<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Welcome To My Own Blog</title>
    <url>/ZLY201.github.io/2020/07/03/hellow/</url>
    <content><![CDATA[<div style="text-align: center">
    <table>
        <tr><td colspan="2" style="text-align: center"><font size="4">博主个人信息</font></td></tr>
        <tr>
            <td style="text-align: center">姓名</td>
            <td style="text-align: center">保密</td>
        </tr>
        <tr>
            <td style="text-align: center">性别</td>
            <td style="text-align: center">反正不是女的</td>
        </tr>
        <tr>
            <td style="text-align: center">年龄</td>
            <td style="text-align: center">别问，问就是18（orz）</td>
        </tr>
        <tr>
            <td style="text-align: center">学校</td>
            <td style="text-align: center">中国地质大学（武汉）</td>
        </tr>
        <tr>
            <td style="text-align: center">专业</td>
            <td style="text-align: center">计算机科学与技术</td>
        </tr>
        <tr><td rowspan="4" style="text-align: center">获奖情况</td></tr>
        <tr><td style="text-align: center">1. 信工学院编程大赛一等奖</td></tr>
        <tr><td style="text-align: center">2. 中国地质大学（武汉）暨华中地区ICPC邀请赛三等奖</td></tr>
        <tr><td style="text-align: center">3. 中国地质大学（武汉）数学建模校内选拔赛一等奖</td></tr>
    </table>
</div>

<p>欢迎访问我的其他博客主页（可能有惊喜哦）<br><a href="https://blog.csdn.net/weixin_44211980" target="_blank" rel="noopener">csdn博客主页</a><br><a href="https://www.luogu.com.cn/blog/226316/" target="_blank" rel="noopener">luogu博客主页</a></p>
<p>祝您玩的开心（0^_^0）！</p>
]]></content>
      <categories>
        <category>Hellow</category>
      </categories>
  </entry>
  <entry>
    <title>Interesting Yang Hui Triangle POJ - 3146</title>
    <url>/ZLY201.github.io/2020/07/09/POJ%20-%203146/</url>
    <content><![CDATA[<h2 id="Interesting-Yang-Hui-Triangle-POJ-3146"><a href="#Interesting-Yang-Hui-Triangle-POJ-3146" class="headerlink" title="Interesting Yang Hui Triangle POJ - 3146"></a><a href="http://poj.org/problem?id=3146" target="_blank" rel="noopener">Interesting Yang Hui Triangle POJ - 3146</a></h2><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>问你杨辉三角第n行有多少个数不能被p整除</p>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>杨辉三角第n行第i个数为$C_{n}^{i-1}$<br>根据卢卡斯定理我们可知，假设$a$和$b$在$p$进制下分别表示为$a_{k}a_{k-1}…a_{0}$和$b_{k}b_{k-1}…b_{0}$，那么<br>$C_{a}^{b} \equiv {C_{a_{k}}^{b_{k}}C_{a_{k-1}}^{b_{k-1}}…C_{a_{0}}^{b_{0}}} \pmod {p}$<br>要使得$C_{a}^{b}$不能被p整除，那么$\forall {i} \in [0, k]$，$a_{k} \geq b_{k}$<br>根据计数原理，我们求出p进制下的$n=n_{k}n_{k-1}…n_{0}$，那么答案即为$(n_{0} + 1)(n_{1} + 1)…(n_{k} + 1)$</p>
<h3 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h3><div><div class="fold_hider"><div class="close hider_title"></div></div><div class="fold">
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ll p, n;</span><br><span class="line">	<span class="keyword">int</span> cas = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; p &gt;&gt; n) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!p &amp;&amp; !n) <span class="keyword">break</span>;</span><br><span class="line">		ll ans = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span> (n) &#123;</span><br><span class="line">			ans = ans * (n % p + <span class="number">1</span>) % <span class="number">10000</span>;</span><br><span class="line">			n /= p;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Case %d: %04lld\n"</span>, ++cas, ans);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></div>]]></content>
      <categories>
        <category>POJ</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>POJ</tag>
        <tag>卢卡斯定理</tag>
      </tags>
  </entry>
  <entry>
    <title>青蛙的约会 POJ - 1061</title>
    <url>/ZLY201.github.io/2020/07/08/POJ%20-%201061/</url>
    <content><![CDATA[<h2 id="青蛙的约会-POJ-1061"><a href="#青蛙的约会-POJ-1061" class="headerlink" title="青蛙的约会 POJ - 1061"></a><a href="http://poj.org/problem?id=1061" target="_blank" rel="noopener">青蛙的约会 POJ - 1061</a></h2><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>两只青蛙在L长的圆形跑道上玩跳跳乐，青蛙A的出发点坐标为x，一次能跳m米，青蛙B的出发点坐标y，一次能跳n米，他们跳一次时间相同，同时起跳，问你跳几次能相遇</p>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>设t次后相遇<br>$x + mt \equiv {y + nt} \pmod {L}$<br>$(x + mt) - (y + nt) = qL$<br>$(m - n)t - qL = (y - x)$<br>$(m - n)t + qL = (x - y)$<br>是不是长得很像$ax + by = c$<br>用拓展欧几里得定理求解t即可</p>
<h3 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h3><div><div class="fold_hider"><div class="close hider_title"></div></div><div class="fold">
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a, ll b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> !b ? a : gcd(b, a % b);</span><br><span class="line">&#125;</span><br><span class="line">pair&lt;ll, ll&gt; exgcd(ll a, ll b) &#123;</span><br><span class="line">	<span class="keyword">if</span> (!b) <span class="keyword">return</span> pair&lt;ll, ll&gt;(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">	pair&lt;ll, ll&gt; temp = exgcd(b, a % b);</span><br><span class="line">	<span class="keyword">return</span> pair&lt;ll, ll&gt;(temp.second, temp.first - a / b * temp.second);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">cin</span>.tie(<span class="number">0</span>), <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">	ll x, y, m, n, l;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y &gt;&gt; m &gt;&gt; n &gt;&gt; l;</span><br><span class="line">	ll a = n - m, b = l;</span><br><span class="line">	ll g = gcd(a, b);</span><br><span class="line">	ll delta = x - y;</span><br><span class="line">	<span class="keyword">if</span> (delta % g) <span class="built_in">cout</span> &lt;&lt; <span class="string">"Impossible\n"</span>;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		pair&lt;ll, ll&gt; pp = exgcd(a, b);</span><br><span class="line">		ll t = pp.first, p = pp.second;</span><br><span class="line">		ll mod = l / g;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; (delta / g * t % mod + mod) % mod &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></div>]]></content>
      <categories>
        <category>POJ</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>POJ</tag>
        <tag>拓展欧几里得定理</tag>
      </tags>
  </entry>
  <entry>
    <title>C Looooops POJ - 2115</title>
    <url>/ZLY201.github.io/2020/07/08/POJ%20-%202115/</url>
    <content><![CDATA[<h2 id="C-Looooops-POJ-2115"><a href="#C-Looooops-POJ-2115" class="headerlink" title="C Looooops POJ - 2115"></a><a href="http://poj.org/problem?id=2115" target="_blank" rel="noopener">C Looooops POJ - 2115</a></h2><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (variable = A; variable != B; variable += C) &#123;</span><br><span class="line">	i = (i % (<span class="number">1</span> &lt;&lt; k));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>给你A，B，C和K问你上述代码中循环的次数是多少</p>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>设运行次数为$N$<br>$(A + C \times N) \bmod {2^{k}} = B$<br>$NC + M2^{k} = B - A$<br>是不是长得很像$ax + by = c$<br>利用拓展欧几里得算法求出最小的N即可</p>
<h3 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h3><div><div class="fold_hider"><div class="close hider_title"></div></div><div class="fold">
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a, ll b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> !b ? a : gcd(b, a % b);</span><br><span class="line">&#125;</span><br><span class="line">pair&lt;ll, ll&gt; exgcd(ll a, ll b) &#123;</span><br><span class="line">	<span class="keyword">if</span> (!b) <span class="keyword">return</span> pair&lt;ll, ll&gt;(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">	pair&lt;ll, ll&gt; temp = exgcd(b, a % b);</span><br><span class="line">	<span class="keyword">return</span> pair&lt;ll, ll&gt;(temp.second, temp.first - a / b * temp.second);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">cin</span>.tie(<span class="number">0</span>), <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">	ll a, b, c, k;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; k) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!a &amp;&amp; !b &amp;&amp; !c &amp;&amp; !k) <span class="keyword">break</span>;</span><br><span class="line">		ll kk = (<span class="number">1l</span>l &lt;&lt; k);</span><br><span class="line">		pair&lt;ll, ll&gt; pp = exgcd(c, kk);</span><br><span class="line">		ll n = pp.first, m = pp.second;</span><br><span class="line">		ll delta = b - a;</span><br><span class="line">		ll g = gcd(c, kk);</span><br><span class="line">		ll mod = kk / g;</span><br><span class="line">		<span class="keyword">if</span> (delta % g) <span class="built_in">cout</span> &lt;&lt; <span class="string">"FOREVER\n"</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; (delta / g * n % mod + mod) % mod &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></div>]]></content>
      <categories>
        <category>POJ</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>POJ</tag>
        <tag>拓展欧几里得定理</tag>
      </tags>
  </entry>
  <entry>
    <title>数论四大定理</title>
    <url>/ZLY201.github.io/2020/07/07/%E6%95%B0%E8%AE%BA%E5%9B%9B%E5%A4%A7%E5%AE%9A%E7%90%86/</url>
    <content><![CDATA[<h2 id="欧几里得算法"><a href="#欧几里得算法" class="headerlink" title="欧几里得算法"></a>欧几里得算法</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>欧几里德算法又称辗转相除法，是指用于计算两个正整数a，b的最大公约数。其公式为$gcd(a, b) = gcd(b, a \bmod b)$</p>
<h3 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h3><p>证明如下：<br>不妨设$a &gt; b$，$gcd(a, b)=n$<br>$a = k_{1}n$，$b = k_{2}n$<br>那么$a - b = (k_{1} - k_{2}) \times n$<br>易得$gcd(a, b) = gcd(b, a - b)=gcd(b, a - 2b)=…=gcd(b, a \bmod b)$</p>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><div><div class="fold_hider"><div class="close hider_title"></div></div><div class="fold">
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a, ll b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> b == <span class="number">0</span> ? a : gcd(b, a % b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></div>
<h2 id="拓展欧几里得算法"><a href="#拓展欧几里得算法" class="headerlink" title="拓展欧几里得算法"></a>拓展欧几里得算法</h2><h3 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h3><p>找到最小的$x$和$y$使得式子$ax + by = gcd(a, b)$成立</p>
<h3 id="求解"><a href="#求解" class="headerlink" title="求解"></a>求解</h3><p>不妨设$x &gt; y$<br>若有$ax + by = gcd(a, b)$<br>必有$bx_{1} + (a \bmod b)y_{1}=gcd(b, a \bmod b) = gcd(a, b)$<br>$bx_{1} + (a - [\frac{a}{b}] \times b)y_{1} = gcd(a, b)$<br>$bx_{1} + ay_{1} - [\frac{a}{b}] \times b \times y = gcd(a, b)$<br>$ay_{1} + (x_{1} - [\frac{a}{b}] \times y_{1})b=gcd(a, b)=ax+by$<br>那么显然存在解$x = y_{1}, y = x_{1} - [\frac{a}{b}] \times y_{1}$</p>
<p>这样就可以对式子进行递归求解了，边界条件为$b = 0$时$x_{k}=1, y_{k}=0$</p>
<p>如果你不希望解出现负数的话，可以使用下面的式子进行处理<br>$x = (x + b) \bmod b \qquad y = (y + a) \bmod a$</p>
<h3 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h3><div><div class="fold_hider"><div class="close hider_title"></div></div><div class="fold">
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">pair&lt;ll, ll&gt; exgcd(ll a, ll b) &#123;</span><br><span class="line">	<span class="keyword">if</span> (!b) <span class="keyword">return</span> pair&lt;ll, ll&gt;(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">	pair&lt;ll, ll&gt; temp = exgcd(b, a % b);</span><br><span class="line">	<span class="keyword">return</span> pair&lt;ll, ll&gt;(temp.second, temp.first - a / b * temp.second);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></div>
<h3 id="拓展1"><a href="#拓展1" class="headerlink" title="拓展1"></a>拓展1</h3><p>找到最小的$x$和$y$使得式子$ax + by = c$成立<br>不妨设$gcd(a, b)=n$<br>$a = k_{1}n$，$b = k_{2}n$<br>那么上式即为$k_{1}n \times x + k_{2}n \times y = c$<br>很显然上式有解的充要条件为$n|c$</p>
<p>我们考虑$ax + by = gcd(a, b)$的最小解为$x和y$<br>那么$\frac{c}{gcd(a, b)} \times (ax’ + by’) = \frac{c}{gcd(a, b)} \times gcd(a, b)$<br>令$x = \frac{c}{gcd(a, b)} \times x’$，$y = \frac{c}{gcd(a, b)} \times y’$<br>显然x和y为$ax + by = c$的最小解</p>
<h3 id="拓展2"><a href="#拓展2" class="headerlink" title="拓展2"></a>拓展2</h3><p>若$ab + kp = 1$，即$a \times b \equiv 1 \pmod p$，那么根据拓展欧几里得算法求解出来的$b$即为$a$在模$p$意义下的乘法逆元</p>
<h2 id="中国剩余定理"><a href="#中国剩余定理" class="headerlink" title="中国剩余定理"></a>中国剩余定理</h2><h3 id="描述-2"><a href="#描述-2" class="headerlink" title="描述"></a>描述</h3><p>中国剩余定理又称孙子定理，中国南北朝时期（公元5世纪）的数学著作《孙子算经》卷下第二十六题，叫做“物不知数”问题，原文如下：</p>
<blockquote>
<p>“今有物不知其数，三三数之剩二，五五数之剩三，七七数之剩二，问物几何？”</p>
</blockquote>
<p>意思就是有一个数除3余2，除5余3，除7余2，问你这个数是多少</p>
<p>这类问题在数论中我们把它称作一元线性同余方程组问题，数学公式表述如下：<br>$x \equiv {a_{1}} \pmod {m_{1}}$<br>$x \equiv {a_{2}} \pmod {m_{2}}$<br>$…$<br>$x \equiv {a_{n}} \pmod {m_{n}}$<br>其中$m_{1}, m_{2}, …, m_{n}两两互质$<br>求x的最小非负整数解</p>
<h3 id="求解-1"><a href="#求解-1" class="headerlink" title="求解"></a>求解</h3><p>令$M=\prod_{i=1}^{n}m_{i}$，即$M=lcm(m_{1}, m_{2}, …, m_{n})$<br>设$t_{i}$为$\frac{M}{m_{i}}t_{i} \equiv {1} \pmod {m_{i}}$的最小非负整数解<br>那么$x = \sum_{i=1}^{m_{i}}a_{i}\frac{M}{m_{i}}t_{i}$为同余方程组的最小非负整数解<br>而$t_{i}$显然为$\frac{M}{m_{i}}t_{i} \equiv {1} \pmod {m_{i}}$关于$m_{i}$的逆元（因为$\frac{M}{m_{i}}t_{i} \equiv {1} \pmod {m_{i}}$）</p>
<h3 id="证明-1"><a href="#证明-1" class="headerlink" title="证明"></a>证明</h3><p>将$x$带入到第$k$个方程中<br>对于$\forall i \neq k$，$a_{i}\frac{M}{m_{i}}t_{i} \equiv {0} \pmod {m_{k}}$，因为$\frac{M}{m_{i}} \bmod m_{k} = 0$<br>对于$i = k$，由于$\frac{M}{m_{i}}t_{i} \equiv {1} \pmod {m_{i}}$，那么自然$a_{i}\frac{M}{m_{i}}t_{i} \equiv {a_{i}} \pmod {m_{k}}$，即得证</p>
<h3 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h3><div><div class="fold_hider"><div class="close hider_title"></div></div><div class="fold">
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">pair&lt;ll, ll&gt; exgcd(ll a, ll b) &#123;</span><br><span class="line">	<span class="keyword">if</span> (!b) <span class="keyword">return</span> pair&lt;ll, ll&gt;(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">	pair&lt;ll, ll&gt; temp = exgcd(b, a % b);</span><br><span class="line">	<span class="keyword">return</span> pair&lt;ll, ll&gt;(temp.second, temp.first - a / b * temp.second);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">CRT</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	ll M = <span class="number">1</span>, res = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) M *= m[i];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">		ll tmp = M / m[i];</span><br><span class="line">		pair&lt;ll, ll&gt; pp = exgcd(tmp, m[i]);</span><br><span class="line">		res = (res + a[i] * pp.first % M * tmp % M) % M;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> (res + M) % M;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></div>
<h2 id="拓展中国剩余定理"><a href="#拓展中国剩余定理" class="headerlink" title="拓展中国剩余定理"></a>拓展中国剩余定理</h2><h3 id="描述-3"><a href="#描述-3" class="headerlink" title="描述"></a>描述</h3><p>$x \equiv {a_{1}} \pmod {m_{1}}$<br>$x \equiv {a_{2}} \pmod {m_{2}}$<br>$…$<br>$x \equiv {a_{n}} \pmod {m_{n}}$<br>不保证$m_{1}, m_{2}, …, m_{n}两两互质$<br>求x的最小非负整数解</p>
<h3 id="求解-2"><a href="#求解-2" class="headerlink" title="求解"></a>求解</h3><p><img src="../数论四大定理/拓展中国剩余定理-1.png" alt=""><br><img src="../数论四大定理/拓展中国剩余定理-2.png" alt=""></p>
<h3 id="Code-3"><a href="#Code-3" class="headerlink" title="Code"></a>Code</h3><div><div class="fold_hider"><div class="close hider_title"></div></div><div class="fold">
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">pair&lt;ll, ll&gt; exgcd(ll a, ll b) &#123;</span><br><span class="line">	<span class="keyword">if</span> (!b) <span class="keyword">return</span> pair&lt;ll, ll&gt;(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">	pair&lt;ll, ll&gt; temp = exgcd(b, a % b);</span><br><span class="line">	<span class="keyword">return</span> pair&lt;ll, ll&gt;(temp.second, temp.first - a / b * temp.second);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">excrt</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	ll aa = a[<span class="number">1</span>], bb = b[<span class="number">1</span>];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">		ll d = gcd(aa, a[i]);</span><br><span class="line">		pair&lt;ll, ll&gt; temp = exgcd(aa / d, a[i] / d);</span><br><span class="line">		<span class="keyword">while</span> (temp.first &lt; <span class="number">0</span>) temp.first += a[i] / d;</span><br><span class="line">		<span class="keyword">if</span> ((b[i] - bb) % d) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		ll p = a[i] / d;</span><br><span class="line">		ll lcm = aa * p;</span><br><span class="line">		bb = ((temp.first * (b[i] - bb) / d % p + p) % p * aa % lcm + bb) % lcm;</span><br><span class="line">		aa = lcm;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> bb;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></div>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>1.中国剩余定理与扩展中国剩余定理-csdn<br><a href="https://blog.csdn.net/enjoy_pascal/article/details/98521475" target="_blank" rel="noopener">https://blog.csdn.net/enjoy_pascal/article/details/98521475</a></p>
<p>2.孙子定理-百度百科<br><a href="https://baike.baidu.com/item/%E5%AD%99%E5%AD%90%E5%AE%9A%E7%90%86/2841597" target="_blank" rel="noopener">https://baike.baidu.com/item/%E5%AD%99%E5%AD%90%E5%AE%9A%E7%90%86/2841597</a></p>
<p>3.拓展欧几里得算法-简书<br><a href="https://www.jianshu.com/p/9d60995a0e89" target="_blank" rel="noopener">https://www.jianshu.com/p/9d60995a0e89</a></p>
]]></content>
      <categories>
        <category>数论</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>LCM Extreme LightOJ - 1375</title>
    <url>/ZLY201.github.io/2020/07/06/LightOJ%20-%201375/</url>
    <content><![CDATA[<h2 id="LCM-Extreme-LightOJ-1375"><a href="#LCM-Extreme-LightOJ-1375" class="headerlink" title="LCM Extreme LightOJ - 1375"></a><a href="http://lightoj.com/volume_showproblem.php?problem=1375" target="_blank" rel="noopener">LCM Extreme LightOJ - 1375</a></h2><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="title">allPairLcm</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">            res += lcm(i, j); <span class="comment">// lcm means least common multiple</span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>给出n，输出上述程序的运行结果</p>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>$res=\sum_{i=1}^{n}\sum_{j=i+1}^{n}lcm(i, j)=\sum_{i=2}^{n}\sum_{j=1}^{i-1}lcm(i, j)$<br>令$s(x)=\sum_{i=1}^{x-1}lcm(i, x)$，那么答案就是$\sum_{i=2}^{n}s(i)$，显然可以预处理<br>对于$s(x)$，有：<br>$s(x)=\sum_{i=1}^{x-1}lcm(i, x)=\sum_{i=1}^{x-1}\frac{i \times x}{gcd(i, x)}=x \times \sum_{i=1}^{x-1}\frac{i}{gcd(i, x)}$<br>令$g = gcd(i, x)$<br>$s(x)=x \times \sum_{i=1}^{x-1}\frac{i}{g}$<br>其中$g|x$，并且$gcd(i, x) = g$<br>令$i = \frac{i}{g}$，那么$s(x)=x \times \sum_{i=1}^{\frac{x}{g}-1}i$<br>其中$gcd(i, \frac{x}{g})=1$，即$i$与$\frac{x}{g}$互质<br>由欧拉定理可知</p>
<blockquote>
<p>小于$n$，且与$n$互质的数之和等于$\frac{n \times \phi(n)}{2}$</p>
</blockquote>
<p>那么$s(x)=x \times \sum_{g|x}\frac{\frac{x}{g} \times \phi(\frac{x}{g})}{2}$<br>这样我们预处理出$\phi(n)$，然后枚举$g$求出$s(x)$，最后求出前缀和即可</p>
<h3 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h3><div><div class="fold_hider"><div class="close hider_title"></div></div><div class="fold">
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">3e6</span> + <span class="number">10</span>;</span><br><span class="line">ll phi[maxn];</span><br><span class="line">ll s[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">eulor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	phi[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; maxn; ++i) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!phi[i]) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; maxn; j += i) &#123;</span><br><span class="line">				<span class="keyword">if</span> (!phi[j]) phi[j] = j;</span><br><span class="line">				phi[j] = phi[j] / i * (i - <span class="number">1</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> g = <span class="number">1</span>; g &lt; maxn; ++g) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> x = g; x &lt; maxn; x += g) &#123;</span><br><span class="line">			<span class="keyword">int</span> t = x / g;</span><br><span class="line">			s[x] += phi[t] * t / <span class="number">2</span> * x;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; maxn; ++i) &#123;</span><br><span class="line">		s[i] += s[i - <span class="number">1</span>];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> T;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">	<span class="keyword">int</span> cas = <span class="number">0</span>;</span><br><span class="line">	eulor();</span><br><span class="line">	<span class="keyword">while</span> (T--) &#123;</span><br><span class="line">		<span class="keyword">int</span> n;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Case %d: %llu\n"</span>, ++cas, s[n]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></div>
<h3 id="编写参考"><a href="#编写参考" class="headerlink" title="编写参考"></a>编写参考</h3><p><a href="https://www.cnblogs.com/-Wallace-/p/12897967.html" target="_blank" rel="noopener">https://www.cnblogs.com/-Wallace-/p/12897967.html</a></p>
]]></content>
      <categories>
        <category>LightOJ</category>
      </categories>
      <tags>
        <tag>LightOJ</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>Bank Robbery LightOJ - 1163</title>
    <url>/ZLY201.github.io/2020/07/06/LightOJ%20-%201163/</url>
    <content><![CDATA[<h2 id="Bank-Robbery-LightOJ-1163"><a href="#Bank-Robbery-LightOJ-1163" class="headerlink" title="Bank Robbery LightOJ - 1163"></a><a href="http://lightoj.com/volume_showproblem.php?problem=1163" target="_blank" rel="noopener">Bank Robbery LightOJ - 1163</a></h2><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>给你k，输出所有使得$A - [\frac{A}{10}] = K$成立的A</p>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>$A - [\frac{A}{10}] = K$<br>$A - \frac{A - A % 10}{10} = k$<br>$9A = 10k - A % 10$<br>$9A = 10k - m$</p>
<p>由于$0\leq m \leq 10$，直接枚举即可</p>
<p>要注意这题longlong会溢出</p>
<h3 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h3><div><div class="fold_hider"><div class="close hider_title"></div></div><div class="fold">
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">3e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> T;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">	<span class="keyword">int</span> cas = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (T--) &#123;</span><br><span class="line">		ll n;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;n);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Case %d:"</span>, ++cas);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">9</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">			<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> tmp = <span class="number">10</span> * n - i;</span><br><span class="line">			<span class="keyword">if</span> (tmp % <span class="number">9</span> == <span class="number">0</span> &amp;&amp; tmp / <span class="number">9</span> % <span class="number">10</span> == i) <span class="built_in">printf</span>(<span class="string">" %lld"</span>, tmp / <span class="number">9</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></div>]]></content>
      <categories>
        <category>LightOJ</category>
      </categories>
      <tags>
        <tag>LightOJ</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>Finding LCM LightOJ - 1215</title>
    <url>/ZLY201.github.io/2020/07/06/LightOJ%20-%201215/</url>
    <content><![CDATA[<h2 id="Finding-LCM-LightOJ-1215"><a href="#Finding-LCM-LightOJ-1215" class="headerlink" title="Finding LCM LightOJ - 1215"></a><a href="http://lightoj.com/volume_showproblem.php?problem=1215" target="_blank" rel="noopener">Finding LCM LightOJ - 1215</a></h2><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>$LCM(a, b, c) = L$<br>现在告诉你a, b, L，问你c的最小值是多少</p>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>设$lcm = LCM(a, b)$，即求最小的c使得$LCM(lcm, c) = L$</p>
<p>设$g = gcd(lcm, c)$，那么$\frac{lcm \times c}{g}=L$</p>
<p>$c = \frac{L}{lcm} \times g$</p>
<p>设$k = \frac{L}{lcm}$，那么$c = k \times g$</p>
<p>又因为$gcd(lcm, c) = g$</p>
<p>所以$gcd(lcm, k \times g) = g$</p>
<p>即$gcd(\frac{lcm}{g}, k) = 1$</p>
<p>由于k已知，要使c最小即使g最小，并且$g|lcm$</p>
<p>那么我们$O(\sqrt{n})$时间找到lcm的最小因子使得$gcd(\frac{lcm}{g}, k) = 1$成立即可</p>
<h3 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h3><div><div class="fold_hider"><div class="close hider_title"></div></div><div class="fold">
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">3e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a, ll b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> b == <span class="number">0</span> ? a : gcd(b, a % b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> T;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">	<span class="keyword">int</span> cas = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (T--) &#123;</span><br><span class="line">		ll a, b, l;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%lld%lld%lld"</span>, &amp;a, &amp;b, &amp;l);</span><br><span class="line">		ll lcm = a / gcd(a, b) * b;</span><br><span class="line">		<span class="keyword">if</span> (l % lcm) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"Case %d: impossible\n"</span>, ++cas);</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		ll k = l / lcm;</span><br><span class="line">		ll kk = <span class="built_in">sqrt</span>(lcm);</span><br><span class="line">		ll ans = l;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= kk; ++i) &#123;</span><br><span class="line">			<span class="keyword">if</span> (lcm % i == <span class="number">0</span>) &#123;</span><br><span class="line">				<span class="keyword">if</span> (gcd(lcm / i, k) == <span class="number">1</span>)</span><br><span class="line">					ans = min(ans, <span class="number">1l</span>l * i * k);</span><br><span class="line">				<span class="keyword">if</span> (gcd(i, k) == <span class="number">1</span>)</span><br><span class="line">					ans = min(ans, lcm / i * k);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Case %d: %lld\n"</span>, ++cas, ans);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></div>]]></content>
      <categories>
        <category>LightOJ</category>
      </categories>
      <tags>
        <tag>LightOJ</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>A New Function LightOJ - 1098</title>
    <url>/ZLY201.github.io/2020/07/06/LightOJ%20-%201098/</url>
    <content><![CDATA[<h2 id="A-New-Function-LightOJ-1098"><a href="#A-New-Function-LightOJ-1098" class="headerlink" title="A New Function LightOJ - 1098"></a><a href="http://lightoj.com/volume_showproblem.php?problem=1098" target="_blank" rel="noopener">A New Function LightOJ - 1098</a></h2><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>定义$SOD(n)$为$n$除$1$和$n$外的所有正因子之和，例如：<br>$SOD(24)=2+3+4+6+8+12=35$<br>定义$CSOD(n)=\sum_{i=1}^{n}SOD(i)$<br>让你求$2e9$内任意n的$CSOD(n)$</p>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>对于每一个数，我们可以把它写成$a \times b$的形式，那么对于答案的贡献显然就是$a+b(a!=b!=1!=n)$，而对于一个因子$i$，它在$n$内出现的次数应当是$\frac{n}{i}-1$，举个例子：<br>假设$n = 12$<br>$i = 2$时<br>$4 = 2 \times 2$<br>$6 = 2 \times 3$<br>$8 = 2 \times 4$<br>$10 = 2 \times 5$<br>$12 = 2 \times 6$<br>$2$需要被统计$\frac{12}{2}-1= 5$次</p>
<p>但是这样的复杂度是$O(n)$，显然不可行，观察上例，发现右边的因子是连续的，并且根据左边因子的出现次数我们可以得到一个等差数列，这样一来，我们就可以在$O(\sqrt{n})$时间内求出答案</p>
<p>这样做有一个问题，如果对于每一个左因子我统计$\frac{n}{i}-1$次，然后统计右边因子，会出现重复</p>
<p>承接上例<br>$i = 3$时<br>$6 = 3 \times 2$<br>$9 = 3 \times 3$<br>$12 = 3 \times 4$<br>对于$6$来说$6 = 3 \times 2$已经在统计$2$的时候统计过了，所以我们统计时右边因子的左区间为$i + 1$，右区间为$\frac{n}{i}$，然后单独计算平方数的贡献即可</p>
<h3 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h3><div><div class="fold_hider"><div class="close hider_title"></div></div><div class="fold">
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> T;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">	<span class="keyword">int</span> cas = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (T--) &#123;</span><br><span class="line">		<span class="keyword">int</span> n;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">		ll res = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> k = <span class="built_in">sqrt</span>(n);</span><br><span class="line">		<span class="comment">//枚举左边因子</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= k; ++i) &#123;</span><br><span class="line">			res += i;	<span class="comment">//单独统计平方数的因子</span></span><br><span class="line">			<span class="comment">//右边因子的等差数列区间</span></span><br><span class="line">			ll l = i + <span class="number">1</span>, r = n / i;</span><br><span class="line">			<span class="keyword">if</span> (r &lt; l) <span class="keyword">continue</span>;</span><br><span class="line">			res += (r - l + <span class="number">1</span>) * i + (r - l + <span class="number">1</span>) * (l + r) / <span class="number">2</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Case %d: %lld\n"</span>, ++cas, res);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></div>
]]></content>
      <categories>
        <category>LightOJ</category>
      </categories>
      <tags>
        <tag>LightOJ</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>How Many Points? LightOJ - 1077</title>
    <url>/ZLY201.github.io/2020/07/05/LightOJ%20-%201077/</url>
    <content><![CDATA[<h2 id="How-Many-Points-LightOJ-1077"><a href="#How-Many-Points-LightOJ-1077" class="headerlink" title="How Many Points? LightOJ - 1077"></a><a href="http://lightoj.com/volume_showproblem.php?problem=1077" target="_blank" rel="noopener">How Many Points? LightOJ - 1077</a></h2><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>多组输入，每次给你两个坐标，问你这两点连成的线段上坐标均为整数的个数是多少</p>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>考虑x，y为满足条件的一组坐标，那么有</p>
<p>$\frac{y_{2}-y_{1}}{x_{2}-x_{1}}=\frac{y-y_{1}}{x-x_{1}}$</p>
<p>将$(x_{1}, y_{1})$当做坐标原点，则有</p>
<p>$\frac{y_{2}}{x_{2}}=\frac{y}{x}$</p>
<p>$\frac{ngcd(y_{2},x_{2})}{mgcd(y_{2},x_{2})}=\frac{n}{m}=\frac{2n}{2m}=…=\frac{ngcd(y_{2},x_{2})}{mgcd(y_{2},x_{2})}$</p>
<p>那么其总个数即为$gcd(abs(x_{2}-x_{1}), abs(y_{2}-y_{1})) + 1$</p>
<h3 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h3><div><div class="fold_hider"><div class="close hider_title"></div></div><div class="fold">
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll x, ll y)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> y == <span class="number">0</span> ? x : gcd(y, x % y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> T;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">	<span class="keyword">int</span> cas = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (T--) &#123;</span><br><span class="line">		ll x1, y1, x2, y2;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%lld%lld%lld%lld"</span>, &amp;x1, &amp;y1, &amp;x2, &amp;y2);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Case %d: %lld\n"</span>, ++cas, gcd(<span class="built_in">abs</span>(x1 - x2), <span class="built_in">abs</span>(y1 - y2)) + <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></div>]]></content>
      <categories>
        <category>LightOJ</category>
      </categories>
      <tags>
        <tag>LightOJ</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>Digits of Factorial LightOJ - 1045</title>
    <url>/ZLY201.github.io/2020/07/05/LightOJ%20-%201045/</url>
    <content><![CDATA[<h2 id="Digits-of-Factorial-LightOJ-1045"><a href="#Digits-of-Factorial-LightOJ-1045" class="headerlink" title="Digits of Factorial LightOJ - 1045"></a><a href="http://lightoj.com/volume_showproblem.php?problem=1045" target="_blank" rel="noopener">Digits of Factorial LightOJ - 1045</a></h2><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>多组输入，每次给你一个n和m，输出n的阶乘在m进制下的位数</p>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>考虑n!在m下的位数是k，则有：</p>
<p>$m^{k+1}\leq n!&lt;m^{k+2}$</p>
<p>$k+1\leq log_{m}^{n!}&lt;k+2$</p>
<p>$k+1\leq log_{m}^{1} + log_{m}^{2} + … + log_{m}^{n}&lt;k+2$</p>
<p>那么预处理处范围内的lg和，最后利用$log_{m}^{n}=\frac {lg^{n}}{lg^{m}}$进行求解即可</p>
<h3 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h3><div><div class="fold_hider"><div class="close hider_title"></div></div><div class="fold">
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">double</span> sum[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> T;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">	<span class="keyword">int</span> cas = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; maxn; ++i) &#123;</span><br><span class="line">		sum[i] = sum[i - <span class="number">1</span>] + <span class="built_in">log</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (T--) &#123;</span><br><span class="line">		<span class="keyword">int</span> n, m;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">		<span class="keyword">double</span> res = sum[n] / <span class="built_in">log</span>(m);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Case %d: %d\n"</span>, ++cas, <span class="keyword">int</span>(res) + <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></div>
]]></content>
      <categories>
        <category>LightOJ</category>
      </categories>
      <tags>
        <tag>LightOJ</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>唯一分解定理</title>
    <url>/ZLY201.github.io/2020/07/05/%E5%94%AF%E4%B8%80%E5%88%86%E8%A7%A3%E5%AE%9A%E7%90%86/</url>
    <content><![CDATA[<h2 id="唯一分解定理"><a href="#唯一分解定理" class="headerlink" title="唯一分解定理"></a>唯一分解定理</h2><p>根据欧拉定理，一个数n可以被写成如下格式</p>
<p>$n = p_{1}^{a_{1}}p_{2}^{a_{2}}p_{3}^{a_{3}}…p_{k}^{a_{k}}$</p>
<p>其中$p_{i}$为n的质因子</p>
<p>那么有如下结论</p>
<ol>
<li>设$F(n)$代表n的正因子数目，则$F(n) = (a_{1}+ 1)(a_{2} + 1)(a_{3} + 1)…(a_{n} + 1)$</li>
<li>设$G(n)$代表n的正因子之和，则<br>$G(n) = (1 + p_{1} + p_{1}^{2}+…+p_{1}^{a_{1}})(1 + p_{2} + p_{2}^{2}+…+p_{2}^{a_{2}})…(1 + p_{k} + p_{2}^{3}+…+p_{k}^{a_{k}})=\prod_{i=1}^{n}(\frac{p_{i}^{a_{i} + 1}-1}{p_{i}-1})$</li>
</ol>
<h2 id="例题：Trailing-Zeroes-I-LightOJ-1028"><a href="#例题：Trailing-Zeroes-I-LightOJ-1028" class="headerlink" title="例题：Trailing Zeroes (I) LightOJ - 1028"></a>例题：<a href="http://http://lightoj.com/volume_showproblem.php?problem=1028" target="_blank" rel="noopener">Trailing Zeroes (I) LightOJ - 1028</a></h2><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>有多组输入，每次给你一个正整数n，问你n的除1之外的正因子数目</p>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>因为有多组输入，那么如果对于每一个n进行暴力统计显然会超时，可以先预处理出$10^{6}$以内的质数，然后对n进行质数分解，使用公式1进行求解</p>
<h3 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h3><div><div class="fold_hider"><div class="close hider_title"></div></div><div class="fold">
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line"><span class="keyword">bool</span> check[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; maxn; ++i) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!check[i]) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = (i &lt;&lt; <span class="number">1</span>); j &lt; maxn; j += i) &#123;</span><br><span class="line">				check[j] = <span class="literal">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			v.push_back(i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">eulor</span><span class="params">(ll n)</span> </span>&#123;</span><br><span class="line">	ll res = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> len = v.size();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; ll(v[i]) * v[i] &lt;= n &amp;&amp; i &lt; len; ++i) &#123;</span><br><span class="line">		<span class="keyword">if</span> (n % v[i] == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">while</span> (n % v[i] == <span class="number">0</span>) &#123;</span><br><span class="line">				n /= v[i];</span><br><span class="line">				++cnt;</span><br><span class="line">			&#125;</span><br><span class="line">			res *= (cnt + <span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (n &gt; <span class="number">1</span>) res *= <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">return</span> res - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> T;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">	<span class="keyword">int</span> cas = <span class="number">0</span>;</span><br><span class="line">	prime();</span><br><span class="line">	<span class="keyword">while</span> (T--) &#123;</span><br><span class="line">		ll n;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;n);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Case %d: %lld\n"</span>, ++cas, eulor(n));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></div>]]></content>
      <categories>
        <category>数论</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>欧拉函数</title>
    <url>/ZLY201.github.io/2020/07/05/%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h2 id="欧拉函数"><a href="#欧拉函数" class="headerlink" title="欧拉函数"></a>欧拉函数</h2><p>对于一个正整数x，小于且和x互质的正整数（包括1）的个数，计做$\phi(x)$</p>
<p>其通项公式为$\phi(x)=x\prod_{i=1}^{n}(1-\frac{1}{p_{i}})$</p>
<p>其中$p_{i}$代表x的某一个质因数，n为质因数个数</p>
<p>特别的，我们规定$\phi(1)=1$</p>
<p>那么我们根据公式可以求出任意正整数x的$\phi(x)$值，代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ll <span class="title">eular</span><span class="params">(ll n)</span> </span>&#123;</span><br><span class="line">    ll res = n;</span><br><span class="line">    ll k = <span class="built_in">sqrt</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= k; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(n % i == <span class="number">0</span>) &#123;</span><br><span class="line">            res = res / i * (i - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">while</span>(n % i == <span class="number">0</span>) n /= i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n &gt; <span class="number">1</span>) res = res / n * (n - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是如果实时让你输出任意指定范围内x的$\phi(x)$值，上述代码的时间复杂度显然不满足要求，于是我们采取打表的方法求出1-n中所有数的$\phi(x)$值，代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">euler</span><span class="params">(ll n)</span> </span>&#123;</span><br><span class="line">	phi[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!phi[i]) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt;= n; j += i) &#123;</span><br><span class="line">				<span class="keyword">if</span> (!phi[j]) phi[j] = j;</span><br><span class="line">				phi[j] = phi[j] / i * (i - <span class="number">1</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="欧拉函数的性质"><a href="#欧拉函数的性质" class="headerlink" title="欧拉函数的性质"></a>欧拉函数的性质</h2><ol>
<li><p>若n是质数p的k次幂，即$n=p^{k}$，那么有$\phi(n)=(p-1)p^{k-1}$</p>
</li>
<li><p>若n与m互质，那么$\phi(nm)=(n-1)(m-1)=\phi(n)\phi(m)$</p>
</li>
<li><p>若n为奇数，则$\phi(n)=\phi(2n)$</p>
</li>
<li><p>小于n，且与n互质的数之和为$\frac{n \times \phi(n)}{2}$</p>
</li>
</ol>
<h2 id="例题：Mathematically-Hard-LightOJ-1007"><a href="#例题：Mathematically-Hard-LightOJ-1007" class="headerlink" title="例题：Mathematically Hard LightOJ - 1007"></a>例题：<a href="http://lightoj.com/volume_showproblem.php?problem=1007" target="_blank" rel="noopener">Mathematically Hard LightOJ - 1007</a></h2><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>给你正整数a和b，定义$score(x) = n^{2}$，其中n为小于x的质因子的个数，问你区间[a, b]内score(i)的和是多少</p>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>根据定义可知$n = \phi(x)$，那么我们使用打表法线性求出范围内的$\phi(x)$求平方和即可</p>
<h3 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h3><div><div class="fold_hider"><div class="close hider_title"></div></div><div class="fold">
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">5e6</span> + <span class="number">10</span>;</span><br><span class="line">ll phi[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">euler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	phi[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; maxn; ++i) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!phi[i]) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; maxn; j += i) &#123;</span><br><span class="line">				<span class="keyword">if</span> (!phi[j]) phi[j] = j;</span><br><span class="line">				phi[j] = phi[j] / i * (i - <span class="number">1</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; maxn; ++i) &#123;</span><br><span class="line">		phi[i] = phi[i - <span class="number">1</span>] + phi[i] * phi[i];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> T;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">	<span class="keyword">int</span> cas = <span class="number">0</span>;</span><br><span class="line">	euler();</span><br><span class="line">	<span class="keyword">while</span> (T--) &#123;</span><br><span class="line">		<span class="keyword">int</span> a, b;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Case %d: %llu\n"</span>, ++cas, phi[b] - phi[a - <span class="number">1</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></div>]]></content>
      <categories>
        <category>数论</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
</search>
