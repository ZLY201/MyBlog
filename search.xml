<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2020牛客暑期多校训练营（第三场）</title>
    <url>/ZLY201.github.io/2020/07/19/2020%E7%89%9B%E5%AE%A2%E6%9A%91%E6%9C%9F%E5%A4%9A%E6%A0%A1%E8%AE%AD%E7%BB%83%E8%90%A5%EF%BC%88%E7%AC%AC%E4%B8%89%E5%9C%BA%EF%BC%89/</url>
    <content><![CDATA[<h1 id="2020牛客暑期多校训练营（第三场）"><a href="#2020牛客暑期多校训练营（第三场）" class="headerlink" title="2020牛客暑期多校训练营（第三场）"></a><a href="https://ac.nowcoder.com/acm/contest/5668#question" target="_blank" rel="noopener">2020牛客暑期多校训练营（第三场）</a></h1><h2 id="B-Classical-String-Problem"><a href="#B-Classical-String-Problem" class="headerlink" title="B.Classical String Problem"></a>B.Classical String Problem</h2><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>给你一个字符串，有两种操作，一种是问你第$x$个字符是什么，第二种是将前$x(x &gt; 0)$字符移动到末尾，或者将后$x(x &lt; 0)$移动到开头</p>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>考虑在每次询问前，如果将前$x$字符移到了后面，将后$y$字符移动到了前面，那么其相当于是将前$x-y$字符移动到了尾部，所以我们在每次询问前记录其移动总和然后$O(1)$回答就好了</p>
<h3 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h3><div><div class="fold_hider"><div class="close hider_title"></div></div><div class="fold">
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>), <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">    <span class="keyword">int</span> q;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; q;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>, len = s.length();</span><br><span class="line">    <span class="keyword">while</span>(q--) &#123;</span><br><span class="line">        <span class="keyword">char</span> c;</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; c &gt;&gt; x;</span><br><span class="line">        <span class="keyword">if</span>(c == <span class="string">'M'</span>) &#123;</span><br><span class="line">            res = res + x;</span><br><span class="line">            <span class="keyword">if</span>(res &lt; <span class="number">0</span>) res = (len + res) % len;</span><br><span class="line">            <span class="keyword">else</span> res = res % len;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            --x;</span><br><span class="line">            <span class="keyword">if</span>(x &lt;= len - res) <span class="built_in">cout</span> &lt;&lt; s[res + x] &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; s[x - len + res] &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></div>
<h2 id="C-Operation-Love"><a href="#C-Operation-Love" class="headerlink" title="C.Operation Love"></a>C.Operation Love</h2><h3 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h3><p>给你很多个手掌，每个手掌由20个坐标点构成，让你分辨出每个手掌是左手掌还是右手掌，手掌可能会被平移或旋转，但是不会被放大和缩小</p>
<h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><p>首先找到手掌的底边，然后根据横纵坐标判断一下方向就可以了，但是这题的坐标并不是精确坐标，坐标只会精确到$1e^{-6}$，所以在判断边长大小时需要将$eps$设置成$1e^{-5}$或者更大，因为两个$5e^{-7}$的误差会达到$1e^{-6}$</p>
<h3 id="AC代码-1"><a href="#AC代码-1" class="headerlink" title="AC代码"></a>AC代码</h3><div><div class="fold_hider"><div class="close hider_title"></div></div><div class="fold">
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PI 3.1415926535898</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> minxx 1e-5</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">length</span><span class="params">(<span class="keyword">double</span> x,<span class="keyword">double</span> y, <span class="keyword">double</span> x1,<span class="keyword">double</span> y1)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sqrt</span>((x - x1) * (x - x1) + (y - y1) * (y - y1));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">        <span class="keyword">double</span> points[<span class="number">20</span>][<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != <span class="number">20</span>; ++i) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%lf%lf"</span>, &amp;points[i][<span class="number">0</span>], &amp;points[i][<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> dd = <span class="number">19</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != <span class="number">19</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">abs</span>(<span class="number">9.0</span> - length(points[i][<span class="number">0</span>], points[i][<span class="number">1</span>], points[i + <span class="number">1</span>][<span class="number">0</span>], points[i + <span class="number">1</span>][<span class="number">1</span>])) &lt; minxx) &#123;</span><br><span class="line">                dd = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">double</span> len1 = length(points[(dd + <span class="number">19</span>) % <span class="number">20</span>][<span class="number">0</span>], points[(dd + <span class="number">19</span>) % <span class="number">20</span>][<span class="number">1</span>], points[dd][<span class="number">0</span>], points[dd][<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">double</span> len2 = length(points[(dd + <span class="number">1</span>) % <span class="number">20</span>][<span class="number">0</span>], points[(dd + <span class="number">1</span>) % <span class="number">20</span>][<span class="number">1</span>], points[(dd + <span class="number">2</span>) % <span class="number">20</span>][<span class="number">0</span>], points[(dd + <span class="number">2</span>) % <span class="number">20</span>][<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">if</span> (points[(dd + <span class="number">19</span>) % <span class="number">20</span>][<span class="number">1</span>] - points[dd][<span class="number">1</span>] &gt; minxx) &#123;</span><br><span class="line">            <span class="keyword">if</span> (points[(dd + <span class="number">1</span>) % <span class="number">20</span>][<span class="number">0</span>] - points[dd][<span class="number">0</span>] &gt; minxx) &#123;</span><br><span class="line">                <span class="keyword">if</span> (len2 - len1 &gt; minxx) <span class="built_in">printf</span>(<span class="string">"right\n"</span>);</span><br><span class="line">                <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"left\n"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (len2 - len1 &gt;minxx) <span class="built_in">printf</span>(<span class="string">"left\n"</span>);</span><br><span class="line">                <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"right\n"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (points[dd][<span class="number">1</span>] - points[(dd + <span class="number">19</span>) % <span class="number">20</span>][<span class="number">1</span>]&gt; minxx) &#123;</span><br><span class="line">            <span class="keyword">if</span> (points[(dd + <span class="number">1</span>) % <span class="number">20</span>][<span class="number">0</span>] - points[dd][<span class="number">0</span>] &gt; minxx) &#123;</span><br><span class="line">                <span class="keyword">if</span> (len2 - len1 &gt; minxx) <span class="built_in">printf</span>(<span class="string">"left\n"</span>);</span><br><span class="line">                <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"right\n"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (len2 - len1 &gt; minxx) <span class="built_in">printf</span>(<span class="string">"right\n"</span>);</span><br><span class="line">                <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"left\n"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (points[dd][<span class="number">0</span>] - points[(dd + <span class="number">19</span>) % <span class="number">20</span>][<span class="number">0</span>] &gt; minxx) &#123;</span><br><span class="line">                <span class="keyword">if</span> (points[(dd + <span class="number">1</span>) % <span class="number">20</span>][<span class="number">1</span>] - points[dd][<span class="number">1</span>] &gt; minxx) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (len2 - len1 &gt; minxx) <span class="built_in">printf</span>(<span class="string">"right\n"</span>);</span><br><span class="line">                    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"left\n"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (len2 - len1 &gt; minxx) <span class="built_in">printf</span>(<span class="string">"left\n"</span>);</span><br><span class="line">                    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"right\n"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (points[(dd + <span class="number">19</span>) % <span class="number">20</span>][<span class="number">0</span>] - points[dd][<span class="number">0</span>] &gt; minxx) &#123;</span><br><span class="line">                <span class="keyword">if</span> (points[(dd + <span class="number">1</span>) % <span class="number">20</span>][<span class="number">1</span>] - points[dd][<span class="number">1</span>] &gt; minxx) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (len2 - len1 &gt; minxx) <span class="built_in">printf</span>(<span class="string">"left\n"</span>);</span><br><span class="line">                    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"right\n"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (len2 - len1 &gt; minxx) <span class="built_in">printf</span>(<span class="string">"right\n"</span>);</span><br><span class="line">                    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"left\n"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></div>
<h2 id="E-Two-Matchings"><a href="#E-Two-Matchings" class="headerlink" title="E.Two Matchings"></a>E.Two Matchings</h2><h3 id="题目大意-2"><a href="#题目大意-2" class="headerlink" title="题目大意"></a>题目大意</h3><p>给你一个序列$a$，让你找到两个$1-n$的排列$p$和$q$，且$\forall i \in [1, n]，p_{i} \neq q_{i}$，且对于$p$和$q$，$\forall i \in [1, n]，p_{i} \neq i，p_{p_{i}}=i$，问你$\frac{1}{2}\sum_{i=1}^{n}(abs(a_{i}-a_{p_{i}})+abs(a_{i}-a_{q_{i}}))$的最小值是多少</p>
<h3 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h3><p>模拟发现只有4个或6个一组进行互换的情况，其余可以由以上两种情况转换而来</p>
<p>具体请参考：<a href="https://blog.nowcoder.net/n/6facdc43054c4f098b42b2b584de217e?f=comment" target="_blank" rel="noopener">https://blog.nowcoder.net/n/6facdc43054c4f098b42b2b584de217e?f=comment</a></p>
<h3 id="AC代码-2"><a href="#AC代码-2" class="headerlink" title="AC代码"></a>AC代码</h3><div><div class="fold_hider"><div class="close hider_title"></div></div><div class="fold">
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line">ll dp[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>), <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">            dp[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(a + <span class="number">1</span>, a + n + <span class="number">1</span>);</span><br><span class="line">        dp[<span class="number">4</span>] = a[<span class="number">4</span>] - a[<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">6</span>] = a[<span class="number">6</span>] - a[<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">8</span>] = a[<span class="number">8</span>] - a[<span class="number">5</span>] + a[<span class="number">4</span>] - a[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">10</span>; i &lt;= n; i += <span class="number">2</span>) &#123;</span><br><span class="line">            dp[i] = min(dp[i - <span class="number">4</span>] + a[i] - a[i - <span class="number">3</span>], dp[i - <span class="number">6</span>] + a[i] - a[i - <span class="number">5</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; dp[n] * <span class="number">2</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></div>
<h2 id="F-Fraction-Construction-Problem"><a href="#F-Fraction-Construction-Problem" class="headerlink" title="F.Fraction Construction Problem"></a>F.Fraction Construction Problem</h2><h3 id="题目大意-3"><a href="#题目大意-3" class="headerlink" title="题目大意"></a>题目大意</h3><p>给你$a$和$b$（$0&lt;a,b \leq 2 \times 10^{6}$），让你找到满足条件的$c,d,e,f$</p>
<ul>
<li>$\frac{c}{d}-\frac{e}{f}=\frac{a}{b}$</li>
<li>$d &lt; b \ and \ f &lt; b$</li>
<li>$1 \leq c,e \leq 4 \times 10^{12}$</li>
</ul>
<h3 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h3><p>设$g = gcd(a, b)$</p>
<p>若$g \neq 1$，那么$a = ga’, b = gb’$<br>$\frac{cf-ed}{df}=\frac{a’}{b’}$，由最简分数唯一性可知$df = b’，cf-ed=a’$<br>那么我们可令$f=1,e=1,d=b’$，则$c=a’+b’$为一组可行解</p>
<p>若$g=1$，同理，我们令$df = b，cf-ed=a$，但是由于$d &lt; b$，所以我们不能直接令$d=b$，所以我们需要找到$b$的两个因子$d$，$f$，满足$df = b$并且$gcd(d,f)=1$，即$gcd(\frac{b}{d},d)=1$，那么我们可以$O(\sqrt{b})$找到$d$和$f$，然后使用拓展欧几里得找到$fc-de=a$的一组可行解即可</p>
<p>注意如果找不到互质的因子的情况，这说明该方程无解</p>
<h3 id="AC代码-3"><a href="#AC代码-3" class="headerlink" title="AC代码"></a>AC代码</h3><div><div class="fold_hider"><div class="close hider_title"></div></div><div class="fold">
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !b ? a : gcd(b, a % b);</span><br><span class="line">&#125;</span><br><span class="line">pair&lt;int, int&gt; exgcd(int a, int b) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!b) <span class="keyword">return</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; temp = exgcd(b, a % b);</span><br><span class="line">    <span class="keyword">return</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(temp.second, temp.first - a / b * temp.second);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>), <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="keyword">int</span> a, b;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        <span class="keyword">int</span> g = gcd(a, b);</span><br><span class="line">        <span class="keyword">if</span> (g != <span class="number">1</span>) <span class="built_in">cout</span> &lt;&lt; (a + b) / g &lt;&lt; <span class="string">" "</span> &lt;&lt; b / g &lt;&lt; <span class="string">" "</span> &lt;&lt; <span class="number">1</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; <span class="number">1</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> k = <span class="built_in">sqrt</span>(b);</span><br><span class="line">            <span class="keyword">int</span> d = <span class="number">0</span>, f = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= k; ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span>(b % i == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(gcd(i, b / i) == <span class="number">1</span>) &#123;</span><br><span class="line">                        d = i, f = b / i;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!d &amp;&amp; !f) &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">"-1 -1 -1 -1\n"</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pp = exgcd(f, d);</span><br><span class="line">            <span class="keyword">int</span> x = pp.first, y = -pp.second;</span><br><span class="line">            ll c = x, e = y;</span><br><span class="line">            <span class="keyword">while</span> (c &lt;= <span class="number">0</span>) c += d;</span><br><span class="line">            <span class="keyword">while</span> (e &lt;= <span class="number">0</span>) e += f;</span><br><span class="line">            c *= a, e *= a;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; c &lt;&lt; <span class="string">" "</span> &lt;&lt; d &lt;&lt; <span class="string">" "</span> &lt;&lt; e &lt;&lt; <span class="string">" "</span> &lt;&lt; f &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></div>
<h2 id="G-Operating-on-a-Graph"><a href="#G-Operating-on-a-Graph" class="headerlink" title="G.Operating on a Graph"></a>G.Operating on a Graph</h2><h3 id="题目大意-4"><a href="#题目大意-4" class="headerlink" title="题目大意"></a>题目大意</h3><p>给你一个图，每个点最初都属于第i组，有q次操作，每次给你一个组号，你需要将与改组相连的组合并到改组，定义两个组相连为至少有一条边将两个组中的某两个点连接起来，问你最终每个点属于的组号是多少</p>
<h3 id="解题思路-4"><a href="#解题思路-4" class="headerlink" title="解题思路"></a>解题思路</h3><p>首先可以想到的是使用并查集来查询和合并组别，然后我们可以使用链表来记录每个组中有哪些顶点，如果要合并两个组可以$O(1)$合并，但是如果只是这样的话会超时，因为如果该图是个完全图，那么我一次就可以将所有点都合并到一起，那么如果你每次都查询一边这个点，时间复杂度是$O(n^{2})$，显然会超时，考虑你每次将一个点的相临点添加到该组后，该点对于后面的查询就没有贡献了，所以可以将该点从链表中剔除，这样复杂度会降至$O(n)$</p>
<h3 id="AC代码-4"><a href="#AC代码-4" class="headerlink" title="AC代码"></a>AC代码</h3><div><div class="fold_hider"><div class="close hider_title"></div></div><div class="fold">
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">8e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v[maxn];</span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; col[maxn];</span><br><span class="line"><span class="keyword">int</span> pre[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> pre[x] == x ? x : pre[x] = find(pre[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>), <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="keyword">int</span> n, m;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            pre[i] = i;</span><br><span class="line">            v[i].clear();</span><br><span class="line">            col[i].clear();</span><br><span class="line">            col[i].push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> x, y;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y;</span><br><span class="line">            v[x].push_back(y);</span><br><span class="line">            v[y].push_back(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> q;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; q;</span><br><span class="line">        <span class="keyword">while</span> (q--) &#123;</span><br><span class="line">            <span class="keyword">int</span> x;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">            <span class="keyword">if</span> (col[x].empty()) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> len = col[x].size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">                <span class="keyword">int</span> u = col[x].front();</span><br><span class="line">                <span class="keyword">int</span> len_v = v[u].size();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len_v; ++j) &#123;</span><br><span class="line">                    <span class="keyword">int</span> fx = find(u), fy = find(v[u][j]);</span><br><span class="line">                    <span class="keyword">if</span> (fx != fy) &#123;</span><br><span class="line">                        pre[fy] = fx;</span><br><span class="line">                        col[fx].splice(col[fx].end(), col[fy]);</span><br><span class="line">                        col[fy].clear();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                col[x].pop_front();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; ++i) <span class="built_in">cout</span> &lt;&lt; find(i) &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; find(n - <span class="number">1</span>) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></div>
<h2 id="L-Problem-L-is-the-Only-Lovely-Problem"><a href="#L-Problem-L-is-the-Only-Lovely-Problem" class="headerlink" title="L.Problem L is the Only Lovely Problem"></a>L.Problem L is the Only Lovely Problem</h2><h3 id="题目大意-5"><a href="#题目大意-5" class="headerlink" title="题目大意"></a>题目大意</h3><p>判断字符串$s$的前几个字符是不是”lovely”（不区分大小写）</p>
<h3 id="解题思路-5"><a href="#解题思路-5" class="headerlink" title="解题思路"></a>解题思路</h3><p>$O(1)$判断即可</p>
<h3 id="AC代码-5"><a href="#AC代码-5" class="headerlink" title="AC代码"></a>AC代码</h3><div><div class="fold_hider"><div class="close hider_title"></div></div><div class="fold">
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>), <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">    <span class="keyword">if</span>(s.length() &lt; <span class="number">6</span>) <span class="built_in">cout</span> &lt;&lt; <span class="string">"ugly\n"</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">string</span> p = <span class="string">"lovely"</span>;</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; p.length(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">tolower</span>(s[i]) == p[i]) <span class="keyword">continue</span>;</span><br><span class="line">            flag = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!flag) <span class="built_in">cout</span> &lt;&lt; <span class="string">"lovely\n"</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">"ugly\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></div>
]]></content>
      <categories>
        <category>NewCoder</category>
      </categories>
      <tags>
        <tag>NewCoder</tag>
      </tags>
  </entry>
  <entry>
    <title>ACM最短路</title>
    <url>/ZLY201.github.io/2020/08/23/ACM%E6%9C%80%E7%9F%AD%E8%B7%AF/</url>
    <content><![CDATA[<h2 id="最短路算法介绍及简略证明"><a href="#最短路算法介绍及简略证明" class="headerlink" title="最短路算法介绍及简略证明"></a>最短路算法介绍及简略证明</h2><h3 id="公共前提"><a href="#公共前提" class="headerlink" title="公共前提"></a>公共前提</h3><p>对于连通图$G=(V,E)$，$|V|=n$，$|E|=m$，$w_{i,j}$表示节点$i$和$j$间的权值，我们需要求得对于任意给定的节点$s$和$t$，$w_{s,t}$的最小值</p>
<h3 id="Floyd-算法"><a href="#Floyd-算法" class="headerlink" title="$Floyd$算法"></a>$Floyd$算法</h3><h4 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h4><p>对于任意两个节点$i$，$j$，若能找到一个节点$k$使得$w_{i,k}+w_{k,j}&lt;w_{i,j}$，那么我们更新$w_{i,j}$的值为$w_{i,k}+w_{k,j}$，对于$\forall i,j,k \in [1,n]$，我们比较$w_{i,k}+w_{k,j}$和$w_{i,j}$的关系，最后$w_{s,t}$即为所求值</p>
<h4 id="算法证明"><a href="#算法证明" class="headerlink" title="算法证明"></a>算法证明</h4><p>首先考虑初始情况，对于节点$i$和$j$，要么联通（仅有$i$至$j$的一条边），要么不连通（权值为$\infty$），在第一次迭代更新时，若$\exists k$使得$w_{i,k}+w_{k,j}&lt;w_{i,j}$，那么我们会将节点$k$加入到联通$i,j$的最短链中，在下一次迭代，我们又会更新$i,k$和$k,j$的中间节点，如此往复，最终我们会得到联通$i,j$的一条最短链，并且该链中任意两点间的距离均为最短，则此时$w_{s,t}$为所求</p>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><div><div class="fold_hider"><div class="close hider_title"></div></div><div class="fold">
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; ++k) &#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">      W[i][j] = min(w[i][j], w[i][k] + w[k][j]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></div>
<p>可以看出时间复杂度为$O(n^3)$</p>
<h4 id="算法缺点"><a href="#算法缺点" class="headerlink" title="算法缺点"></a>算法缺点</h4><p>无法处理带有负权环的图，因为负权环中不存在最短路</p>
<h3 id="Dijkstra-算法"><a href="#Dijkstra-算法" class="headerlink" title="$Dijkstra$算法"></a>$Dijkstra$算法</h3><h4 id="核心思路-1"><a href="#核心思路-1" class="headerlink" title="核心思路"></a>核心思路</h4><p>我们维护一个节点集合$S$，集合中的点两两已确定最短路，我们每次找到与$S$中所有相邻点中距离起点$s$最近的节点$v$，设其父亲节点为$u$，并将其加入到集合$S$，并使得$w_{s,v}=w_{s,u}+w_{u,v}$，并更新$w_{s,i}=min(w_{s,i},w_{s,k}+w_{k,i})$</p>
<h4 id="算法证明-1"><a href="#算法证明-1" class="headerlink" title="算法证明"></a>算法证明</h4><p>该算法的原理基于以下前提：</p>
<blockquote>
<p>对于一个顶点$u$的字段邻接边所连点$v$，必然不存在$k$使得$w_{u,v}&gt;w_{u,k}+w_{k,v}$</p>
</blockquote>
<p>很好理解，因为$w_{u,v} \leq w_{u,i}$，显然有$w_{u,v} \leq w_{u,k}$</p>
<p>那么每次迭代找到的$v$，$w_{s,v}=w_{s,u}+w_{u,v}$显然最小</p>
<h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><div><div class="fold_hider"><div class="close hider_title"></div></div><div class="fold">
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"><span class="keyword">int</span> dis[maxn];</span><br><span class="line"><span class="built_in">memset</span>(vis, <span class="literal">false</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line"><span class="built_in">memset</span>(dis, <span class="number">0x3f3f3f3f</span>, <span class="keyword">sizeof</span>(dis));</span><br><span class="line">dis[s] = <span class="number">0</span>;</span><br><span class="line">vis[s] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">  <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> Min = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!vis[j] &amp;&amp; dis[j] &lt; Min) &#123;</span><br><span class="line">      k = j;</span><br><span class="line">      Min = dis[k];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  vis[k] = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!vis[j] &amp;&amp; dis[j] &gt; dis[k] + W[k][j]]) &#123;</span><br><span class="line">      dis[j] = dis[k] + w[k][j];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></div>
<p>可以看出朴素$Dijkstra$复杂度为$O(n^2)$，可以用堆将其优化到$O((n + m)log_{2}^{n})$，此处省略</p>
<h4 id="算法缺点-1"><a href="#算法缺点-1" class="headerlink" title="算法缺点"></a>算法缺点</h4><p>不能处理负权图，因为负权边不满足前提条件</p>
<h3 id="Bellman-Ford-算法"><a href="#Bellman-Ford-算法" class="headerlink" title="$Bellman-Ford$算法"></a>$Bellman-Ford$算法</h3><h4 id="核心思路-2"><a href="#核心思路-2" class="headerlink" title="核心思路"></a>核心思路</h4><p>我们定义松弛操作为：</p>
<blockquote>
<p>对于任意边$E(u,v)$，如果$w_{s,v}&gt;w_{s,u}+w_{u,v}$，我们使得$w_{s,v}=w_{s,u}+w_{u,v}$</p>
</blockquote>
<p>若所有顶点处理完毕后仍存在$w_{s,v}&gt;w_{s,u}+w_{u,v}$，则说明存在负环</p>
<h4 id="算法证明-2"><a href="#算法证明-2" class="headerlink" title="算法证明"></a>算法证明</h4><p>该算法为$Floyd$的简化版，证明略</p>
<h4 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h4><div><div class="fold_hider"><div class="close hider_title"></div></div><div class="fold">
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//表示u[i], v[i]间的权值为w[i]</span></span><br><span class="line"><span class="keyword">int</span> u[maxn], v[maxn], w[maxn];</span><br><span class="line"><span class="keyword">int</span> dis[maxn];</span><br><span class="line"><span class="built_in">memset</span>(dis, <span class="number">0x3f3f3f3f</span>, <span class="keyword">sizeof</span>(dis));</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; ++k) &#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">    dis[v[i]] = min(dis[u[i]] + w[i]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">bool</span> loop = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">  <span class="keyword">if</span>(dis[v[i]] &gt; dis[u[i]] + w[i]) &#123;</span><br><span class="line">    loop = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></div>
<p>可以看出其时间复杂度为$O(nm)$</p>
<h4 id="算法缺点-2"><a href="#算法缺点-2" class="headerlink" title="算法缺点"></a>算法缺点</h4><p>可以处理负权图和负权环，但是时间复杂度太高</p>
<h3 id="SPFA-算法"><a href="#SPFA-算法" class="headerlink" title="$SPFA$算法"></a>$SPFA$算法</h3><h4 id="核心思路-3"><a href="#核心思路-3" class="headerlink" title="核心思路"></a>核心思路</h4><p>由于$Bellman-Ford$复杂度过高，于是引入了队列优化的$Bellman-Ford$——$SPFA$</p>
]]></content>
      <categories>
        <category>图论</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title>Max Sum Plus Plus HDU - 1024</title>
    <url>/ZLY201.github.io/2020/07/11/HDU%20-%201024/</url>
    <content><![CDATA[<h2 id="Max-Sum-Plus-Plus-HDU-1024"><a href="#Max-Sum-Plus-Plus-HDU-1024" class="headerlink" title="Max Sum Plus Plus HDU - 1024"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1024" target="_blank" rel="noopener">Max Sum Plus Plus HDU - 1024</a></h2><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>将$n$个数分成$m$组互不相交的连续子序列（$m$组不一定包含所有数），问你这$m$组的和最大是多少</p>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>假设前$i$个数已经分成了$j$组，那么第$i$个数可以分到$j$组中的任意一组或者变成第$j+1$组的第一个数<br>由此我们定义$dp[i][j]$为前$i$个数分成$j$组的最大值，那么转移方程为：</p>
<script type="math/tex; mode=display">dp[i][j]=max(dp[i-1][j] + a[i], (max_{k=1}^{i-1}dp[k][j-1]) + a[i])</script><p>其中$dp[i-1][j] + a[i]$表示将第$i$个数分到前$j$组中的任意一组，$(max_{k=1}^{i-1}dp[k][j-1]) + a[i]$表示将第$i$个数自成一组并合并到前$k$个数分成$j-1$组中最大的情况中</p>
<p>但是这样做的时间复杂度是$O(mn^{2})$，显然不符合要求</p>
<p>观察上式，我们发现$max_{k=1}^{i-1}dp[k][j-1]$由于与$j-1$之前的情况无关，所以并不用每一次都重新计算，而是在统计组数为$j-1$时将其记录下来即可</p>
<h3 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h3><div><div class="fold_hider"><div class="close hider_title"></div></div><div class="fold">
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line">ll a[maxn];</span><br><span class="line">ll dp[maxn];</span><br><span class="line">ll mmax[maxn];	<span class="comment">//实时记录组数为j-1的情况</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">cin</span>.tie(<span class="number">0</span>), <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">int</span> m, n;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; m &gt;&gt; n) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">			dp[i] = mmax[i] = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j) &#123;</span><br><span class="line">			ll Max = LLONG_MIN;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = j; i &lt;= n; ++i) &#123;</span><br><span class="line">				dp[i] = max(dp[i - <span class="number">1</span>], mmax[i - <span class="number">1</span>]) + a[i];</span><br><span class="line">				<span class="comment">//注意下面两个语句不能颠倒，因为这会影响下一次的循环（i + 1的情况）</span></span><br><span class="line">				mmax[i - <span class="number">1</span>] = Max;</span><br><span class="line">				Max = max(Max, dp[i]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		ll res = LLONG_MIN;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = m; i &lt;= n; ++i) &#123;</span><br><span class="line">			res = max(dp[i], res);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></div>
]]></content>
      <categories>
        <category>HDU</category>
      </categories>
      <tags>
        <tag>HDU</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>FatMouse&#39;s Speed HDU - 1160</title>
    <url>/ZLY201.github.io/2020/07/12/HDU%20-%201160/</url>
    <content><![CDATA[<h2 id="FatMouse’s-Speed-HDU-1160"><a href="#FatMouse’s-Speed-HDU-1160" class="headerlink" title="FatMouse’s Speed HDU - 1160"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1160" target="_blank" rel="noopener">FatMouse’s Speed HDU - 1160</a></h2><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>给你$1-k$每个人的$W$和$S$，让你构造一个$W[m[1]] &lt; W[m[2]] &lt; … &lt; W[m[n]]$和$S[m[1]] &gt; S[m[2]] &gt; … &gt; S[m[n]]$的序列，其中$m$为每个人的标号，输出$n$和序列$m$</p>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>将数组按照$W$优先降序，$S$优先升序（一会说为什么反过来）排序，$dp[i]$表示以$i$为结尾的序列最大长度，那么对于$\forall j &lt; i,\ 如果W[i] &lt; W[j] \ \&amp;\&amp; \ S[i] &gt; S[j]$，那么$dp[i] = max(dp[j]) + 1$，我们可以使用类似于并查集的数组反向记录$dp[j] + 1&gt;dp[i]$的$j$的标号，然后回溯输出序列，由于这样记录下来的序列是反向的，所以前面我们需要将比较条件反过来排序</p>
<p>注：这题比较坑的是输入，cin是从后往前运行的，所以++cnt要放在后面，而且读入EOF会使得cnt多加一次，所以读完后要将其减一</p>
<h3 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h3><div><div class="fold_hider"><div class="close hider_title"></div></div><div class="fold">
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> w, s, id;</span><br><span class="line">&#125;a[<span class="number">1010</span>];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(Node a, Node b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (a.w == b.w) <span class="keyword">return</span> a.s &lt; b.s;</span><br><span class="line">	<span class="keyword">return</span> a.w &gt; b.w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">1010</span>], pre[<span class="number">1010</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a[cnt].w, &amp;a[++cnt].s)) a[cnt].id = cnt;</span><br><span class="line">	--cnt;</span><br><span class="line">	sort(a + <span class="number">1</span>, a + cnt + <span class="number">1</span>, cmp);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= cnt; ++i) &#123;</span><br><span class="line">		dp[i] = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= cnt; ++i) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; ++j) &#123;</span><br><span class="line">			<span class="keyword">if</span> (a[i].w &lt; a[j].w &amp;&amp; a[i].s &gt; a[j].s &amp;&amp; dp[i] &lt; dp[j] + <span class="number">1</span>) &#123;</span><br><span class="line">				dp[i] = dp[j] + <span class="number">1</span>;</span><br><span class="line">				pre[i] = j;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (dp[i] &gt; dp[pos]) pos = i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, dp[pos]);</span><br><span class="line">	<span class="keyword">while</span> (pos) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, a[pos].id);</span><br><span class="line">		pos = pre[pos];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></div>
]]></content>
      <categories>
        <category>HDU</category>
      </categories>
      <tags>
        <tag>HDU</tag>
        <tag>动态规划</tag>
        <tag>最长上升子序列</tag>
      </tags>
  </entry>
  <entry>
    <title>免费馅饼 HDU - 1176</title>
    <url>/ZLY201.github.io/2020/07/11/HDU%20-%201176/</url>
    <content><![CDATA[<h2 id="免费馅饼-HDU-1176"><a href="#免费馅饼-HDU-1176" class="headerlink" title="免费馅饼 HDU - 1176"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1176" target="_blank" rel="noopener">免费馅饼 HDU - 1176</a></h2><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>有一条坐标轴，范围为$[0, 10]$，有$n$个馅饼分别会在$t_{i}$秒落在$x_{i}$的位置，你的初始位置为5，每秒能向左或向右移动一格，问你你能拾取的最大数量的馅饼个数是多少</p>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>由于你每次只能向左或向右移动一格，那么在$t$秒你有三种可选择的状态：</p>
<ol>
<li>保持不动</li>
<li>向左移动一格</li>
<li>向右移动一格</li>
</ol>
<p>所以我们可以定义$dp[i][j]$为第$i$秒在$j$位置处所拾取的最大馅饼数目，那么转移方程即为：</p>
<script type="math/tex; mode=display">dp[i][j]=dp[i][j]+max(max(dp[i+1][j-1],dp[i+1][j+1]),dp[i+1][j])</script><p>初始条件为$dp[i][j]=\sum_{k=1}^{n}(t_{k} == i\  \&amp;\&amp; \ x_{k} == j)$</p>
<p>还需注意的是我们枚举时间需要从后往前枚举，因为如果从$t=0$开始枚举的话最终的状态是不确定的，就是说你的位置是不确定的，而由于初始状态为$x=5$，所以从后往前枚举是可行的</p>
<h3 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h3><div><div class="fold_hider"><div class="close hider_title"></div></div><div class="fold">
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> dp[maxn][<span class="number">15</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">cin</span>.tie(<span class="number">0</span>), <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!n) <span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">int</span> Time = <span class="number">0</span>;</span><br><span class="line">		<span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">			<span class="keyword">int</span> x, t;</span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; x &gt;&gt; t;</span><br><span class="line">			++dp[t][x];</span><br><span class="line">			Time = max(Time, t);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = Time - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">10</span>; ++j) &#123;</span><br><span class="line">				dp[i][j] += max(max(dp[i + <span class="number">1</span>][j - <span class="number">1</span>], dp[i + <span class="number">1</span>][j + <span class="number">1</span>]), dp[i + <span class="number">1</span>][j]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; dp[<span class="number">0</span>][<span class="number">5</span>] &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></div>
]]></content>
      <categories>
        <category>HDU</category>
      </categories>
      <tags>
        <tag>HDU</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>Phalanx HDU - 2859</title>
    <url>/ZLY201.github.io/2020/07/12/HDU%20-%202859/</url>
    <content><![CDATA[<h2 id="Phalanx-HDU-2859"><a href="#Phalanx-HDU-2859" class="headerlink" title="Phalanx HDU - 2859"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=2859" target="_blank" rel="noopener">Phalanx HDU - 2859</a></h2><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>给你一个$n \times n$的字符矩阵，问你其最大的对称子矩阵的大小</p>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>考虑现在已经有了一个以$(i, j)$为左下角，$m \times m$大小的子矩阵，我们要想将其扩大，那么必须以$(i + 1, j - 1)$为左下角并且$\forall k \leq m+1,\ s[i+1-k]=s[j-1+k]$</p>
<p>那么我们定义$dp[i][j]$表示以$(i, j)$为左下角的对称矩阵的大小，如果$\forall k \leq dp[i-1][j+1]+1，s[i+1-k]=s[j-1+k]$，那么$dp[i][j]=dp[i-1][j+1]+1$，否则$dp[i][j]=max(k), \forall l \leq k,\ s[i+1-l]=s[j-1+l]$</p>
<h3 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h3><div><div class="fold_hider"><div class="close hider_title"></div></div><div class="fold">
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e3</span> + <span class="number">10</span>;</span><br><span class="line"><span class="built_in">string</span> s[maxn];</span><br><span class="line"><span class="keyword">int</span> dp[maxn][maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">cin</span>.tie(<span class="number">0</span>), <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!n) <span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; s[i];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">		<span class="keyword">int</span> Max = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">				dp[i][j] = <span class="number">1</span>;</span><br><span class="line">				<span class="keyword">int</span> x = i, y = j;</span><br><span class="line">				<span class="keyword">while</span> (x &gt;= <span class="number">1</span> &amp;&amp; y &lt; n &amp;&amp; s[i][y] == s[x][j]) &#123;</span><br><span class="line">					--x, ++y;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">int</span> tmp = i - x;</span><br><span class="line">				<span class="keyword">if</span> (tmp &gt; dp[i - <span class="number">1</span>][j + <span class="number">1</span>]) dp[i][j] = dp[i - <span class="number">1</span>][j + <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">				<span class="keyword">else</span> dp[i][j] = tmp;</span><br><span class="line">				Max = max(Max, dp[i][j]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; Max &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></div>
]]></content>
      <categories>
        <category>HDU</category>
      </categories>
      <tags>
        <tag>HDU</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>Tickets HDU - 1260</title>
    <url>/ZLY201.github.io/2020/07/11/HDU%20-%201260/</url>
    <content><![CDATA[<h2 id="Tickets-HDU-1260"><a href="#Tickets-HDU-1260" class="headerlink" title="Tickets HDU - 1260"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1260" target="_blank" rel="noopener">Tickets HDU - 1260</a></h2><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>有$k$个人去电影院买票，第$i$个人的买票时间为$a[i]$，第$i$和第$i+1$个人一起买票的时间为$b[i]$，问你最少花多长时间可以把票卖完</p>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>考虑第i个人的状态有：</p>
<ol>
<li>单独卖票</li>
<li>和前一个人一起卖票</li>
</ol>
<p>那么我用$dp[i]$表示前i个人卖票所花的最短时间，其状态转移方程为:</p>
<script type="math/tex; mode=display">dp[i]=min(dp[i-1]+a[i],dp[i-2]+b[i-1])</script><p>初始条件为$dp[1]=a[1]$</p>
<h3 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h3><div><div class="fold_hider"><div class="close hider_title"></div></div><div class="fold">
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">2010</span>], b[<span class="number">2010</span>];</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">2010</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> T;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">	<span class="keyword">while</span> (T--) &#123;</span><br><span class="line">		<span class="keyword">int</span> k;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;k);</span><br><span class="line">		<span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; ++i) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; k; ++i) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;b[i]);</span><br><span class="line">		dp[<span class="number">1</span>] = a[<span class="number">1</span>];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= k; ++i) &#123;</span><br><span class="line">			dp[i] = min(dp[i - <span class="number">1</span>] + a[i], dp[i - <span class="number">2</span>] + b[i - <span class="number">1</span>]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> ss = dp[k] % <span class="number">60</span>;</span><br><span class="line">		<span class="keyword">int</span> mm = dp[k] / <span class="number">60</span> % <span class="number">60</span>;</span><br><span class="line">		<span class="keyword">int</span> hh = <span class="number">8</span> + dp[k] / <span class="number">60</span> / <span class="number">60</span>;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%02d:%02d:%02d %s\n"</span>, hh, mm, ss, (hh &gt; <span class="number">12</span> ? <span class="string">"pm"</span> : <span class="string">"am"</span>));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></div>
]]></content>
      <categories>
        <category>HDU</category>
      </categories>
      <tags>
        <tag>HDU</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>Race to 1 Again LightOJ - 1038</title>
    <url>/ZLY201.github.io/2020/07/26/LightOJ%20-%201038/</url>
    <content><![CDATA[<h2 id="Race-to-1-Again-LightOJ-1038"><a href="#Race-to-1-Again-LightOJ-1038" class="headerlink" title="Race to 1 Again LightOJ - 1038"></a><a href="http://lightoj.com/volume_showproblem.php?problem=1038" target="_blank" rel="noopener">Race to 1 Again LightOJ - 1038</a></h2><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>给你一个正整数$D$，每次我们选择一个$D$的因子$k$使得$D/=k$，问你将$D$变成$1$的操作次数的期望是多少</p>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>考虑将$D$除以$k$后得到$D’=D/k$，那么$E(D)=\frac{1}{\sum_{k|D}}\times(E(D’)+1)$<br>那么将范围内的数筛一遍因子，按照公式转移即可，初始条件为$E[1]=0$，时间复杂度$O(n\sqrt{n}+T)$</p>
<h3 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h3><div><div class="fold_hider"><div class="close hider_title"></div></div><div class="fold">
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> eps 1e-6</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">double</span> dp[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pre</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; maxn; ++i) &#123;</span><br><span class="line">		<span class="keyword">int</span> k = <span class="built_in">sqrt</span>(i);</span><br><span class="line">		<span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">double</span> res = <span class="number">0.0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= k; ++j) &#123;</span><br><span class="line">			<span class="keyword">if</span> (i % j == <span class="number">0</span>) &#123;</span><br><span class="line">				++cnt;</span><br><span class="line">				res += dp[j] + <span class="number">1</span>;</span><br><span class="line">				<span class="keyword">if</span> (j * j != i) &#123;</span><br><span class="line">					++cnt;</span><br><span class="line">					res += dp[i / j] + <span class="number">1</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		dp[i] = res / ((cnt - <span class="number">1</span>) * <span class="number">1.0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> T;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">	<span class="keyword">int</span> cas = <span class="number">0</span>;</span><br><span class="line">	pre();</span><br><span class="line">	<span class="keyword">while</span> (T--) &#123;</span><br><span class="line">		<span class="keyword">int</span> n;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Case %d: %.10f\n"</span>, ++cas, dp[n]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></div>
]]></content>
      <categories>
        <category>LightOJ</category>
      </categories>
      <tags>
        <tag>LightOJ</tag>
        <tag>唯一分解定理</tag>
        <tag>概率&amp;期望</tag>
        <tag>概率dp</tag>
      </tags>
  </entry>
  <entry>
    <title>Digits of Factorial LightOJ - 1045</title>
    <url>/ZLY201.github.io/2020/07/05/LightOJ%20-%201045/</url>
    <content><![CDATA[<h2 id="Digits-of-Factorial-LightOJ-1045"><a href="#Digits-of-Factorial-LightOJ-1045" class="headerlink" title="Digits of Factorial LightOJ - 1045"></a><a href="http://lightoj.com/volume_showproblem.php?problem=1045" target="_blank" rel="noopener">Digits of Factorial LightOJ - 1045</a></h2><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>多组输入，每次给你一个n和m，输出n的阶乘在m进制下的位数</p>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>考虑n!在m下的位数是k，则有：</p>
<p>$m^{k-1}\leq n!&lt;m^{k}$</p>
<p>$k-1\leq log_{m}^{n!}&lt;k$</p>
<p>$k-1\leq log_{m}^{1} + log_{m}^{2} + … + log_{m}^{n}&lt;k$</p>
<p>那么预处理处范围内的lg和，最后利用$log_{m}^{n}=\frac {lg^{n}}{lg^{m}}$进行求解即可</p>
<h3 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h3><div><div class="fold_hider"><div class="close hider_title"></div></div><div class="fold">
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">double</span> sum[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> T;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">	<span class="keyword">int</span> cas = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; maxn; ++i) &#123;</span><br><span class="line">		sum[i] = sum[i - <span class="number">1</span>] + <span class="built_in">log</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (T--) &#123;</span><br><span class="line">		<span class="keyword">int</span> n, m;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">		<span class="keyword">double</span> res = sum[n] / <span class="built_in">log</span>(m);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Case %d: %d\n"</span>, ++cas, <span class="keyword">int</span>(res) + <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></div>
]]></content>
      <categories>
        <category>LightOJ</category>
      </categories>
      <tags>
        <tag>LightOJ</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>Discovering Gold LightOJ - 1030</title>
    <url>/ZLY201.github.io/2020/07/25/LightOJ%20-%201030/</url>
    <content><![CDATA[<h2 id="Discovering-Gold-LightOJ-1030"><a href="#Discovering-Gold-LightOJ-1030" class="headerlink" title="Discovering Gold LightOJ - 1030"></a><a href="http://lightoj.com/volume_showproblem.php?problem=1030" target="_blank" rel="noopener">Discovering Gold LightOJ - 1030</a></h2><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>有一个$1\times n$的地图，你的初始位置为$(1, 1)$，你每次通过掷骰子来确定你的向前移动步数，每个格子上有$a_{i}$糖果，你可以获取你所在格子上的所有糖果（经过的无法获取），问你最终你获取的糖果数目的期望值是多少</p>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>由于你每次可以向前移动的数目为$1\sim6$，那么$dp[i]$表示第$i$个格子上获得的糖果的期望数目，那么转移方程为$dp[i]=\frac{1}{min(n-i,6)}\sum_{j=1}^{min(n-i,6)}dp[i+j]$<br>初始状态为$\forall i\in [1,n],dp[i]=a[i]$</p>
<h3 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h3><div><div class="fold_hider"><div class="close hider_title"></div></div><div class="fold">
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> eps 1e-6</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">110</span>;</span><br><span class="line"><span class="keyword">double</span> dp[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> T;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">	<span class="keyword">int</span> cas = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (T--) &#123;</span><br><span class="line">		<span class="keyword">int</span> n;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">		<span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">			<span class="keyword">int</span> x;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x);</span><br><span class="line">			dp[i] = x * <span class="number">1.0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">1</span>; --i) &#123;</span><br><span class="line">			<span class="keyword">int</span> k = min(n - i, <span class="number">6</span>);</span><br><span class="line">			<span class="keyword">double</span> tmp = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= k; ++j) &#123;</span><br><span class="line">				tmp += dp[i + j];</span><br><span class="line">			&#125;</span><br><span class="line">			dp[i] += tmp / (k * <span class="number">1.0</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Case %d: %.10lf\n"</span>, ++cas, dp[<span class="number">1</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></div>
]]></content>
      <categories>
        <category>LightOJ</category>
      </categories>
      <tags>
        <tag>LightOJ</tag>
        <tag>概率&amp;期望</tag>
        <tag>概率dp</tag>
      </tags>
  </entry>
  <entry>
    <title>Just another Robbery LightOJ - 1079</title>
    <url>/ZLY201.github.io/2020/07/26/LightOJ%20-%201079/</url>
    <content><![CDATA[<h2 id="Just-another-Robbery-LightOJ-1079"><a href="#Just-another-Robbery-LightOJ-1079" class="headerlink" title="Just another Robbery LightOJ - 1079"></a><a href="http://lightoj.com/volume_showproblem.php?problem=1079" target="_blank" rel="noopener">Just another Robbery LightOJ - 1079</a></h2><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>有$n$家银行，每家银行被抢后抓的概率是$p_{i}$，可获得的金钱是$a_{i}$，问你在被抓几率最高为$P$的情况下可获得的最大金钱数目是多少</p>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>将危险率转化为安全率，那么即求在安全程度最低为$1-P$的情况下可获得的最大金钱数目，将金钱看成体积，安全程度看成重量，那么问题被转换成为了概率下的01背包问题，$dp[i]$表示在获取金钱数目为$i$时的安全程度，其状态转移方程即为：</p>
<script type="math/tex; mode=display">dp[i] = max(dp[i],dp[i-a[i]]\times p[i])</script><h3 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h3><div><div class="fold_hider"><div class="close hider_title"></div></div><div class="fold">
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> eps 1e-6</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">double</span> dp[maxn];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> money;</span><br><span class="line">	<span class="keyword">double</span> safe;</span><br><span class="line">	Node() &#123;</span><br><span class="line">		money = <span class="number">0</span>;</span><br><span class="line">		safe = <span class="number">0.0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;a[<span class="number">110</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> T;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">	<span class="keyword">int</span> cas = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (T--) &#123;</span><br><span class="line">		<span class="keyword">double</span> Safe;</span><br><span class="line">		<span class="keyword">int</span> n;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%lf%d"</span>, &amp;Safe, &amp;n);</span><br><span class="line">		Safe = <span class="number">1.0</span> - Safe;</span><br><span class="line">		<span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d%lf"</span>, &amp;a[i].money, &amp;a[i].safe);</span><br><span class="line">			a[i].safe = <span class="number">1.0</span> - a[i].safe;</span><br><span class="line">			sum += a[i].money;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">		dp[<span class="number">0</span>] = <span class="number">1.0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = sum; j &gt;= a[i].money; --j) &#123;</span><br><span class="line">				dp[j] = max(dp[j], dp[j - a[i].money] * a[i].safe);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = sum; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">			<span class="keyword">if</span> (dp[i] &gt;= Safe) &#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"Case %d: %d\n"</span>, ++cas, i);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></div>
]]></content>
      <categories>
        <category>LightOJ</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>LightOJ</tag>
        <tag>概率&amp;期望</tag>
        <tag>概率dp</tag>
        <tag>01背包</tag>
      </tags>
  </entry>
  <entry>
    <title>Dangerous Maze LightOJ - 1027</title>
    <url>/ZLY201.github.io/2020/07/25/LightOJ%20-%201027/</url>
    <content><![CDATA[<h2 id="A-Dangerous-Maze-LightOJ-1027"><a href="#A-Dangerous-Maze-LightOJ-1027" class="headerlink" title="A Dangerous Maze LightOJ - 1027"></a><a href="http://lightoj.com/volume_showproblem.php?problem=1027" target="_blank" rel="noopener">A Dangerous Maze LightOJ - 1027</a></h2><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>迷宫中有$n$扇门，到达每扇门的时间为$|x|$，如果$x$大于$0$说明该扇门通往出口，否则该扇门会将你传送至原点，问你走出迷宫所花时间的期望是多少</p>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>首先，对于任何一扇门，其被选择的概率均为$\frac{1}{n}$，那么我们假设通往出口的门的数量为$x$，其所需时间分别为$a_{1},a_{2},…,a_{x}$,通向原点的门的数量为$y$，其所需时间分别为$b_{1},b_{2},…,b_{y}$<br>显然对于通向出口的门$i$，其对于期望的贡献为$E_{a_{i}}=\frac{1}{n}\times a_{i}$，而对于通向原点的门$i$，由于最终一定能够出去，设出去的时间期望为$E$，那么$E_{b_{i}}=\frac{1}{n}\times (b_{i} + E)$，则有：</p>
<script type="math/tex; mode=display">E=\sum_{i=1}^{x}E_{a_{i}}+\sum_{i=1}^{y}E_{b_{i}}=\sum_{i=1}^{x}\frac{1}{n}\times a_{i}+\sum_{i=1}^{y}\frac{1}{n}\times (b_{i} + E)</script><p>其中$n=x+y$<br>化简后我们可以得到$E=\frac{1}{x}\times(\sum_{i=1}^{x}a_{i}+\sum_{i=1}^{y}b_{i})$</p>
<h3 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h3><div><div class="fold_hider"><div class="close hider_title"></div></div><div class="fold">
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> !b ? a : gcd(b, a % b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> T;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">	<span class="keyword">int</span> cas = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (T--) &#123;</span><br><span class="line">		<span class="keyword">int</span> n;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">		<span class="keyword">int</span> cnt = <span class="number">0</span>, sum = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">			<span class="keyword">int</span> x;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x);</span><br><span class="line">			<span class="keyword">if</span> (x &gt; <span class="number">0</span>) ++cnt;</span><br><span class="line">			sum += <span class="built_in">abs</span>(x);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Case %d: "</span>, ++cas);</span><br><span class="line">		<span class="keyword">if</span> (!cnt) <span class="built_in">printf</span>(<span class="string">"inf\n"</span>);</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">int</span> g = gcd(sum, cnt);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%d/%d\n"</span>, sum / g, cnt / g);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></div>
]]></content>
      <categories>
        <category>LightOJ</category>
      </categories>
      <tags>
        <tag>LightOJ</tag>
        <tag>概率&amp;期望</tag>
      </tags>
  </entry>
  <entry>
    <title>How Many Points? LightOJ - 1077</title>
    <url>/ZLY201.github.io/2020/07/05/LightOJ%20-%201077/</url>
    <content><![CDATA[<h2 id="How-Many-Points-LightOJ-1077"><a href="#How-Many-Points-LightOJ-1077" class="headerlink" title="How Many Points? LightOJ - 1077"></a><a href="http://lightoj.com/volume_showproblem.php?problem=1077" target="_blank" rel="noopener">How Many Points? LightOJ - 1077</a></h2><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>多组输入，每次给你两个坐标，问你这两点连成的线段上坐标均为整数的个数是多少</p>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>考虑x，y为满足条件的一组坐标，那么有</p>
<p>$\frac{y_{2}-y_{1}}{x_{2}-x_{1}}=\frac{y-y_{1}}{x-x_{1}}$</p>
<p>将$(x_{1}, y_{1})$当做坐标原点，则有</p>
<p>$\frac{y_{2}}{x_{2}}=\frac{y}{x}$</p>
<p>$\frac{ngcd(y_{2},x_{2})}{mgcd(y_{2},x_{2})}=\frac{n}{m}=\frac{2n}{2m}=…=\frac{ngcd(y_{2},x_{2})}{mgcd(y_{2},x_{2})}$</p>
<p>那么其总个数即为$gcd(abs(x_{2}-x_{1}), abs(y_{2}-y_{1})) + 1$</p>
<h3 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h3><div><div class="fold_hider"><div class="close hider_title"></div></div><div class="fold">
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll x, ll y)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> y == <span class="number">0</span> ? x : gcd(y, x % y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> T;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">	<span class="keyword">int</span> cas = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (T--) &#123;</span><br><span class="line">		ll x1, y1, x2, y2;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%lld%lld%lld%lld"</span>, &amp;x1, &amp;y1, &amp;x2, &amp;y2);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Case %d: %lld\n"</span>, ++cas, gcd(<span class="built_in">abs</span>(x1 - x2), <span class="built_in">abs</span>(y1 - y2)) + <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></div>]]></content>
      <categories>
        <category>LightOJ</category>
      </categories>
      <tags>
        <tag>LightOJ</tag>
        <tag>数学</tag>
        <tag>数论</tag>
        <tag>欧几里得定理</tag>
      </tags>
  </entry>
  <entry>
    <title>A New Function LightOJ - 1098</title>
    <url>/ZLY201.github.io/2020/07/06/LightOJ%20-%201098/</url>
    <content><![CDATA[<h2 id="A-New-Function-LightOJ-1098"><a href="#A-New-Function-LightOJ-1098" class="headerlink" title="A New Function LightOJ - 1098"></a><a href="http://lightoj.com/volume_showproblem.php?problem=1098" target="_blank" rel="noopener">A New Function LightOJ - 1098</a></h2><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>定义$SOD(n)$为$n$除$1$和$n$外的所有正因子之和，例如：<br>$SOD(24)=2+3+4+6+8+12=35$<br>定义$CSOD(n)=\sum_{i=1}^{n}SOD(i)$<br>让你求$2e9$内任意n的$CSOD(n)$</p>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>对于每一个数，我们可以把它写成$a \times b$的形式，那么对于答案的贡献显然就是$a+b(a!=b!=1!=n)$，而对于一个因子$i$，它在$n$内出现的次数应当是$\frac{n}{i}-1$，举个例子：<br>假设$n = 12$<br>$i = 2$时<br>$4 = 2 \times 2$<br>$6 = 2 \times 3$<br>$8 = 2 \times 4$<br>$10 = 2 \times 5$<br>$12 = 2 \times 6$<br>$2$需要被统计$\frac{12}{2}-1= 5$次</p>
<p>但是这样的复杂度是$O(n)$，显然不可行，观察上例，发现右边的因子是连续的，并且根据左边因子的出现次数我们可以得到一个等差数列，这样一来，我们就可以在$O(\sqrt{n})$时间内求出答案</p>
<p>这样做有一个问题，如果对于每一个左因子我统计$\frac{n}{i}-1$次，然后统计右边因子，会出现重复</p>
<p>承接上例<br>$i = 3$时<br>$6 = 3 \times 2$<br>$9 = 3 \times 3$<br>$12 = 3 \times 4$<br>对于$6$来说$6 = 3 \times 2$已经在统计$2$的时候统计过了，所以我们统计时右边因子的左区间为$i + 1$，右区间为$\frac{n}{i}$，然后单独计算平方数的贡献即可</p>
<h3 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h3><div><div class="fold_hider"><div class="close hider_title"></div></div><div class="fold">
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> T;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">	<span class="keyword">int</span> cas = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (T--) &#123;</span><br><span class="line">		<span class="keyword">int</span> n;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">		ll res = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> k = <span class="built_in">sqrt</span>(n);</span><br><span class="line">		<span class="comment">//枚举左边因子</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= k; ++i) &#123;</span><br><span class="line">			res += i;	<span class="comment">//单独统计平方数的因子</span></span><br><span class="line">			<span class="comment">//右边因子的等差数列区间</span></span><br><span class="line">			ll l = i + <span class="number">1</span>, r = n / i;</span><br><span class="line">			<span class="keyword">if</span> (r &lt; l) <span class="keyword">continue</span>;</span><br><span class="line">			res += (r - l + <span class="number">1</span>) * i + (r - l + <span class="number">1</span>) * (l + r) / <span class="number">2</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Case %d: %lld\n"</span>, ++cas, res);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></div>
]]></content>
      <categories>
        <category>LightOJ</category>
      </categories>
      <tags>
        <tag>LightOJ</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>Bank Robbery LightOJ - 1163</title>
    <url>/ZLY201.github.io/2020/07/06/LightOJ%20-%201163/</url>
    <content><![CDATA[<h2 id="Bank-Robbery-LightOJ-1163"><a href="#Bank-Robbery-LightOJ-1163" class="headerlink" title="Bank Robbery LightOJ - 1163"></a><a href="http://lightoj.com/volume_showproblem.php?problem=1163" target="_blank" rel="noopener">Bank Robbery LightOJ - 1163</a></h2><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>给你k，输出所有使得$A - [\frac{A}{10}] = K$成立的A</p>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>$A - [\frac{A}{10}] = K$<br>$A - \frac{A - A % 10}{10} = k$<br>$9A = 10k - A % 10$<br>$9A = 10k - m$</p>
<p>由于$0\leq m \leq 9$，直接枚举即可</p>
<p>要注意这题longlong会溢出</p>
<h3 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h3><div><div class="fold_hider"><div class="close hider_title"></div></div><div class="fold">
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">3e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> T;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">	<span class="keyword">int</span> cas = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (T--) &#123;</span><br><span class="line">		ll n;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;n);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Case %d:"</span>, ++cas);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">9</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">			<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> tmp = <span class="number">10</span> * n - i;</span><br><span class="line">			<span class="keyword">if</span> (tmp % <span class="number">9</span> == <span class="number">0</span> &amp;&amp; tmp / <span class="number">9</span> % <span class="number">10</span> == i) <span class="built_in">printf</span>(<span class="string">" %lld"</span>, tmp / <span class="number">9</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></div>]]></content>
      <categories>
        <category>LightOJ</category>
      </categories>
      <tags>
        <tag>LightOJ</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>Finding LCM LightOJ - 1215</title>
    <url>/ZLY201.github.io/2020/07/06/LightOJ%20-%201215/</url>
    <content><![CDATA[<h2 id="Finding-LCM-LightOJ-1215"><a href="#Finding-LCM-LightOJ-1215" class="headerlink" title="Finding LCM LightOJ - 1215"></a><a href="http://lightoj.com/volume_showproblem.php?problem=1215" target="_blank" rel="noopener">Finding LCM LightOJ - 1215</a></h2><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>$LCM(a, b, c) = L$<br>现在告诉你a, b, L，问你c的最小值是多少</p>
<h3 id="解题思路（一）"><a href="#解题思路（一）" class="headerlink" title="解题思路（一）"></a>解题思路（一）</h3><p>设$lcm = LCM(a, b)$，即求最小的c使得$LCM(lcm, c) = L$<br>设$g = gcd(lcm, c)$，那么$\frac{lcm \times c}{g}=L$<br>$c = \frac{L}{lcm} \times g$<br>设$k = \frac{L}{lcm}$，那么$c = k \times g$<br>又因为$gcd(lcm, c) = g$<br>所以$gcd(lcm, k \times g) = g$<br>即$gcd(\frac{lcm}{g}, k) = 1$<br>由于$k$已知，要使$c$最小即使$g$最小，其中$g|lcm$<br>那么我们$O(\sqrt{n})$时间找到最小能够使得$gcd(\frac{lcm}{g}, k) = 1$成立的$lcm$的因子即可</p>
<h3 id="AC代码（一）"><a href="#AC代码（一）" class="headerlink" title="AC代码（一）"></a>AC代码（一）</h3><div><div class="fold_hider"><div class="close hider_title"></div></div><div class="fold">
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">3e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a, ll b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> b == <span class="number">0</span> ? a : gcd(b, a % b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> T;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">	<span class="keyword">int</span> cas = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (T--) &#123;</span><br><span class="line">		ll a, b, l;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%lld%lld%lld"</span>, &amp;a, &amp;b, &amp;l);</span><br><span class="line">		ll lcm = a / gcd(a, b) * b;</span><br><span class="line">		<span class="keyword">if</span> (l % lcm) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"Case %d: impossible\n"</span>, ++cas);</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		ll k = l / lcm;</span><br><span class="line">		ll kk = <span class="built_in">sqrt</span>(lcm);</span><br><span class="line">		ll ans = l;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= kk; ++i) &#123;</span><br><span class="line">			<span class="keyword">if</span> (lcm % i == <span class="number">0</span>) &#123;</span><br><span class="line">				<span class="keyword">if</span> (gcd(lcm / i, k) == <span class="number">1</span>)</span><br><span class="line">					ans = min(ans, <span class="number">1l</span>l * i * k);</span><br><span class="line">				<span class="keyword">if</span> (gcd(i, k) == <span class="number">1</span>)</span><br><span class="line">					ans = min(ans, lcm / i * k);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Case %d: %lld\n"</span>, ++cas, ans);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></div>
<h3 id="解题思路（二）"><a href="#解题思路（二）" class="headerlink" title="解题思路（二）"></a>解题思路（二）</h3><p>根据思路一中的结论，我们得到了$gcd(\frac{lcm}{g}, k) = 1$，并且$c=k \times g$<br>那么我们接下来进行这么一系列操作<br>令$g_{1}=gcd(lcm, k)$<br>$g_{2}=gcd(\frac{lcm}{g_{1}},k \times g_{1})$<br>$…$<br>$g_{k + 1} = gcd(\frac{lcm}{g_{1}g_{2}…g_{n}}, k \times g_{1}g_{2}…g_{n})$<br>那么当$n$增大到一定范围时$g_{n + 1} = gcd(\frac{lcm}{g_{1}g_{2}…g_{n}}, k \times g_{1}g_{2}…g_{n})$必定等于1<br>现在我令$g=g_{1}g_{2}…g_{n}$<br>那么$gcd(\frac{lcm}{g}, k \times g)=1$<br>显然$gcd(\frac{lcm}{g}, k)=1$，因为$\frac{lcm}{g}$中一定不会包含任何一个与$k$有关的因子，不然就不满足$gcd(\frac{lcm}{g}, k \times g)=1$<br>所以$c=k \times g$为一个满足条件的解<br>现在证明它是最小的<br>由于$\frac{c}{gcd(lcm, c)}=k$，在$k$已知的情况下要想$c$最小，那么$gcd(lcm, c)$要最小<br>现在$c=k \times g$，那么$gcd(lcm, c)=g=g_{1}g_{2}…g_{n}$，你会发现它的确是最小的，因为你去除任意一个$g_{i}$均会使得<br>$gcd(\frac{lcm}{g_{1}g_{2}…g_{n}}, k \times g_{1}g_{2}…g_{i-1}g_{i+1}…g_{n}) = g_{i} &gt; 1$<br>而如果你去除$g_{i}$后在$g$加入一个无关的因子$g_{m}$，其中$g_{m}&lt;g_{i}$，则会导致$LCM(a, b, c) \neq L$<br>综上所述$c = k \times g_{1}g_{2}…g_{n}$为所求最优解<br>证毕</p>
<p>所以我们使用循环或递归来求出$g_{1}g_{2}…g_{n}$，那么答案即为$k \times g_{1}g_{2}…g_{n}$</p>
<h3 id="AC代码（二）"><a href="#AC代码（二）" class="headerlink" title="AC代码（二）"></a>AC代码（二）</h3><div><div class="fold_hider"><div class="close hider_title"></div></div><div class="fold">
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a, ll b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> b == <span class="number">0</span> ? a : gcd(b, a % b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> T;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">	<span class="keyword">int</span> cas = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (T--) &#123;</span><br><span class="line">		ll a, b, l;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%lld%lld%lld"</span>, &amp;a, &amp;b, &amp;l);</span><br><span class="line">		ll lcm = a / gcd(a, b) * b;</span><br><span class="line">		<span class="keyword">if</span> (l % lcm) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"Case %d: impossible\n"</span>, ++cas);</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		ll k = l / lcm;</span><br><span class="line">		<span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">			ll g = gcd(lcm, k);</span><br><span class="line">			<span class="keyword">if</span> (g == <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">			k *= g;</span><br><span class="line">			lcm /= g;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Case %d: %lld\n"</span>, ++cas, k);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></div>
]]></content>
      <categories>
        <category>LightOJ</category>
      </categories>
      <tags>
        <tag>LightOJ</tag>
        <tag>数论</tag>
        <tag>欧几里得定理</tag>
      </tags>
  </entry>
  <entry>
    <title>LCM Extreme LightOJ - 1375</title>
    <url>/ZLY201.github.io/2020/07/06/LightOJ%20-%201375/</url>
    <content><![CDATA[<h2 id="LCM-Extreme-LightOJ-1375"><a href="#LCM-Extreme-LightOJ-1375" class="headerlink" title="LCM Extreme LightOJ - 1375"></a><a href="http://lightoj.com/volume_showproblem.php?problem=1375" target="_blank" rel="noopener">LCM Extreme LightOJ - 1375</a></h2><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="title">allPairLcm</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">            res += lcm(i, j); <span class="comment">// lcm means least common multiple</span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>给出n，输出上述程序的运行结果</p>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>$res=\sum_{i=1}^{n}\sum_{j=i+1}^{n}lcm(i, j)=\sum_{i=2}^{n}\sum_{j=1}^{i-1}lcm(i, j)$<br>令$s(x)=\sum_{i=1}^{x-1}lcm(i, x)$，那么答案就是$\sum_{i=2}^{n}s(i)$，显然可以预处理<br>对于$s(x)$，有：<br>$s(x)=\sum_{i=1}^{x-1}lcm(i, x)=\sum_{i=1}^{x-1}\frac{i \times x}{gcd(i, x)}=x \times \sum_{i=1}^{x-1}\frac{i}{gcd(i, x)}$<br>令$g = gcd(i, x)$<br>$s(x)=x \times \sum_{i=1}^{x-1}\frac{i}{g}$<br>其中$g|x$，并且$gcd(i, x) = g$<br>令$i = \frac{i}{g}$，那么$s(x)=x \times \sum_{i=1}^{\frac{x}{g}-1}i$<br>其中$gcd(i, \frac{x}{g})=1$，即$i$与$\frac{x}{g}$互质<br>由欧拉定理可知</p>
<blockquote>
<p>小于$n$，且与$n$互质的数之和等于$\frac{n \times \phi(n)}{2}$</p>
</blockquote>
<p>那么$s(x)=x \times \sum_{g|x}\frac{\frac{x}{g} \times \phi(\frac{x}{g})}{2}$<br>这样我们预处理出$\phi(n)$，然后枚举$g$求出$s(x)$，最后求出前缀和即可</p>
<h3 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h3><div><div class="fold_hider"><div class="close hider_title"></div></div><div class="fold">
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">3e6</span> + <span class="number">10</span>;</span><br><span class="line">ll phi[maxn];</span><br><span class="line">ll s[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">eulor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	phi[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; maxn; ++i) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!phi[i]) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; maxn; j += i) &#123;</span><br><span class="line">				<span class="keyword">if</span> (!phi[j]) phi[j] = j;</span><br><span class="line">				phi[j] = phi[j] / i * (i - <span class="number">1</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> g = <span class="number">1</span>; g &lt; maxn; ++g) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> x = g; x &lt; maxn; x += g) &#123;</span><br><span class="line">			<span class="keyword">int</span> t = x / g;</span><br><span class="line">			s[x] += phi[t] * t / <span class="number">2</span> * x;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; maxn; ++i) &#123;</span><br><span class="line">		s[i] += s[i - <span class="number">1</span>];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> T;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">	<span class="keyword">int</span> cas = <span class="number">0</span>;</span><br><span class="line">	eulor();</span><br><span class="line">	<span class="keyword">while</span> (T--) &#123;</span><br><span class="line">		<span class="keyword">int</span> n;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Case %d: %llu\n"</span>, ++cas, s[n]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></div>
<h3 id="编写参考"><a href="#编写参考" class="headerlink" title="编写参考"></a>编写参考</h3><p><a href="https://www.cnblogs.com/-Wallace-/p/12897967.html" target="_blank" rel="noopener">https://www.cnblogs.com/-Wallace-/p/12897967.html</a></p>
]]></content>
      <categories>
        <category>LightOJ</category>
      </categories>
      <tags>
        <tag>LightOJ</tag>
        <tag>数论</tag>
        <tag>欧拉函数</tag>
      </tags>
  </entry>
  <entry>
    <title>Birthday Paradox LightOJ - 1104</title>
    <url>/ZLY201.github.io/2020/07/25/LightOJ%20-%201104/</url>
    <content><![CDATA[<h2 id="Birthday-Paradox-LightOJ-1104"><a href="#Birthday-Paradox-LightOJ-1104" class="headerlink" title="Birthday Paradox LightOJ - 1104"></a><a href="http://lightoj.com/volume_showproblem.php?problem=1104" target="_blank" rel="noopener">Birthday Paradox LightOJ - 1104</a></h2><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>问你当一年有$n$天时，你和最少多少个人中两个人生日相同的概率不低于$0.5$</p>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>假设有$m$个人<br>对于第一个人其生日有$n$种可能<br>对于第二个人其生日与第一个人不相同的概率为$\frac{n-1}{n}$<br>对于第二个人其生日与第一个人和第二个人均不相同的概率为$\frac{n-2}{n}$<br>…<br>对于第$m$个人其生日与之前所有人均不相同的概率为$\frac{n-m+1}{n}$<br>那么这$m$个人两两生日不同的概率$p=1 \times \frac{n-1}{n}\times\frac{n-2}{n}\times…\times \frac{n-m+1}{n}=\frac{n!}{(n-m)!\times n^{n}}$<br>那么本题即要求$1-p\leq0.5$，即$p\geq0.5$<br>考虑$n$的范围太大，阶乘会溢出，我们可以采用对数的形式对不等式进行化简</p>
<script type="math/tex; mode=display">\frac{n!}{(n-m)!\times n^{n}}\geq0.5</script><script type="math/tex; mode=display">lg^{n!}-lg^{(n-m)!}-nlg^{n}\geq-1</script><script type="math/tex; mode=display">lg^{n!}-lg^{(n-m)!}-nlg^{n}+1\geq0</script><script type="math/tex; mode=display">lg^{1}+lg^{2}+...+lg^{n}-(lg^{1}+lg^{2}+...+lg^{n-m})-nlg^{n}+1\geq0</script><script type="math/tex; mode=display">\sum_{i=1}^{n}lg^i-\sum_{i=1}^{n-m}lg^i-nlg^{n}+1\geq0</script><p>这样我们预处理出$1e^{5}$以内的$lg$和然后对$m$进行二分即可</p>
<p>注：要特判$n=1$的情况</p>
<h3 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h3><div><div class="fold_hider"><div class="close hider_title"></div></div><div class="fold">
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">double</span> sum[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pre</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	sum[<span class="number">0</span>] = sum[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; maxn; ++i) &#123;</span><br><span class="line">		sum[i] = sum[i - <span class="number">1</span>] + log2(i);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">judge</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">double</span> tmp = sum[n] - sum[n - m] - m * <span class="number">1.0</span> * log2(n);</span><br><span class="line">	<span class="keyword">return</span> tmp + <span class="number">1.0</span> &lt;= <span class="number">0.0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> T;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">	<span class="keyword">int</span> cas = <span class="number">0</span>;</span><br><span class="line">	pre();</span><br><span class="line">	<span class="keyword">while</span> (T--) &#123;</span><br><span class="line">		<span class="keyword">int</span> n;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">		<span class="keyword">int</span> l = <span class="number">1</span>, r = n;</span><br><span class="line">		<span class="keyword">int</span> res = n;</span><br><span class="line">		<span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">			<span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span> (judge(mid, n)) &#123;</span><br><span class="line">				r = mid - <span class="number">1</span>;</span><br><span class="line">				res = min(res, mid);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Case %d: %d\n"</span>, ++cas, max(res - <span class="number">1</span>, <span class="number">1</span>));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></div>]]></content>
      <categories>
        <category>LightOJ</category>
      </categories>
      <tags>
        <tag>LightOJ</tag>
        <tag>概率&amp;期望</tag>
      </tags>
  </entry>
  <entry>
    <title>NewCoder - Boundary</title>
    <url>/ZLY201.github.io/2020/07/14/NewCoder%20-%20Boundary/</url>
    <content><![CDATA[<h2 id="NewCoder-Boundary"><a href="#NewCoder-Boundary" class="headerlink" title="NewCoder - Boundary"></a><a href="https://ac.nowcoder.com/acm/contest/5667/B" target="_blank" rel="noopener">NewCoder - Boundary</a></h2><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>给你一些点，问你过原点的圆能够包含这些点的最大数目是多少</p>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>由于三个点可以确定一个圆，那么我们$O(n^{2})$将任意两个点和原点形成的圆心坐标求出来，然后对这些坐标进行排序，然后$O(n^{2})$的时间统计圆心相同的数目，取其中的最大值即可，总复杂度$O(n^{2}log_{2}^{n})$</p>
<p>那么其中涉及到三个问题</p>
<ol>
<li>圆心怎么表示，double可能会有精度问题</li>
<li>假设$(i,j_{1})，(i,j_{2})，…，(i,j_{n})$的圆心坐标相同，那么我统计$(j_{1},j_{2})，…，(j_{1},j_{n})$时会导致统计重复</li>
</ol>
<p>对于第一个问题，我推导公式发现圆心坐标$(x, y)$可以写成$(\frac{a}{c},\frac{b}{c})$的形式，那么我们可以记录a，b，c的值，将其表示成分数形式</p>
<p>对于第二个问题，假设与$i$成对的$j$有$n$个，那么与$j_{1}$成对的自然有$n-1$个，这是一个等差数列，得到最大值后用求根公式将$n$求出即可</p>
<p>注：千万不要用map，虽然理论上复杂度也是$O(n^{2}log_{2}^{n})$，但是这题的数据很严格，导致常数很大，使用卡常技巧也只能只能过70%的数据</p>
<h3 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h3><div><div class="fold_hider"><div class="close hider_title"></div></div><div class="fold">
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(2)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e3</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">4e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">&#125;;</span><br><span class="line">point p[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    ll a, b;</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="title">Node</span><span class="params">()</span> </span>&#123; a = b = c = <span class="number">0</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="title">Node</span><span class="params">(<span class="keyword">register</span> ll aa, <span class="keyword">register</span> ll bb, <span class="keyword">register</span> <span class="keyword">int</span> cc)</span> </span>&#123;</span><br><span class="line">        a = aa, b = bb, c = cc;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Node&amp; B)<span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">register</span> ll xx = B.c * <span class="number">1l</span>l * a - c * <span class="number">1l</span>l * B.a;</span><br><span class="line">        <span class="keyword">register</span> ll yy = B.c * <span class="number">1l</span>l * b - c * <span class="number">1l</span>l * B.b;</span><br><span class="line">        <span class="keyword">if</span> ((c &gt; <span class="number">0</span> &amp;&amp; B.c &lt; <span class="number">0</span>) || (c &lt; <span class="number">0</span> &amp;&amp; B.c &gt; <span class="number">0</span>)) xx = -xx, yy = -yy;</span><br><span class="line">        <span class="keyword">if</span> (yy == <span class="number">0</span>) <span class="keyword">return</span> xx &lt; <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> yy &lt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Node&amp; B)<span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (B.c * <span class="number">1l</span>l * a - c * <span class="number">1l</span>l * B.a == <span class="number">0</span>) &amp;&amp; (B.c * <span class="number">1l</span>l * b - c * <span class="number">1l</span>l * B.b) == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;pp[maxn];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">judge</span><span class="params">(<span class="keyword">register</span> point&amp; a, <span class="keyword">register</span> point&amp; b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a.x &amp;&amp; !a.y &amp;&amp; !b.x &amp;&amp; b.y) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (!a.x &amp;&amp; a.y &amp;&amp; b.x &amp;&amp; !b.y) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>), <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; p[i].x &gt;&gt; p[i].y;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">            <span class="keyword">register</span> <span class="keyword">int</span> x1 = p[i].x, y1 = p[i].y;</span><br><span class="line">            <span class="keyword">register</span> <span class="keyword">int</span> x2 = p[j].x, y2 = p[j].y;</span><br><span class="line">            <span class="keyword">register</span> <span class="keyword">int</span> c = y2 * x1 - y1 * x2;</span><br><span class="line">            <span class="keyword">if</span> (!c) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!judge(p[i], p[j])) <span class="keyword">continue</span>;</span><br><span class="line">                pp[++cnt] = Node(x1 + x2, y1 + y2, <span class="number">2</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">register</span> <span class="keyword">int</span> c1 = x1 * x1 + y1 * y1, c2 = x2 * x2 + y2 * y2;</span><br><span class="line">            <span class="keyword">register</span> ll b = c2 * <span class="number">1l</span>l * x1 - c1 * <span class="number">1l</span>l * x2;</span><br><span class="line">            <span class="keyword">register</span> ll a = c1 * <span class="number">1l</span>l * y2 - c2 * <span class="number">1l</span>l * y1;</span><br><span class="line">            pp[++cnt] = Node(a, b, c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(pp + <span class="number">1</span>, pp + cnt + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">int</span> index = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">int</span> Max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt; cnt) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">register</span> <span class="keyword">int</span> tmp = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (index &lt; cnt &amp;&amp; pp[index] == pp[index + <span class="number">1</span>]) ++index, ++tmp;</span><br><span class="line">        Max = max(Max, tmp);</span><br><span class="line">        ++index;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (Max == <span class="number">0</span>) <span class="built_in">cout</span> &lt;&lt; <span class="string">"1\n"</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> k = (<span class="built_in">sqrt</span>(<span class="number">1</span> + <span class="number">8</span> * Max) - <span class="number">1</span>) / <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; k &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></div>
]]></content>
      <categories>
        <category>NewCoder</category>
      </categories>
      <tags>
        <tag>NewCoder</tag>
        <tag>计算几何</tag>
      </tags>
  </entry>
  <entry>
    <title>NewCoder - Easy Integration</title>
    <url>/ZLY201.github.io/2020/07/14/NewCoder%20-%20Easy%20Integration/</url>
    <content><![CDATA[<h2 id="NewCoder-Easy-Integration"><a href="#NewCoder-Easy-Integration" class="headerlink" title="NewCoder - Easy Integration"></a><a href="https://ac.nowcoder.com/acm/contest/5666/J" target="_blank" rel="noopener">NewCoder - Easy Integration</a></h2><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>给出$n$，让你输出$\int_{0}^{1}(x-x^{2})^{n}$的值</p>
<p>注：这个值可以被表示成$\frac{p}{q}$的形式，请使用$(p \cdot q^{-1}) \bmod {998244353}$的形式</p>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>根据分布积分法求出$int_{0}^{1}(x-x^{2})^{n}$的通项公式为：</p>
<script type="math/tex; mode=display">\frac{n!}{\prod_{i=n+1}^{2n + 1}i}</script><p>为了方便预处理，我们可以将其变一下形：</p>
<script type="math/tex; mode=display">\frac{n! \cdot n!}{(2n + 1)!}</script><p>那么将其写成逆元的形式就是$(n!)^{2} \cdot inv((2n + 1)!)$<br>$O(n)$将阶乘和阶乘逆元递推出来，然后O(1)输出结果就可以了</p>
<h3 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h3><div><div class="fold_hider"><div class="close hider_title"></div></div><div class="fold">
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e6</span> + <span class="number">5</span>;</span><br><span class="line">ll a[N];</span><br><span class="line">ll inv[N];</span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll x, ll y, ll m)</span> </span>&#123;</span><br><span class="line">    ll ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (y) &#123;</span><br><span class="line">        <span class="keyword">if</span> (y &amp; <span class="number">1</span>) ans = ans * x % m;</span><br><span class="line">        x = x * x % m;</span><br><span class="line">        y &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    a[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; N; ++i)  &#123;</span><br><span class="line">        a[i] = a[i - <span class="number">1</span>] * i % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    inv[N - <span class="number">1</span>] = qpow(a[N - <span class="number">1</span>], mod - <span class="number">2</span>, mod);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = N - <span class="number">2</span>; i &gt;= <span class="number">1</span>; --i) &#123;</span><br><span class="line">        inv[i] = inv[i + <span class="number">1</span>] * (i * <span class="number">1l</span>l + <span class="number">1</span>) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    init();</span><br><span class="line">    ll n;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n) &#123;</span><br><span class="line">        ll ans = a[n] * a[n] % mod * inv[<span class="number">2</span> * n + <span class="number">1</span>] % mod;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></div>
]]></content>
      <categories>
        <category>NewCoder</category>
      </categories>
      <tags>
        <tag>NewCoder</tag>
        <tag>数学</tag>
        <tag>数论</tag>
        <tag>乘法逆元</tag>
      </tags>
  </entry>
  <entry>
    <title>NewCoder - Cover the Tree</title>
    <url>/ZLY201.github.io/2020/07/14/NewCoder%20-%20Cover%20the%20Tree/</url>
    <content><![CDATA[<h2 id="NewCoder-Cover-the-Tree"><a href="#NewCoder-Cover-the-Tree" class="headerlink" title="NewCoder - Cover the Tree"></a><a href="https://ac.nowcoder.com/acm/contest/5667/C" target="_blank" rel="noopener">NewCoder - Cover the Tree</a></h2><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>给你一颗无根树，树上任意两个节点可以形成一条链，问你最少多少个链可以将所有边包含进来</p>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>贴一个官方题解<br><img src="../NewCoder - Cover the Tree/NewCoder - Cover the Tree官方题解.png" alt=""></p>
<h3 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h3><div><div class="fold_hider"><div class="close hider_title"></div></div><div class="fold">
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v[maxn];</span><br><span class="line"><span class="keyword">int</span> _dfs[maxn];</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> _dfs[i] &lt; _dfs[j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">    _dfs[u] = ++cnt;</span><br><span class="line">    <span class="keyword">int</span> len = v[u].size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> y = v[u][i];</span><br><span class="line">        <span class="keyword">if</span> (y == fa) <span class="keyword">continue</span>;</span><br><span class="line">        dfs(v[u][i], u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>), <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> x, y;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        v[x].push_back(y);</span><br><span class="line">        v[y].push_back(x);</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vv;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (v[i].size() == <span class="number">1</span>) &#123;</span><br><span class="line">            vv.push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(vv.begin(), vv.end(), cmp);</span><br><span class="line">    <span class="keyword">int</span> num = (vv.size() + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; num &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; ++i) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; vv[i] &lt;&lt; <span class="string">" "</span> &lt;&lt; vv[min(i + num, (<span class="keyword">int</span>)vv.size() - <span class="number">1</span>)] &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></div>
]]></content>
      <categories>
        <category>NewCoder</category>
      </categories>
      <tags>
        <tag>NewCoder</tag>
        <tag>dfs序</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>Common Subsequence POJ - 1458</title>
    <url>/ZLY201.github.io/2020/07/12/POJ%20-%201458/</url>
    <content><![CDATA[<h2 id="Common-Subsequence-POJ-1458"><a href="#Common-Subsequence-POJ-1458" class="headerlink" title="Common Subsequence POJ - 1458"></a><a href="http://poj.org/problem?id=1458" target="_blank" rel="noopener">Common Subsequence POJ - 1458</a></h2><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>给你两个字符串$s$和$p$，让你求最长公共子串的长度</p>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>对于字符$s[i]$和$p[j]$可以分为相同和不同两种情况，如果相同则可以将其加入到$s[i]$之前与$p[j]$之前的最长公共子串中去，否则忽略，那么我们定义$dp[i][j]$表示$s$中前$i$个字符与$p$中前$j$个字符的最长公共子串的长度，其状态转移方程为：</p>
<script type="math/tex; mode=display">dp[i][j]=
\begin
{cases}
{dp[i-1][j-1] + 1} & {s[i]=p[j]} \\
{max(dp[i-1][j],dp[i][j-1])} & {s[i]!=p[j]}
\end
{cases}</script><h3 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h3><div><div class="fold_hider"><div class="close hider_title"></div></div><div class="fold">
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">1010</span>][<span class="number">1010</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">string</span> s, p;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; s &gt;&gt; p) &#123;</span><br><span class="line">		s = <span class="string">" "</span> + s;</span><br><span class="line">		p = <span class="string">" "</span> + p;</span><br><span class="line">		<span class="keyword">int</span> ls = s.length();</span><br><span class="line">		<span class="keyword">int</span> lp = p.length();</span><br><span class="line">		<span class="keyword">int</span> Max = <span class="number">0</span>;</span><br><span class="line">		<span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; ls; ++i) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; lp; ++j) &#123;</span><br><span class="line">				<span class="keyword">if</span> (s[i] == p[j]) dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">				<span class="keyword">else</span> dp[i][j] = max(dp[i][j - <span class="number">1</span>], dp[i - <span class="number">1</span>][j]);</span><br><span class="line">				Max = max(dp[i][j], Max);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; Max &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></div>
]]></content>
      <categories>
        <category>POJ</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>POJ</tag>
        <tag>最长公共子串</tag>
      </tags>
  </entry>
  <entry>
    <title>NewCoder - Fake Maxpooling</title>
    <url>/ZLY201.github.io/2020/07/14/NewCoder%20-%20Fake%20Maxpooling/</url>
    <content><![CDATA[<h2 id="NewCoder-Fake-Maxpooling"><a href="#NewCoder-Fake-Maxpooling" class="headerlink" title="NewCoder - Fake Maxpooling"></a><a href="https://ac.nowcoder.com/acm/contest/5667/F" target="_blank" rel="noopener">NewCoder - Fake Maxpooling</a></h2><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>定义矩阵$A$，其中$A_{i,j}=lcm(i,j)$，让你用一个$k \times k$的矩阵取框这个$A$，问你所有$k \times k$矩阵中的最大值之和是多少</p>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>首先是官方题解<br><img src="../NewCoder - Fake Maxpooling/NewCoder - Fake Maxpooling官方题解.png" alt=""></p>
<p>后来我看到有一个很巧妙的dp做法<br>我们首先将$A_{ij}$给求出来，然后$dp[i][j]$表示以$(1, 1)$为左上角，以$(i, j)$为右下角的最大值，那么其状态转移方程为：</p>
<script type="math/tex; mode=display">dp[i][j]=max(dp[i][j],dp[i-1][j],dp[i][j-1],dp[i-1][j-1])</script><p>由于$i &lt; k，j &lt; k$时$A[i][j]$对答案没有影响，我们统计$dp[i][j]，k \leq i,j \leq n$的和即可</p>
<h3 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h3><div><div class="fold_hider"><div class="close hider_title"></div></div><div class="fold">
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">5e3</span> + <span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> !b ? a : gcd(b, a % b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> dp[maxn][maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">cin</span>.tie(<span class="number">0</span>), <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">int</span> n, m, k;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">	ll res = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j) &#123;</span><br><span class="line">			<span class="keyword">int</span> tmp = i / gcd(i, j) * j;</span><br><span class="line">			res += tmp * <span class="number">1l</span>l;</span><br><span class="line">			dp[i][j] = max(tmp, max(dp[i - <span class="number">1</span>][j], max(dp[i][j - <span class="number">1</span>], dp[i - <span class="number">1</span>][j - <span class="number">1</span>])));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(k != <span class="number">1</span>) &#123;</span><br><span class="line">		res = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = k; i &lt;= n; ++i) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = k; j &lt;= m; ++j) &#123;</span><br><span class="line">				res += dp[i][j] * <span class="number">1l</span>l;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></div>
]]></content>
      <categories>
        <category>NewCoder</category>
      </categories>
      <tags>
        <tag>NewCoder</tag>
        <tag>动态规划</tag>
        <tag>单调队列</tag>
      </tags>
  </entry>
  <entry>
    <title>NewCoder - Infinite String Comparision</title>
    <url>/ZLY201.github.io/2020/07/13/NewCoder%20-%20Infinite%20String%20Comparision/</url>
    <content><![CDATA[<h2 id="NewCoder-Infinite-String-Comparision"><a href="#NewCoder-Infinite-String-Comparision" class="headerlink" title="NewCoder - Infinite String Comparision"></a><a href="https://ac.nowcoder.com/acm/contest/5666/F" target="_blank" rel="noopener">NewCoder - Infinite String Comparision</a></h2><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>将两个字符串$s$和$p$无限延长，问你这两个字符串的大小关系</p>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>将两个字符串分别延长两倍后进行比较即可<br>证明：<br>如果在$min(len(s), len(p))$之内有不同的字符串，那么结果显然<br>否则假设$len(s) &gt; len(p)$<br>令$s = s + s，p = p + p$，由于在$len(p)$之内$s$和$p$相同，那么<br>$s = p + s’ + p + s’$<br>$p = p + p$<br>由于$(s’ + p)$的长度显然大于$p$的长度，那么我们必定可以比较出$s$与$p$的关系</p>
<p>$len(s) &lt; len(p)$同理</p>
<h3 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h3><div><div class="fold_hider"><div class="close hider_title"></div></div><div class="fold">
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>), <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">string</span> s, p;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; s &gt;&gt; p) &#123;</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">        s += s, p += p;</span><br><span class="line">        <span class="keyword">if</span>(s.length() &lt; p.length()) &#123;</span><br><span class="line">            swap(s, p);</span><br><span class="line">            flag = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ls = s.length(), lp = p.length();</span><br><span class="line">        <span class="keyword">int</span> tag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ls; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> index = i % lp;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == p[i % lp]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (s[i] &lt; p[i % lp]) tag = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> tag = <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (tag == <span class="number">0</span>) <span class="built_in">cout</span> &lt;&lt; <span class="string">"=\n"</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (tag == <span class="number">1</span>) <span class="built_in">cout</span> &lt;&lt; (flag ? <span class="string">"&gt;\n"</span> : <span class="string">"&lt;\n"</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; (flag ? <span class="string">"&lt;\n"</span> : <span class="string">"&gt;\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></div>
]]></content>
      <categories>
        <category>NewCoder</category>
      </categories>
      <tags>
        <tag>NewCoder</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>Interesting Yang Hui Triangle POJ - 3146</title>
    <url>/ZLY201.github.io/2020/07/09/POJ%20-%203146/</url>
    <content><![CDATA[<h2 id="Interesting-Yang-Hui-Triangle-POJ-3146"><a href="#Interesting-Yang-Hui-Triangle-POJ-3146" class="headerlink" title="Interesting Yang Hui Triangle POJ - 3146"></a><a href="http://poj.org/problem?id=3146" target="_blank" rel="noopener">Interesting Yang Hui Triangle POJ - 3146</a></h2><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>问你杨辉三角第n行有多少个数不能被p整除</p>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>杨辉三角第n行第i个数为$C_{n}^{i-1}$<br>根据卢卡斯定理我们可知，假设$a$和$b$在$p$进制下分别表示为$a_{k}a_{k-1}…a_{0}$和$b_{k}b_{k-1}…b_{0}$，那么<br>$C_{a}^{b} \equiv {C_{a_{k}}^{b_{k}}C_{a_{k-1}}^{b_{k-1}}…C_{a_{0}}^{b_{0}}} \pmod {p}$<br>要使得$C_{a}^{b}$不能被p整除，那么$\forall {i} \in [0, k]$，$a_{i} \geq b_{i}$<br>根据计数原理，我们求出p进制下的$n=n_{k}n_{k-1}…n_{0}$，那么答案即为$(n_{0} + 1)(n_{1} + 1)…(n_{k} + 1)$</p>
<h3 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h3><div><div class="fold_hider"><div class="close hider_title"></div></div><div class="fold">
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ll p, n;</span><br><span class="line">	<span class="keyword">int</span> cas = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; p &gt;&gt; n) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!p &amp;&amp; !n) <span class="keyword">break</span>;</span><br><span class="line">		ll ans = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span> (n) &#123;</span><br><span class="line">			ans = ans * (n % p + <span class="number">1</span>) % <span class="number">10000</span>;</span><br><span class="line">			n /= p;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Case %d: %04lld\n"</span>, ++cas, ans);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></div>]]></content>
      <categories>
        <category>POJ</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>POJ</tag>
        <tag>卢卡斯定理</tag>
      </tags>
  </entry>
  <entry>
    <title>青蛙的约会 POJ - 1061</title>
    <url>/ZLY201.github.io/2020/07/08/POJ%20-%201061/</url>
    <content><![CDATA[<h2 id="青蛙的约会-POJ-1061"><a href="#青蛙的约会-POJ-1061" class="headerlink" title="青蛙的约会 POJ - 1061"></a><a href="http://poj.org/problem?id=1061" target="_blank" rel="noopener">青蛙的约会 POJ - 1061</a></h2><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>两只青蛙在L长的圆形跑道上玩跳跳乐，青蛙A的出发点坐标为x，一次能跳m米，青蛙B的出发点坐标y，一次能跳n米，他们跳一次时间相同，同时起跳，问你跳几次能相遇</p>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>设$t$次后相遇<br>$x + mt \equiv {y + nt} \pmod {L}$<br>$(x + mt) - (y + nt) = qL$<br>$(m - n)t - qL = (y - x)$<br>$(n - m)t + qL = (x - y)$<br>是不是长得很像$ax + by = c$<br>用拓展欧几里得定理求解t即可</p>
<h3 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h3><div><div class="fold_hider"><div class="close hider_title"></div></div><div class="fold">
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a, ll b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> !b ? a : gcd(b, a % b);</span><br><span class="line">&#125;</span><br><span class="line">pair&lt;ll, ll&gt; exgcd(ll a, ll b) &#123;</span><br><span class="line">	<span class="keyword">if</span> (!b) <span class="keyword">return</span> pair&lt;ll, ll&gt;(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">	pair&lt;ll, ll&gt; temp = exgcd(b, a % b);</span><br><span class="line">	<span class="keyword">return</span> pair&lt;ll, ll&gt;(temp.second, temp.first - a / b * temp.second);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">cin</span>.tie(<span class="number">0</span>), <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">	ll x, y, m, n, l;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y &gt;&gt; m &gt;&gt; n &gt;&gt; l;</span><br><span class="line">	ll a = n - m, b = l;</span><br><span class="line">	ll g = gcd(a, b);</span><br><span class="line">	ll delta = x - y;</span><br><span class="line">	<span class="keyword">if</span> (delta % g) <span class="built_in">cout</span> &lt;&lt; <span class="string">"Impossible\n"</span>;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		pair&lt;ll, ll&gt; pp = exgcd(a, b);</span><br><span class="line">		ll t = pp.first, p = pp.second;</span><br><span class="line">		ll mod = l / g;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; (delta / g * t % mod + mod) % mod &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></div>]]></content>
      <categories>
        <category>POJ</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>POJ</tag>
        <tag>拓展欧几里得定理</tag>
      </tags>
  </entry>
  <entry>
    <title>Treats for the Cows POJ - 3186</title>
    <url>/ZLY201.github.io/2020/07/12/POJ%20-%203186/</url>
    <content><![CDATA[<h2 id="Treats-for-the-Cows-POJ-3186"><a href="#Treats-for-the-Cows-POJ-3186" class="headerlink" title="Treats for the Cows POJ - 3186"></a><a href="http://poj.org/problem?id=3186" target="_blank" rel="noopener">Treats for the Cows POJ - 3186</a></h2><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>有一个数组$a$，每次你可以将数组的头部或尾部添加到新数组$b$的结尾，问你$W = \sum_{i=1}^{n}b_{i} \times i$的最大值是多少</p>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>对于$b[i]$仅有两个状态，要么是当前$a$数组的开头，要么是$a$数组的结尾，那么我们定义$dp[i][j]$为当前$a$数组开头取了$i$个，结尾取了$j$个的最大值，其状态转移方程为：</p>
<script type="math/tex; mode=display">dp[i][j]=max(dp[i-1][j] + a[i] \times (i + j), dp[i][j - 1] + a[n - j + 1] \times (i + j))</script><p>初始条件为：</p>
<script type="math/tex; mode=display">\begin
{cases}
dp[i][0] += dp[i - 1][0] + a[i] * i \\
dp[0][i] += dp[0][i - 1] + a[n - i + 1] * i \\
\end
{cases}</script><h3 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h3><div><div class="fold_hider"><div class="close hider_title"></div></div><div class="fold">
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e3</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line"><span class="keyword">int</span> dp[maxn][maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">cin</span>.tie(<span class="number">0</span>), <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">		dp[i][<span class="number">0</span>] += dp[i - <span class="number">1</span>][<span class="number">0</span>] + a[i] * i;</span><br><span class="line">		dp[<span class="number">0</span>][i] += dp[<span class="number">0</span>][i - <span class="number">1</span>] + a[n - i + <span class="number">1</span>] * i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> Max = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; i + j &lt;= n; ++j) &#123;</span><br><span class="line">			dp[i][j] = max(dp[i - <span class="number">1</span>][j] + a[i] * (i + j), dp[i][j - <span class="number">1</span>] + a[n - j + <span class="number">1</span>] * (i + j));</span><br><span class="line">			Max = max(Max, dp[i][j]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; Max &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></div>
]]></content>
      <categories>
        <category>POJ</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>POJ</tag>
      </tags>
  </entry>
  <entry>
    <title>C Looooops POJ - 2115</title>
    <url>/ZLY201.github.io/2020/07/08/POJ%20-%202115/</url>
    <content><![CDATA[<h2 id="C-Looooops-POJ-2115"><a href="#C-Looooops-POJ-2115" class="headerlink" title="C Looooops POJ - 2115"></a><a href="http://poj.org/problem?id=2115" target="_blank" rel="noopener">C Looooops POJ - 2115</a></h2><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (variable = A; variable != B; variable += C) &#123;</span><br><span class="line">	i = (i % (<span class="number">1</span> &lt;&lt; k));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>给你A，B，C和K问你上述代码中循环的次数是多少</p>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>设运行次数为$N$<br>$(A + C \times N) \bmod {2^{k}} = B$<br>$NC + M2^{k} = B - A$<br>是不是长得很像$ax + by = c$<br>利用拓展欧几里得算法求出最小的N即可</p>
<h3 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h3><div><div class="fold_hider"><div class="close hider_title"></div></div><div class="fold">
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a, ll b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> !b ? a : gcd(b, a % b);</span><br><span class="line">&#125;</span><br><span class="line">pair&lt;ll, ll&gt; exgcd(ll a, ll b) &#123;</span><br><span class="line">	<span class="keyword">if</span> (!b) <span class="keyword">return</span> pair&lt;ll, ll&gt;(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">	pair&lt;ll, ll&gt; temp = exgcd(b, a % b);</span><br><span class="line">	<span class="keyword">return</span> pair&lt;ll, ll&gt;(temp.second, temp.first - a / b * temp.second);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">cin</span>.tie(<span class="number">0</span>), <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">	ll a, b, c, k;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; k) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!a &amp;&amp; !b &amp;&amp; !c &amp;&amp; !k) <span class="keyword">break</span>;</span><br><span class="line">		ll kk = (<span class="number">1l</span>l &lt;&lt; k);</span><br><span class="line">		pair&lt;ll, ll&gt; pp = exgcd(c, kk);</span><br><span class="line">		ll n = pp.first, m = pp.second;</span><br><span class="line">		ll delta = b - a;</span><br><span class="line">		ll g = gcd(c, kk);</span><br><span class="line">		ll mod = kk / g;</span><br><span class="line">		<span class="keyword">if</span> (delta % g) <span class="built_in">cout</span> &lt;&lt; <span class="string">"FOREVER\n"</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; (delta / g * n % mod + mod) % mod &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></div>]]></content>
      <categories>
        <category>POJ</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>POJ</tag>
        <tag>拓展欧几里得定理</tag>
      </tags>
  </entry>
  <entry>
    <title>Making the Grade POJ - 3666</title>
    <url>/ZLY201.github.io/2020/07/13/POJ%20-%203666/</url>
    <content><![CDATA[<h2 id="Making-the-Grade-POJ-3666"><a href="#Making-the-Grade-POJ-3666" class="headerlink" title="Making the Grade POJ - 3666"></a><a href="http://poj.org/problem?id=3666" target="_blank" rel="noopener">Making the Grade POJ - 3666</a></h2><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>将序列修改成单调不减的序列的最小成本是多少，假设修改前数组为$a$，修改后数组为$b$，成本定义为$\sum_{i=1}^{n}\lvert a_{i}-b_{i}\rvert$</p>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>模拟过后发现无论怎么改，对于最优解，修改后的数组中任意一个数在原数组中均能找到，我们定义$dp[i][j]$为前$i$序列中的最大值修改成$j$的情况，将$a$数组离散化到$[1, n]$区间之内，其状态转移方程为：</p>
<script type="math/tex; mode=display">dp[i][j] = abs(a[i] - b[j]) + min(dp[i - 1][k]) \qquad k \leq j</script><p>具体可以参考下面几篇博客：<br><a href="https://www.cnblogs.com/vb4896/p/5877962.html" target="_blank" rel="noopener">https://www.cnblogs.com/vb4896/p/5877962.html</a><br><a href="https://blog.csdn.net/u011815404/article/details/88552887" target="_blank" rel="noopener">https://blog.csdn.net/u011815404/article/details/88552887</a></p>
<h3 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h3><div><div class="fold_hider"><div class="close hider_title"></div></div><div class="fold">
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e3</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> a[maxn], b[maxn];</span><br><span class="line"><span class="keyword">int</span> dp[maxn][maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">cin</span>.tie(<span class="number">0</span>), <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">		b[i] = a[i];</span><br><span class="line">	&#125;</span><br><span class="line">	sort(b + <span class="number">1</span>, b + n + <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">		<span class="keyword">int</span> Min = INT_MAX;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">			Min = min(dp[i - <span class="number">1</span>][j], Min);</span><br><span class="line">			dp[i][j] = <span class="built_in">abs</span>(a[i] - b[j]) + Min;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> res = INT_MAX;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) res = min(res, dp[n][i]);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></div>
]]></content>
      <categories>
        <category>POJ</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>POJ</tag>
      </tags>
  </entry>
  <entry>
    <title>Milking Time POJ - 3616</title>
    <url>/ZLY201.github.io/2020/07/13/POJ%20-%203616/</url>
    <content><![CDATA[<h2 id="Milking-Time-POJ-3616"><a href="#Milking-Time-POJ-3616" class="headerlink" title="Milking Time POJ - 3616"></a><a href="http://poj.org/problem?id=3616" target="_blank" rel="noopener">Milking Time POJ - 3616</a></h2><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>在$N$时间之内有$M$次挤奶的机会，每次的开始时间为$start_{i}$，结束时间为$end_{i}$，每次挤奶的效率为$efficiency_{i}$，每次挤奶之后需要休息$R$小时，问你最大的效率和是多少</p>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>首先根据贪心策略，我们肯定优先选择结束时间早的时间段，所以我们先按照结束时间对时间段进行排序，现在假设我已经得到了$i$段之前的最大效率和，那么对于第$i + 1$个时间段，我可以将其添加到任意以$j$结尾，并且$start_{i} \geq end_{j} + R$的末尾，形成一个新的序列</p>
<p>那么定义$dp[i]$为以第$i$段结尾的最大效率和，其状态转移方程为：</p>
<script type="math/tex; mode=display">dp[i] = max(dp[i], dp[j] + efficiency_{i}) \qquad j < i \ \&\& \ start_{i} \geq end_{j} + R</script><h3 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h3><div><div class="fold_hider"><div class="close hider_title"></div></div><div class="fold">
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e3</span> + <span class="number">10</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> x, y, z;</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Node&amp; b)<span class="keyword">const</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (y != b.y) <span class="keyword">return</span> y &lt; b.y;</span><br><span class="line">		<span class="keyword">if</span> (x != b.x) <span class="keyword">return</span> x &lt; b.x;</span><br><span class="line">		<span class="keyword">return</span> z &gt; b.z;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;a[maxn];</span><br><span class="line"><span class="keyword">int</span> dp[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">cin</span>.tie(<span class="number">0</span>), <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">int</span> n, m, r;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; r;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; a[i].x &gt;&gt; a[i].y &gt;&gt; a[i].z;</span><br><span class="line">	&#125;</span><br><span class="line">	sort(a + <span class="number">1</span>, a + m + <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">		dp[i] = a[i].z;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= m; ++j) &#123;</span><br><span class="line">			<span class="keyword">if</span> (a[i].x &gt;= a[j].y + r) &#123;</span><br><span class="line">				dp[i] = max(dp[i], dp[j] + a[i].z);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		res = max(res, dp[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></div>
]]></content>
      <categories>
        <category>POJ</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>POJ</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>SaikrOJ - ipc2_5</title>
    <url>/ZLY201.github.io/2020/07/27/SaikrOJ%20-%20ipc2_5/</url>
    <content><![CDATA[<h2 id="SaikrOJ-ipc2-5"><a href="#SaikrOJ-ipc2-5" class="headerlink" title="SaikrOJ - ipc2_5"></a><a href="http://oj.saikr.com/problem/ipc2_5" target="_blank" rel="noopener">SaikrOJ - ipc2_5</a></h2><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>有一个数列，第$i$个数为$x_{i}$，它的长度为$n$</p>
<p>给出了$a$，$b$，$c$，要找到一个$i$，使得$a(i+1)x_{i}^{2}+(b+1)ix_{i}+(c+i)=0$成立</p>
<p>如果有多个$i$满足，要最小的那个$i$</p>
<p>有很多组询问需要回答，但是不确定有多少组，$a=b=c=0$标志着提问的结束</p>
<p>为了加大难度，数据被加密了</p>
<p>比如在输入中读到的数为$a_{0}，b_{0}，c_{0}$​，那么真正需要询问的$a=a_{0}+Last，b=b_{0}+Last，c=c_{0}+Last$</p>
<p>$Last$的值是你对上一个询问给出的答案。如果这是第一个询问，那么$Last=0$</p>
<p>所有的询问都会按以上叙述加密，包括结束标志</p>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>这题乍一看是一个公式题，但是无论你怎么推算没有不了发现任何规律，但是如果对于每一个询问都$O(n)$遍历的话显然会超时，问题似乎陷入了僵局</p>
<p>仔细读题，我们发现最后一组的$a_{0}，b_0，c_0$均为$0$，那么则有：</p>
<script type="math/tex; mode=display">
a=a_{0}+Last=0，b=b_{0}+Last=0，c=c_{0}+Last=0</script><p>可以得到：</p>
<script type="math/tex; mode=display">
Last=-a_{0}=-b_{0}=-c_{0}</script><p>？？？我们好像发现了什么不得了的东西</p>
<p>也就是说最后一组的答案我们是知道的，那么对于式子：</p>
<script type="math/tex; mode=display">
a(i+1)x_{i}^{2}+(b+1)ix_{i}+(c+i)=0</script><p>我们将其写成</p>
<script type="math/tex; mode=display">
(a_{0}+Last)(i+1)x_{i}^{2}+(b_{0}+Last)ix_{i}+(c_{0}+Last+i)=0</script><p>其中$a_0，b_0，c_0$为读入的数据，下标$i$为上一次求得的$Last’$，$x_{i}$已知，那么上式中唯一的未知数即为$Last$，也就是说<strong>我们可以通过该组的值直接求出上一组的值</strong></p>
<p>移项可以得到：</p>
<script type="math/tex; mode=display">
Last = -\frac{a_{0}(i+1)x_{i}+b_{0}ix_{i}+c_{0}+i}{(i+1)x_{i}+ix_{i}+1}</script><p><del>那么这题就做完了</del></p>
<h3 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h3><div><div class="fold_hider"><div class="close hider_title"></div></div><div class="fold">
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">500000</span> + <span class="number">10</span>;</span><br><span class="line">ll x[maxn];</span><br><span class="line">ll a[maxn], b[maxn], c[maxn];</span><br><span class="line">ll ans[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">cin</span>.tie(<span class="number">0</span>), <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">cin</span> &gt;&gt; x[i];</span><br><span class="line">	<span class="keyword">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; a[cnt] &gt;&gt; b[cnt] &gt;&gt; c[cnt]) ++cnt;</span><br><span class="line">	--cnt;</span><br><span class="line">	ans[cnt - <span class="number">1</span>] = -a[cnt];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = cnt - <span class="number">1</span>; i &gt;= <span class="number">1</span>; --i) &#123;</span><br><span class="line">		ll A = (ans[i] + <span class="number">1</span>) * x[ans[i]] * x[ans[i]];</span><br><span class="line">		ll B = ans[i] * x[ans[i]];</span><br><span class="line">		ll C = ans[i] + c[i];</span><br><span class="line">		ans[i - <span class="number">1</span>] = -(a[i] * A + (b[i] + <span class="number">1</span>) * B + C) / (A + B + <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt - <span class="number">1</span>; ++i) <span class="built_in">cout</span> &lt;&lt; ans[i] &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></div>
]]></content>
      <categories>
        <category>杂</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>Welcome To My Own Blog</title>
    <url>/ZLY201.github.io/2020/07/03/hellow/</url>
    <content><![CDATA[<div style="text-align: center">
    <table>
        <tr><td colspan="2" style="text-align: center"><font size="4">博主个人信息</font></td></tr>
        <tr>
            <td style="text-align: center">姓名</td>
            <td style="text-align: center">保密</td>
        </tr>
        <tr>
            <td style="text-align: center">性别</td>
            <td style="text-align: center">反正不是女的</td>
        </tr>
        <tr>
            <td style="text-align: center">年龄</td>
            <td style="text-align: center">别问，问就是18（orz）</td>
        </tr>
        <tr>
            <td style="text-align: center">学校</td>
            <td style="text-align: center">中国地质大学（武汉）</td>
        </tr>
        <tr>
            <td style="text-align: center">专业</td>
            <td style="text-align: center">计算机科学与技术</td>
        </tr>
        <tr><td rowspan="4" style="text-align: center">获奖情况</td></tr>
        <tr><td style="text-align: center">1. 信工学院编程大赛一等奖</td></tr>
        <tr><td style="text-align: center">2. 中国地质大学（武汉）暨华中地区ICPC邀请赛三等奖</td></tr>
        <tr><td style="text-align: center">3. 中国地质大学（武汉）数学建模校内选拔赛一等奖</td></tr>
    </table>
</div>

<p>欢迎访问我的其他博客主页（可能有惊喜哦）<br><a href="https://blog.csdn.net/weixin_44211980" target="_blank" rel="noopener">csdn博客主页</a><br><a href="https://www.luogu.com.cn/blog/226316/" target="_blank" rel="noopener">luogu博客主页</a></p>
<p>祝您玩的开心（0^_^0）！</p>
]]></content>
      <categories>
        <category>Hellow</category>
      </categories>
  </entry>
  <entry>
    <title>luogu - 3556</title>
    <url>/ZLY201.github.io/2020/09/15/luogu%20-%203556/</url>
    <content><![CDATA[<h2 id="luogu-3556-POI2013-MOR-Tales-of-seafaring"><a href="#luogu-3556-POI2013-MOR-Tales-of-seafaring" class="headerlink" title="luogu - 3556 [POI2013]MOR-Tales of seafaring"></a><a href="https://www.luogu.com.cn/problem/P3556" target="_blank" rel="noopener">luogu - 3556 [POI2013]MOR-Tales of seafaring</a></h2><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>给定无向图$G=(V,E)$，$|V|=n$，$|E|=m$，有$k$个询问，问你$x$和$y$之间有没有长度为$d$的路径</p>
<h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>$2\leq n \leq 5000$</p>
<p>$1 \leq m \leq 5000$</p>
<p>$1 \leq d \leq 1e^9$</p>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>既然是无向图，那么我们可以在某条边上来回走，那么我们只用处理处$x$到$y$的奇数最短路和偶数最短路即可，但是$k$的范围过大，如果对于每一次询问都进行一次$bfs$显然会超时，由于$n$只有$5000$，则说明$k$次询问中有很多重复的节点，我们考虑使用二维数组记录已经处理过的节点，避免重复运算</p>
<p>注意：</p>
<ol>
<li>二维数组要是用$short$而不能使用$int$类型，否则会超出内存</li>
<li>要判断$x = y$的情况，有可能是孤立点，那么就不存在长度为$2$的路径</li>
<li>要判断$x$与$y$不连通的情况</li>
<li>本题卡常数，要开O2优化</li>
</ol>
<h3 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h3><div><div class="fold_hider"><div class="close hider_title"></div></div><div class="fold">
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(2)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">5001</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v[maxn];</span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"><span class="keyword">bool</span> check[maxn];</span><br><span class="line">short dis[maxn][maxn][<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">register</span> <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">register</span> <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; que;</span><br><span class="line">    que.push(s);</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="literal">false</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">    dis[s][s][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!que.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = que.front();</span><br><span class="line">        que.pop();</span><br><span class="line">        vis[u] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> len = v[u].size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(dis[s][v[u][i]][<span class="number">1</span>] &gt; dis[s][u][<span class="number">0</span>] + <span class="number">1</span>) &#123;</span><br><span class="line">                dis[s][v[u][i]][<span class="number">1</span>] = dis[s][u][<span class="number">0</span>] + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(!vis[v[u][i]]) &#123;</span><br><span class="line">                    que.push(v[u][i]);</span><br><span class="line">                    vis[v[u][i]] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(dis[s][v[u][i]][<span class="number">0</span>] &gt; dis[s][u][<span class="number">1</span>] + <span class="number">1</span>) &#123;</span><br><span class="line">                dis[s][v[u][i]][<span class="number">0</span>] = dis[s][u][<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(!vis[v[u][i]]) &#123;</span><br><span class="line">                    que.push(v[u][i]);</span><br><span class="line">                    vis[v[u][i]] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>), <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">int</span> n, m, k;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">register</span> <span class="keyword">int</span> x, y;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        v[x].push_back(y);</span><br><span class="line">        v[y].push_back(x);</span><br><span class="line">    &#125;</span><br><span class="line">    fill(dis[<span class="number">0</span>][<span class="number">0</span>], dis[<span class="number">0</span>][<span class="number">0</span>] + maxn * maxn * <span class="number">2</span>, <span class="number">32767</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> x, y, z;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y &gt;&gt; z;</span><br><span class="line">        <span class="keyword">if</span>(!check[x]) &#123;</span><br><span class="line">            bfs(x);</span><br><span class="line">            check[x] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(x == y) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!z) <span class="built_in">cout</span> &lt;&lt; <span class="string">"TAK"</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(z % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(v[x].size()) <span class="built_in">cout</span> &lt;&lt; <span class="string">"TAK"</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">"NIE"</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(dis[x][y][<span class="number">1</span>] != <span class="number">32767</span> &amp;&amp; z &gt;= dis[x][y][<span class="number">1</span>]) <span class="built_in">cout</span> &lt;&lt; <span class="string">"TAK"</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">"NIE"</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(dis[x][y][<span class="number">0</span>] != <span class="number">32767</span> &amp;&amp; z &gt;= dis[x][y][<span class="number">0</span>] &amp;&amp; z % <span class="number">2</span> == dis[x][y][<span class="number">0</span>] % <span class="number">2</span>) <span class="built_in">cout</span> &lt;&lt; <span class="string">"TAK"</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(dis[x][y][<span class="number">1</span>] != <span class="number">32767</span> &amp;&amp; z &gt;= dis[x][y][<span class="number">1</span>] &amp;&amp; z % <span class="number">2</span> == dis[x][y][<span class="number">1</span>] % <span class="number">2</span>) <span class="built_in">cout</span> &lt;&lt; <span class="string">"TAK"</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">"NIE"</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>洛谷</tag>
        <tag>奇偶最短路</tag>
        <tag>O2优化</tag>
      </tags>
  </entry>
  <entry>
    <title>ACM博弈论基础</title>
    <url>/ZLY201.github.io/2020/07/23/%E5%8D%9A%E5%BC%88%E8%AE%BA/</url>
    <content><![CDATA[<h1 id="博弈论基础"><a href="#博弈论基础" class="headerlink" title="博弈论基础"></a>博弈论基础</h1><p>博弈场景一般均满足以下条件：</p>
<ol>
<li>有两名选手参与博弈</li>
<li>每名选手交替进行操作</li>
<li>操作必须满足一定条件，即操作合法</li>
<li>游戏结束的条件为某一方选手无法对于有限资源进行合法操作</li>
</ol>
<p>对于任何一种情况，我们定义P-position和N-position，其中P代表Previous，N代表Next。直观的说，上一次操作的人有必胜策略的局面是P-position，也就是“先手必败”，现在轮到操作的人有必胜策略的局面是N-position，也就是“先手可保证必胜”，简单来说，P/N状态可以表述为以下三条：</p>
<ol>
<li>无法进行任何移动的局面是P-position</li>
<li>可以移动到P-position的局面是N-position</li>
<li>所有移动都导致N-position的局面是P-position</li>
</ol>
<p>对于P/N状态有如下性质：</p>
<ol>
<li>若面临末状态者为获胜则末状态为胜态否则末状态为必败态</li>
<li>一个局面是胜态的充要条件是该局面进行某种决策后会成为必败态</li>
<li>一个局面是必败态的充要条件是该局面无论进行何种决策均会成为胜态</li>
</ol>
<p>简单来说，就是在N状态至少存在一种状态可以进入P状态，而P状态无论如何操作只能进入N状态</p>
<p>在进行博弈推导时，一定要牢记以上几条性质，否则一定会出错</p>
<h1 id="经典博弈"><a href="#经典博弈" class="headerlink" title="经典博弈"></a>经典博弈</h1><h2 id="巴什博奕"><a href="#巴什博奕" class="headerlink" title="巴什博奕"></a>巴什博奕</h2><p>一堆有$n$个物品，两个人轮流从中取出$1 - m$个，取光者胜，问你先手必胜态</p>
<p>结论：$n \equiv {0} \pmod {m + 1}$时先手必败，反之先手必胜</p>
<p>证明：<br>若$n \equiv {0} \pmod {m + 1}$，则$n = k \times (m + 1)$，假设先手取$k$，那么只要后手取走$m + 1 - k$个先手必败<br>否则若$n = k \times (m + 1) + s(s &lt; m + 1)$，那么先手只要取走$s$个则必胜</p>
<h3 id="例题：Brave-Game-HDU-1846"><a href="#例题：Brave-Game-HDU-1846" class="headerlink" title="例题：Brave Game HDU - 1846"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1846" target="_blank" rel="noopener">例题：Brave Game HDU - 1846</a></h3><h4 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h4><div><div class="fold_hider"><div class="close hider_title"></div></div><div class="fold">
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> T, n, m;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">	<span class="keyword">while</span> (T--) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">		<span class="keyword">if</span> (n % (m + <span class="number">1</span>) == <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">"second\n"</span>);</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"first\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></div>
<h2 id="完全版巴什博奕"><a href="#完全版巴什博奕" class="headerlink" title="完全版巴什博奕"></a>完全版巴什博奕</h2><p>一堆有$n$个物品，两个人轮流从中取出$p - q$个，取光者胜，问你先手必胜态</p>
<p>结论：$0 &lt; n \bmod (p + q) &lt; p$时先手必胜，否则先手必败</p>
<p>证明：假设$n = m \times (p + q) + s(0 \leq s &lt; p+q)$，若$0 &lt; s &lt; p$，那么假设先手取$k$，那么后手只要取$p+q-k$，最后一定会剩下$s$，先手必胜<br>否则若$s==0||s&gt;=p$，假设先手取$k$，那么此时$n=m \times (p + q) + s - k$，转换成了后手当先手的情况，原先手必败</p>
<h3 id="例题：邂逅明下-HDU-2897"><a href="#例题：邂逅明下-HDU-2897" class="headerlink" title="例题：邂逅明下 HDU - 2897"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=2897" target="_blank" rel="noopener">例题：邂逅明下 HDU - 2897</a></h3><h4 id="AC代码-1"><a href="#AC代码-1" class="headerlink" title="AC代码"></a>AC代码</h4><div><div class="fold_hider"><div class="close hider_title"></div></div><div class="fold">
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">cin</span>.tie(<span class="number">0</span>), <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">int</span> n, p, q;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; p &gt;&gt; q) &#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; ((n % (p + q) == <span class="number">0</span> || n % (p + q) &gt; p) ? <span class="string">"WIN"</span> : <span class="string">"LOST"</span>) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></div>
<h2 id="威佐夫博弈"><a href="#威佐夫博弈" class="headerlink" title="威佐夫博弈"></a>威佐夫博弈</h2><p>有两堆物品，两人轮流从一堆中取出至少一个物品或者从两堆中取出相同数量的物品，取光者胜，问先手必胜态</p>
<p>结论：必输局势为$(0, 0),(1, 2),(3, 5),(4, 7),…,(a_{k}, b_{k})$，其中$a_{k} = [\frac{\sqrt{5} + 1}{2} \times (b_{k} - a_{k})]$</p>
<h3 id="例题：取石子游戏-HDU-1527"><a href="#例题：取石子游戏-HDU-1527" class="headerlink" title="例题：取石子游戏 HDU - 1527"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1527" target="_blank" rel="noopener">例题：取石子游戏 HDU - 1527</a></h3><h4 id="AC代码-2"><a href="#AC代码-2" class="headerlink" title="AC代码"></a>AC代码</h4><div><div class="fold_hider"><div class="close hider_title"></div></div><div class="fold">
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> rate = (<span class="built_in">sqrt</span>(<span class="number">5</span>) + <span class="number">1.0</span>) / <span class="number">2.0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">cin</span>.tie(<span class="number">0</span>), <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">int</span> a, b;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b) &#123;</span><br><span class="line">		<span class="keyword">if</span> (a &gt; b) swap(a, b);</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; (a == (<span class="keyword">int</span>(rate * (b - a) * <span class="number">1.0</span>)) ? <span class="number">0</span> : <span class="number">1</span>) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></div>
<h2 id="斐波那契博弈"><a href="#斐波那契博弈" class="headerlink" title="斐波那契博弈"></a>斐波那契博弈</h2><p>有一堆物品，两个人轮流取，先手可以取任意个，但是不能取完，之后每一次取出物品的数量不能超过上一次的两倍，取完者胜，问先手必胜态</p>
<p>结论：当物品总数量为斐波那契数时先手必败，否则先手必胜</p>
<p>证明：<a href="https://blog.csdn.net/acm_cxlove/article/details/7835016" target="_blank" rel="noopener">https://blog.csdn.net/acm_cxlove/article/details/7835016</a></p>
<h3 id="例题：取石子游戏-HDU-2516"><a href="#例题：取石子游戏-HDU-2516" class="headerlink" title="例题：取石子游戏 HDU - 2516"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=2516" target="_blank" rel="noopener">例题：取石子游戏 HDU - 2516</a></h3><h4 id="AC代码-3"><a href="#AC代码-3" class="headerlink" title="AC代码"></a>AC代码</h4><div><div class="fold_hider"><div class="close hider_title"></div></div><div class="fold">
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> F[<span class="number">110</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">cin</span>.tie(<span class="number">0</span>), <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">	F[<span class="number">0</span>] = F[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= <span class="number">100</span>; ++i) &#123;</span><br><span class="line">		F[i] = F[i - <span class="number">1</span>] + F[i - <span class="number">2</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!n) <span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">100</span>; ++i) &#123;</span><br><span class="line">			<span class="keyword">if</span> (F[i] == n) flag = <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; (flag ? <span class="string">"Second win"</span> : <span class="string">"First win"</span>) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></div>
<h2 id="尼姆博奕"><a href="#尼姆博奕" class="headerlink" title="尼姆博奕"></a>尼姆博奕</h2><p>有$n$堆物品，两人轮流取，每次取任意一堆中至少一个，取完者胜，问先手必胜态</p>
<p>结论：当$n$堆物品的数量异或和为$0$时先手必败，否则先手必胜</p>
<p>证明：<a href="https://blog.csdn.net/k_koris/article/details/81743806" target="_blank" rel="noopener">https://blog.csdn.net/k_koris/article/details/81743806</a></p>
<h3 id="例题：Being-a-Good-Boy-in-Spring-Festival-HDU-1850"><a href="#例题：Being-a-Good-Boy-in-Spring-Festival-HDU-1850" class="headerlink" title="例题：Being a Good Boy in Spring Festival HDU - 1850"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1850" target="_blank" rel="noopener">例题：Being a Good Boy in Spring Festival HDU - 1850</a></h3><h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>这题比较特别的是他问的并不是必胜或必败，而是问你先手第一次操作的方法数目，需要用到异或运算的性质，即$a \oplus a = 0$，且异或运算满足交换律，那么我们先处理出总的异或和$sum=a_{1} \oplus a_{2} \oplus … \oplus a_{n}$，然后分别与$a_{i}$进行异或，则$sum’=a_{1} \oplus a_{2} \oplus … \oplus a_{n} \oplus a_{i}$，那么$sum’$即表示与$a_{i}$异或前的状态，若$a[i] &gt; sum’$，那么我们通过可以减少$a_{i}$的值使得$sum=0$，即将其变为必胜态</p>
<h4 id="AC代码-4"><a href="#AC代码-4" class="headerlink" title="AC代码"></a>AC代码</h4><div><div class="fold_hider"><div class="close hider_title"></div></div><div class="fold">
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">110</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">cin</span>.tie(<span class="number">0</span>), <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!n) <span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">			sum ^= a[i];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">			<span class="keyword">if</span> ((sum ^ a[i]) &lt; a[i]) ++res;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></div>
<h2 id="阶梯博弈"><a href="#阶梯博弈" class="headerlink" title="阶梯博弈"></a>阶梯博弈</h2><p>有$n$个阶梯，每个阶梯上放若干物品，两个人轮流将一个阶梯上的任意数量物品移至前一个台阶，最后移动者胜，问先手必胜态（最终状态为所有物品在地面上，即$0$号台阶）</p>
<p>结论：若奇数号台阶上的物品数量异或和为0则先手必败，否则先手必胜</p>
<p>证明：假设对手移动了奇数号台阶，那么按照尼姆博奕的方法移动即可，否则若对手移动的数偶数号台阶$2i$，那么我们将相等数量的物品从$2i-1$移动到$2i-2$即可，那么最后奇数号台阶上就不会有物品存在了，需要从最后一个偶数号台阶开始向下移动</p>
<h3 id="例题：Game-HDU-3389"><a href="#例题：Game-HDU-3389" class="headerlink" title="例题：Game HDU - 3389"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=3389" target="_blank" rel="noopener">例题：Game HDU - 3389</a></h3><h4 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h4><p>这题是阶梯博弈的变形版，我们考虑满足$n % 2 == 1,n % 3==0$等同于满足$n % 6 == 3$，那么$A$和$B$一定为一下几种情况<br>$(A \bmod 6 = 0) + (B \bmod 6 = 3) = 6 \qquad (A \bmod 6 = 3) + (B \bmod 6 = 0) = 6$<br>$(A \bmod 6 = 1) + (B \bmod 6 = 2) = 6 \qquad (A \bmod 6 = 2) + (B \bmod 6 = 1) = 6$<br>$(A \bmod 6 = 4) + (B \bmod 6 = 5) = 6 \qquad (A \bmod 6 = 5) + (B \bmod 6 = 4) = 6$<br>又因为$A &gt; B$，我们将下标$1-6$模$6$，得到$1,2,3,4,5,0$，可以发现移动规则如下：$0-3,2-1,5-4$，我们将$1,3,4$看做偶数台阶，将$0,2,5$看做奇数台阶进行阶梯博弈即可</p>
<h4 id="AC代码-5"><a href="#AC代码-5" class="headerlink" title="AC代码"></a>AC代码</h4><div><div class="fold_hider"><div class="close hider_title"></div></div><div class="fold">
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> T;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">	<span class="keyword">int</span> cas = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (T--) &#123;</span><br><span class="line">		<span class="keyword">int</span> n;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">		<span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">			<span class="keyword">int</span> x;</span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">			<span class="keyword">if</span> (i % <span class="number">6</span> == <span class="number">0</span> || i % <span class="number">6</span> == <span class="number">2</span> || i % <span class="number">6</span> == <span class="number">5</span>) sum ^= x;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Case %d: %s\n"</span>, ++cas, (sum ? <span class="string">"Alice"</span> : <span class="string">"Bob"</span>));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></div>
<p><br/></p>
<h1 id="SG函数"><a href="#SG函数" class="headerlink" title="SG函数"></a>SG函数</h1><h2 id="问题引入"><a href="#问题引入" class="headerlink" title="问题引入"></a>问题引入</h2><p>对于经典Nim博弈，我们可以通过经验或结论来解决，但是对于一般Nim的博弈，我们显然需要用到更一般的方法进行推导，在博弈论中，一个常用的方法就是$SG$函数。</p>
<h2 id="SG函数简介"><a href="#SG函数简介" class="headerlink" title="SG函数简介"></a>SG函数简介</h2><p>首先我们定义$mex$运算，该运算表示不属于指定集合的最小非负整数，如$mex\{0, 1, 2, 4\} = 3, mex\{1, 3, 5\}=0$</p>
<p>其次我们定义函数$SG$，对于一个给定的有向无环图，对于顶点$x$，$SG(x)=mex\{SG(y)|y为x的后继\}$</p>
<p>那么我们假设顶点$x$为必败点$P$，那么根据其性质可知，$P$状态无论如何都只能进入$N$状态，即当且仅当$SG(x)=0$时其为必败态，因为从$x$任意移动都可进入必胜态$SG(y)&gt;0$</p>
<p>对于类尼姆博弈，先手必败态为$SG(1) \oplus SG(2) \oplus SG(3) \oplus … \oplus SG(n) = 0$，否则先手必胜，特别的对于尼姆博弈$SG(x)=x$</p>
<h3 id="例题：Nim-or-not-Nim-HDU-3032"><a href="#例题：Nim-or-not-Nim-HDU-3032" class="headerlink" title="例题：Nim or not Nim? HDU - 3032"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=3032" target="_blank" rel="noopener">例题：Nim or not Nim? HDU - 3032</a></h3><h4 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h4><p>先打表找到$SG$函数的规律，然后对每一堆物品的$SG$函数求异或和即可</p>
<h4 id="AC代码-6"><a href="#AC代码-6" class="headerlink" title="AC代码"></a>AC代码</h4><div><div class="fold_hider"><div class="close hider_title"></div></div><div class="fold">
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line"><span class="keyword">int</span> sg[maxn];</span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SG</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; x; ++i) &#123;</span><br><span class="line">		vis[sg[i]] = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; x; ++i) &#123;</span><br><span class="line">		vis[sg[i] ^ sg[x - i]] = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">1000</span>; ++i) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!vis[i]) <span class="keyword">return</span> sg[x] = i;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">cin</span>.tie(<span class="number">0</span>), <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">int</span> T;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">	<span class="comment">//sg[0] = 0, sg[1] = 1;</span></span><br><span class="line">	<span class="comment">//for (int i = 2; i &lt;= 1000; ++i) cout &lt;&lt; i &lt;&lt; " " &lt;&lt; SG(i) &lt;&lt; '\n';</span></span><br><span class="line">	<span class="keyword">while</span> (T--) &#123;</span><br><span class="line">		<span class="keyword">int</span> n;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">		<span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">			<span class="keyword">if</span> (a[i] % <span class="number">4</span> == <span class="number">0</span>) sum ^= (a[i] - <span class="number">1</span>);</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (a[i] % <span class="number">4</span> == <span class="number">3</span>) sum ^= (a[i] + <span class="number">1</span>);</span><br><span class="line">			<span class="keyword">else</span> sum ^= a[i];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; (sum ? <span class="string">"Alice"</span> : <span class="string">"Bob"</span>) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></div>
<p><br/></p>
<h1 id="编写参考"><a href="#编写参考" class="headerlink" title="编写参考"></a>编写参考</h1><ol>
<li>ACM博弈论基础 by Rogn<br><a href="https://www.cnblogs.com/lfri/p/10662291.html" target="_blank" rel="noopener">https://www.cnblogs.com/lfri/p/10662291.html</a></li>
<li>acm博弈论 by 111qqz<br><a href="https://www.cnblogs.com/111qqz/articles/4829996.html" target="_blank" rel="noopener">https://www.cnblogs.com/111qqz/articles/4829996.html</a></li>
<li>博弈论 （PN图) by 相思明月楼<br><a href="https://blog.csdn.net/Adusts/article/details/81385588" target="_blank" rel="noopener">https://blog.csdn.net/Adusts/article/details/81385588</a></li>
<li>阶梯博弈详解 by forezxl<br><a href="https://blog.csdn.net/a1799342217/article/details/78265265" target="_blank" rel="noopener">https://blog.csdn.net/a1799342217/article/details/78265265</a></li>
<li>HDU - 2897 - 邂逅明下 by 明镜止水<br><a href="https://www.cnblogs.com/sineatos/p/3888898.html" target="_blank" rel="noopener">https://www.cnblogs.com/sineatos/p/3888898.html</a></li>
<li>（组合游戏）SG函数与SG定理详解 by bestsort<br><a href="https://blog.csdn.net/bestsort/article/details/88197959" target="_blank" rel="noopener">https://blog.csdn.net/bestsort/article/details/88197959</a></li>
<li>百度百科 - SG函数<br><a href="https://baike.baidu.com/item/SG%E5%87%BD%E6%95%B0/1004609?fr=aladdin#3" target="_blank" rel="noopener">https://baike.baidu.com/item/SG%E5%87%BD%E6%95%B0/1004609?fr=aladdin#3</a></li>
</ol>
]]></content>
      <categories>
        <category>博弈论</category>
      </categories>
      <tags>
        <tag>博弈论</tag>
        <tag>巴什博奕</tag>
        <tag>威佐夫博弈</tag>
        <tag>斐波那契博弈</tag>
        <tag>尼姆博奕</tag>
        <tag>SG函数</tag>
      </tags>
  </entry>
  <entry>
    <title>唯一分解定理</title>
    <url>/ZLY201.github.io/2020/07/05/%E5%94%AF%E4%B8%80%E5%88%86%E8%A7%A3%E5%AE%9A%E7%90%86/</url>
    <content><![CDATA[<h2 id="唯一分解定理"><a href="#唯一分解定理" class="headerlink" title="唯一分解定理"></a>唯一分解定理</h2><p>根据欧拉定理，一个数n可以被写成如下格式</p>
<p>$n = p_{1}^{a_{1}}p_{2}^{a_{2}}p_{3}^{a_{3}}…p_{k}^{a_{k}}$</p>
<p>其中$p_{i}$为n的质因子</p>
<p>那么有如下结论</p>
<ol>
<li>设$F(n)$代表n的正因子数目，则$F(n) = (a_{1}+ 1)(a_{2} + 1)(a_{3} + 1)…(a_{n} + 1)$</li>
<li>设$G(n)$代表n的正因子之和，则<br>$G(n) = (1 + p_{1} + p_{1}^{2}+…+p_{1}^{a_{1}})(1 + p_{2} + p_{2}^{2}+…+p_{2}^{a_{2}})…(1 + p_{k} + p_{2}^{3}+…+p_{k}^{a_{k}})=\prod_{i=1}^{n}(\frac{p_{i}^{a_{i} + 1}-1}{p_{i}-1})$</li>
</ol>
<h2 id="例题：Trailing-Zeroes-I-LightOJ-1028"><a href="#例题：Trailing-Zeroes-I-LightOJ-1028" class="headerlink" title="例题：Trailing Zeroes (I) LightOJ - 1028"></a>例题：<a href="http://http://lightoj.com/volume_showproblem.php?problem=1028" target="_blank" rel="noopener">Trailing Zeroes (I) LightOJ - 1028</a></h2><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>有多组输入，每次给你一个正整数n，问你n的除1之外的正因子数目</p>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>因为有多组输入，那么如果对于每一个n进行暴力统计显然会超时，可以先预处理出$10^{6}$以内的质数，然后对n进行质数分解，使用公式1进行求解</p>
<h3 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h3><div><div class="fold_hider"><div class="close hider_title"></div></div><div class="fold">
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line"><span class="keyword">bool</span> check[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; maxn; ++i) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!check[i]) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = (i &lt;&lt; <span class="number">1</span>); j &lt; maxn; j += i) &#123;</span><br><span class="line">				check[j] = <span class="literal">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			v.push_back(i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">eulor</span><span class="params">(ll n)</span> </span>&#123;</span><br><span class="line">	ll res = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> len = v.size();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; ll(v[i]) * v[i] &lt;= n &amp;&amp; i &lt; len; ++i) &#123;</span><br><span class="line">		<span class="keyword">if</span> (n % v[i] == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">while</span> (n % v[i] == <span class="number">0</span>) &#123;</span><br><span class="line">				n /= v[i];</span><br><span class="line">				++cnt;</span><br><span class="line">			&#125;</span><br><span class="line">			res *= (cnt + <span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (n &gt; <span class="number">1</span>) res *= <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">return</span> res - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> T;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">	<span class="keyword">int</span> cas = <span class="number">0</span>;</span><br><span class="line">	prime();</span><br><span class="line">	<span class="keyword">while</span> (T--) &#123;</span><br><span class="line">		ll n;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;n);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Case %d: %lld\n"</span>, ++cas, eulor(n));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></div>]]></content>
      <categories>
        <category>数论</category>
      </categories>
      <tags>
        <tag>唯一分解定理</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>luogu - 1967</title>
    <url>/ZLY201.github.io/2020/08/23/luogu%20-%201967/</url>
    <content><![CDATA[<h2 id="luogu-1967-货车运输"><a href="#luogu-1967-货车运输" class="headerlink" title="luogu - 1967 货车运输"></a><a href="https://www.luogu.com.cn/problem/P1967" target="_blank" rel="noopener">luogu - 1967 货车运输</a></h2><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>有$n$个城市，$m$条双向道路，每一条道路有限重，现在有$q$辆货车分别向$u_{i}$城市送货到$v_{i}$城市，问你在不超过限重的情况下每辆车能运送货物的最大重量是多少</p>
<p>其中$1 \leq n &lt; 10^{4}$，$1 \leq m &lt; 5 \times 10^{4}$，$1 \leq q &lt; 3 \times 10^{4}$</p>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>首先很容易想到暴力的$Floyd$，转移方程也非常容易想到，即：</p>
<script type="math/tex; mode=display">
G[i][j] = max(G[i][j], min(G[i][k], G[k][j]))</script><p>但是该算法时间复杂度$O(n^3)$，空间复杂度$O(n^2)$，显然不能满足要求，考虑优化。</p>
<p>模拟发现，如果$u_{i}$到$v_{i}$有多条道路，那么我们肯定会选择限重最大的那条路，并且不会去走边权小的道路，于是我们可以处理图中的最大生成树，这样就可以保证任意两个节点间的路径为最大。</p>
<p>其次，由于树上的任意两节点路径唯一，我们可以使用$LCA$来求得任意两节点间的路径。</p>
<p>总时间复杂度$O(mlog_{2}^{m}+(n + q)log_{2}^{n})$，空间复杂度$O(m+nlog_{2}^{n})$</p>
<h3 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h3><div><div class="fold_hider"><div class="close hider_title"></div></div><div class="fold">
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> u, v, w;</span><br><span class="line">    Edge() &#123; u = v = w = <span class="number">0</span>; &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Edge&amp; obj)<span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> w &gt; obj.w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;edge[maxn];</span><br><span class="line"><span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; v[maxn];</span><br><span class="line"><span class="keyword">int</span> pre[maxn], fa[maxn][<span class="number">25</span>], w[maxn][<span class="number">25</span>];</span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"><span class="keyword">int</span> deep[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    vis[u] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">int</span> len = v[u].size();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(vis[v[u][i].first]) <span class="keyword">continue</span>;</span><br><span class="line">        deep[v[u][i].first] = deep[u] + <span class="number">1</span>;</span><br><span class="line">        fa[v[u][i].first][<span class="number">0</span>] = u;</span><br><span class="line">        w[v[u][i].first][<span class="number">0</span>] = v[u][i].second;</span><br><span class="line">        dfs(v[u][i].first);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> pre[x] == x ? x : pre[x] = find(pre[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(find(u) != find(v)) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> res = INF;</span><br><span class="line">    <span class="keyword">if</span>(deep[u] &gt; deep[v]) swap(u, v);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">20</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(deep[fa[v][i]] &gt;= deep[u]) &#123;</span><br><span class="line">            res = min(res, w[v][i]);</span><br><span class="line">            v = fa[v][i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(u == v) <span class="keyword">return</span> res;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">20</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(fa[u][i] != fa[v][i]) &#123;</span><br><span class="line">            res = min(res, min(w[u][i], w[v][i]));</span><br><span class="line">            u = fa[u][i];</span><br><span class="line">            v = fa[v][i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    res = min(res, min(w[u][<span class="number">0</span>], w[v][<span class="number">0</span>]));</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>), <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) pre[i] = i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; edge[i].u &gt;&gt; edge[i].v &gt;&gt; edge[i].w;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(edge + <span class="number">1</span>, edge + m + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> fu = find(edge[i].u);</span><br><span class="line">        <span class="keyword">int</span> fv = find(edge[i].v);</span><br><span class="line">        <span class="keyword">if</span>(fu == fv) <span class="keyword">continue</span>;</span><br><span class="line">        pre[fv] = fu;</span><br><span class="line">        v[edge[i].u].push_back(make_pair(edge[i].v, edge[i].w));</span><br><span class="line">        v[edge[i].v].push_back(make_pair(edge[i].u, edge[i].w));</span><br><span class="line">        ++cnt;</span><br><span class="line">        <span class="keyword">if</span>(cnt &gt;= m - <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(vis[i]) <span class="keyword">continue</span>;</span><br><span class="line">        deep[i] = <span class="number">1</span>;</span><br><span class="line">        dfs(i);</span><br><span class="line">        fa[i][<span class="number">0</span>] = i;</span><br><span class="line">        w[i][<span class="number">0</span>] = INF;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">20</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">            fa[j][i] = fa[fa[j][i - <span class="number">1</span>]][i - <span class="number">1</span>];</span><br><span class="line">            w[j][i] = min(w[j][i - <span class="number">1</span>], w[fa[j][i - <span class="number">1</span>]][i - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> q;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; q;</span><br><span class="line">    <span class="keyword">while</span>(q--) &#123;</span><br><span class="line">        <span class="keyword">int</span> u, v;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; lca(u, v) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>
]]></content>
      <categories>
        <category>图论</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>LCA</tag>
        <tag>生成树</tag>
      </tags>
  </entry>
  <entry>
    <title>对顶堆</title>
    <url>/ZLY201.github.io/2020/07/26/%E5%AF%B9%E9%A1%B6%E5%A0%86/</url>
    <content><![CDATA[<h2 id="对顶堆"><a href="#对顶堆" class="headerlink" title="对顶堆"></a>对顶堆</h2><h3 id="问题引入"><a href="#问题引入" class="headerlink" title="问题引入"></a>问题引入</h3><p>有$n$个人依次入队，每个人的身高不同，当第$i$个人入队时询问$1\sim i$中身高第$k$小的人是谁</p>
<p>显然有一个$O(n^2)$的暴力算法，我们先将$n$个人的身高进行排序，并记录他们的入队次序，然后每次$O(n)$遍历找到$id$小于$i$的第$k$个人即可，但是当数据范围超过$1e^{5}$时该算法在时间上显然不能满足要求</p>
<p>如果你足够细心，你会发现该问题的本质是求<strong>区间内的第$k$小</strong>，那么我们可以考虑优秀的主席树，时间复杂度$O(nlog_{2}^{n})$，时间上可以满足要求，但是主席树的空间消耗极高，我们想尝试找到一个既节约时间又节约空间的算法</p>
<p>有没有这样的算法存在呢？</p>
<p>答案是有的</p>
<h3 id="对顶堆概述"><a href="#对顶堆概述" class="headerlink" title="对顶堆概述"></a>对顶堆概述</h3><p>首先简单回顾一下什么是堆</p>
<p>堆分为大根堆和小根堆，堆的本质是一棵树，大根堆即树的根是这棵树上所有节点中最大的，并且任一节点的值大于其左右儿子节点，小根堆顾名思义，即为大根堆的相反结构</p>
<p>现在我定义一个大根堆$Max-Heap$，和一个小根堆$Min-Heap$，我们维护$Max-Heap$的大小为$k$，并且$Max-Heap$的堆顶元素小于或等于$Min-Heap$的堆顶元素，那么$Max-Heap$的堆顶即为所求区间中第$k$小的值</p>
<p>承接上例，我们现在要求$1\sim n$中的第$k$大，那么每当有人入队时，我们先将其放入$Max-Heap$中，假设放入之前其大小为$k-1$，那么现在其大小为$k$，我们将其堆顶元素取出，并放入$Min-Heap$中，然后将$Min-Heap$的堆顶元素取出并放入$Max-Heap$中，那么现在$Max-Heap$的堆顶即为所求的区间第$k$大，时间复杂度$O(nlog_{2}^{n})$，空间复杂度$O(n)$</p>
<h3 id="例题：Running-Median-POJ-3784"><a href="#例题：Running-Median-POJ-3784" class="headerlink" title="例题：Running Median POJ - 3784"></a><a href="http://poj.org/problem?id=3784" target="_blank" rel="noopener">例题：Running Median POJ - 3784</a></h3><h4 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h4><p>给你一个长度$n$的数组，$n$保证为奇数，让你输出$1\sim n$中所有下标$i$为奇数时$1\sim i$的中位数</p>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>显然就是让你求$1\sim i$中第$\frac{i+1}{2}$大的数，运用对顶堆实时处理即可</p>
<p>我们始终维护$Max-Heap$的堆顶元素为$1\sim i$中的中位数，那么$Max-Heap$的大小一定比$Min-Heap$大，并且正好大$1$，当$i$为偶数时，我们先将$a[i]$放入$Max-Heap$，然后取出$Max-Heap$的堆顶元素，并放入$Min-Heap$，这样，我们就保证了$Max-Heap$的堆顶为第$\frac{i}{2}$大的，当$i$为奇数时，我们将$a[i]$放入$Min-Heap$，然后将$Min-Heap$的堆顶元素取出并放入到$Max-Heap$中，这样，就保证了此时$Max-Heap$的堆顶为$1\sim i$中第$\frac{i+1}{2}$大的数</p>
<h4 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h4><div><div class="fold_hider"><div class="close hider_title"></div></div><div class="fold">
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">priority_queue&lt;<span class="keyword">long</span>, <span class="built_in">vector</span>&lt;<span class="keyword">long</span>&gt; &gt; max_que;</span><br><span class="line">priority_queue&lt;<span class="keyword">long</span>, <span class="built_in">vector</span>&lt;<span class="keyword">long</span>&gt;, greater&lt;<span class="keyword">long</span>&gt; &gt; min_que;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">cin</span>.tie(<span class="number">0</span>), <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">int</span> T; <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">	<span class="keyword">while</span>(T--) &#123;</span><br><span class="line">		<span class="keyword">int</span> cas; <span class="built_in">cin</span> &gt;&gt; cas;</span><br><span class="line">		<span class="keyword">int</span> n; <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; cas &lt;&lt; <span class="string">' '</span> &lt;&lt; (n + <span class="number">1</span>) / <span class="number">2</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">		<span class="keyword">while</span> (!max_que.empty()) max_que.pop();</span><br><span class="line">		<span class="keyword">while</span> (!min_que.empty()) min_que.pop();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">			<span class="keyword">long</span> x; <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">			<span class="keyword">if</span> ((i &amp; <span class="number">1</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">				max_que.push(x);</span><br><span class="line">				min_que.push(max_que.top());</span><br><span class="line">				max_que.pop();</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				min_que.push(x);</span><br><span class="line">				max_que.push(min_que.top());</span><br><span class="line">				min_que.pop();</span><br><span class="line">				<span class="built_in">cout</span> &lt;&lt; max_que.top() &lt;&lt; (((i + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>) % <span class="number">10</span> ? <span class="string">' '</span> : <span class="string">'\n'</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></div>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>POJ</tag>
        <tag>数据结构</tag>
        <tag>堆\优先队列</tag>
      </tags>
  </entry>
  <entry>
    <title>数论四大定理</title>
    <url>/ZLY201.github.io/2020/07/07/%E6%95%B0%E8%AE%BA%E5%9B%9B%E5%A4%A7%E5%AE%9A%E7%90%86/</url>
    <content><![CDATA[<h2 id="欧几里得算法"><a href="#欧几里得算法" class="headerlink" title="欧几里得算法"></a>欧几里得算法</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>欧几里德算法又称辗转相除法，是指用于计算两个正整数a，b的最大公约数。其公式为$gcd(a, b) = gcd(b, a \bmod b)$</p>
<h3 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h3><p>证明如下：<br>不妨设$a &gt; b$，$gcd(a, b)=n$<br>$a = k_{1}n$，$b = k_{2}n$<br>那么$a - b = (k_{1} - k_{2}) \times n$<br>易得$gcd(a, b) = gcd(b, a - b)=gcd(b, a - 2b)=…=gcd(b, a \bmod b)$</p>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><div><div class="fold_hider"><div class="close hider_title"></div></div><div class="fold">
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a, ll b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> b == <span class="number">0</span> ? a : gcd(b, a % b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></div>
<h2 id="拓展欧几里得算法"><a href="#拓展欧几里得算法" class="headerlink" title="拓展欧几里得算法"></a>拓展欧几里得算法</h2><h3 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h3><p>找到最小的$x$和$y$使得式子$ax + by = gcd(a, b)$成立</p>
<h3 id="求解"><a href="#求解" class="headerlink" title="求解"></a>求解</h3><p>不妨设$x &gt; y$<br>若有$ax + by = gcd(a, b)$<br>必有$bx_{1} + (a \bmod b)y_{1}=gcd(b, a \bmod b) = gcd(a, b)$<br>$bx_{1} + (a - [\frac{a}{b}] \times b)y_{1} = gcd(a, b)$<br>$bx_{1} + ay_{1} - [\frac{a}{b}] \times b \times y = gcd(a, b)$<br>$ay_{1} + (x_{1} - [\frac{a}{b}] \times y_{1})b=gcd(a, b)=ax+by$<br>那么显然存在解$x = y_{1}, y = x_{1} - [\frac{a}{b}] \times y_{1}$</p>
<p>这样就可以对式子进行递归求解了，边界条件为$b = 0$时$x_{k}=1, y_{k}=0$</p>
<p>如果你不希望解出现负数的话，可以使用下面的式子进行处理<br>$x = (x + b) \bmod b \qquad y = (y + a) \bmod a$</p>
<h3 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h3><div><div class="fold_hider"><div class="close hider_title"></div></div><div class="fold">
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">pair&lt;ll, ll&gt; exgcd(ll a, ll b) &#123;</span><br><span class="line">	<span class="keyword">if</span> (!b) <span class="keyword">return</span> pair&lt;ll, ll&gt;(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">	pair&lt;ll, ll&gt; temp = exgcd(b, a % b);</span><br><span class="line">	<span class="keyword">return</span> pair&lt;ll, ll&gt;(temp.second, temp.first - a / b * temp.second);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></div>
<h3 id="拓展1"><a href="#拓展1" class="headerlink" title="拓展1"></a>拓展1</h3><p>找到最小的$x$和$y$使得式子$ax + by = c$成立<br>不妨设$gcd(a, b)=n$<br>$a = k_{1}n$，$b = k_{2}n$<br>那么上式即为$k_{1}n \times x + k_{2}n \times y = c$<br>很显然上式有解的充要条件为$n|c$</p>
<p>我们考虑$ax + by = gcd(a, b)$的最小解为$x和y$<br>那么$\frac{c}{gcd(a, b)} \times (ax + by) = \frac{c}{gcd(a, b)} \times gcd(a, b)$<br>令$x’ = \frac{c}{gcd(a, b)} \times x$，$y’ = \frac{c}{gcd(a, b)} \times y$<br>显然$x’$和$y’$为$ax + by = c$的最小解</p>
<h3 id="拓展2"><a href="#拓展2" class="headerlink" title="拓展2"></a>拓展2</h3><p>若$ab + kp = 1$，即$a \times b \equiv 1 \pmod p$，那么根据拓展欧几里得算法求解出来的$b$即为$a$在模$p$意义下的乘法逆元</p>
<h2 id="中国剩余定理"><a href="#中国剩余定理" class="headerlink" title="中国剩余定理"></a>中国剩余定理</h2><h3 id="描述-2"><a href="#描述-2" class="headerlink" title="描述"></a>描述</h3><p>中国剩余定理又称孙子定理，中国南北朝时期（公元5世纪）的数学著作《孙子算经》卷下第二十六题，叫做“物不知数”问题，原文如下：</p>
<blockquote>
<p>“今有物不知其数，三三数之剩二，五五数之剩三，七七数之剩二，问物几何？”</p>
</blockquote>
<p>意思就是有一个数除3余2，除5余3，除7余2，问你这个数是多少</p>
<p>这类问题在数论中我们把它称作一元线性同余方程组问题，数学公式表述如下：<br>$x \equiv {a_{1}} \pmod {m_{1}}$<br>$x \equiv {a_{2}} \pmod {m_{2}}$<br>$…$<br>$x \equiv {a_{n}} \pmod {m_{n}}$<br>其中$m_{1}, m_{2}, …, m_{n}两两互质$<br>求x的最小非负整数解</p>
<h3 id="求解-1"><a href="#求解-1" class="headerlink" title="求解"></a>求解</h3><p>令$M=\prod_{i=1}^{n}m_{i}$，即$M=lcm(m_{1}, m_{2}, …, m_{n})$<br>设$t_{i}$为$\frac{M}{m_{i}}t_{i} \equiv {1} \pmod {m_{i}}$的最小非负整数解<br>那么$x = \sum_{i=1}^{n}a_{i}\frac{M}{m_{i}}t_{i}$为同余方程组的最小非负整数解<br>而$t_{i}$显然为$\frac{M}{m_{i}}$在模$m_{i}$意义下的乘法逆元（因为$\frac{M}{m_{i}}t_{i} \equiv {1} \pmod {m_{i}}$）</p>
<h3 id="证明-1"><a href="#证明-1" class="headerlink" title="证明"></a>证明</h3><p>将$x = \sum_{i=1}^{n}a_{i}\frac{M}{m_{i}}t_{i}$带入到第$k$个方程中<br>对于$\forall i \neq k$，$a_{i}\frac{M}{m_{i}}t_{i} \equiv {0} \pmod {m_{k}}$，因为$\frac{M}{m_{i}} \bmod m_{k} = 0$<br>对于$i = k$，由于$\frac{M}{m_{i}}t_{i} \equiv {1} \pmod {m_{k}}$，那么自然$a_{i}\frac{M}{m_{i}}t_{i} \equiv {a_{i}} \pmod {m_{k}}$，即得证</p>
<h3 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h3><div><div class="fold_hider"><div class="close hider_title"></div></div><div class="fold">
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">pair&lt;ll, ll&gt; exgcd(ll a, ll b) &#123;</span><br><span class="line">	<span class="keyword">if</span> (!b) <span class="keyword">return</span> pair&lt;ll, ll&gt;(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">	pair&lt;ll, ll&gt; temp = exgcd(b, a % b);</span><br><span class="line">	<span class="keyword">return</span> pair&lt;ll, ll&gt;(temp.second, temp.first - a / b * temp.second);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">CRT</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	ll M = <span class="number">1</span>, res = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) M *= m[i];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">		ll tmp = M / m[i];</span><br><span class="line">		pair&lt;ll, ll&gt; pp = exgcd(tmp, m[i]);</span><br><span class="line">		res = (res + a[i] * pp.first % M * tmp % M) % M;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> (res + M) % M;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></div>
<h2 id="拓展中国剩余定理"><a href="#拓展中国剩余定理" class="headerlink" title="拓展中国剩余定理"></a>拓展中国剩余定理</h2><h3 id="描述-3"><a href="#描述-3" class="headerlink" title="描述"></a>描述</h3><p>$x \equiv {a_{1}} \pmod {m_{1}}$<br>$x \equiv {a_{2}} \pmod {m_{2}}$<br>$…$<br>$x \equiv {a_{n}} \pmod {m_{n}}$<br>不保证$m_{1}, m_{2}, …, m_{n}两两互质$<br>求x的最小非负整数解</p>
<h3 id="求解-2"><a href="#求解-2" class="headerlink" title="求解"></a>求解</h3><p><img src="../数论四大定理/拓展中国剩余定理-1.png" alt=""><br><img src="../数论四大定理/拓展中国剩余定理-2.png" alt=""></p>
<h3 id="Code-3"><a href="#Code-3" class="headerlink" title="Code"></a>Code</h3><div><div class="fold_hider"><div class="close hider_title"></div></div><div class="fold">
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">pair&lt;ll, ll&gt; exgcd(ll a, ll b) &#123;</span><br><span class="line">	<span class="keyword">if</span> (!b) <span class="keyword">return</span> pair&lt;ll, ll&gt;(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">	pair&lt;ll, ll&gt; temp = exgcd(b, a % b);</span><br><span class="line">	<span class="keyword">return</span> pair&lt;ll, ll&gt;(temp.second, temp.first - a / b * temp.second);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">excrt</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	ll aa = a[<span class="number">1</span>], bb = b[<span class="number">1</span>];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">		ll d = gcd(aa, a[i]);</span><br><span class="line">		pair&lt;ll, ll&gt; temp = exgcd(aa / d, a[i] / d);</span><br><span class="line">		<span class="keyword">while</span> (temp.first &lt; <span class="number">0</span>) temp.first += a[i] / d;</span><br><span class="line">		<span class="keyword">if</span> ((b[i] - bb) % d) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		ll p = a[i] / d;</span><br><span class="line">		ll lcm = aa * p;</span><br><span class="line">		bb = ((temp.first * (b[i] - bb) / d % p + p) % p * aa % lcm + bb) % lcm;</span><br><span class="line">		aa = lcm;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> bb;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></div>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>1.中国剩余定理与扩展中国剩余定理-csdn<br><a href="https://blog.csdn.net/enjoy_pascal/article/details/98521475" target="_blank" rel="noopener">https://blog.csdn.net/enjoy_pascal/article/details/98521475</a></p>
<p>2.孙子定理-百度百科<br><a href="https://baike.baidu.com/item/%E5%AD%99%E5%AD%90%E5%AE%9A%E7%90%86/2841597" target="_blank" rel="noopener">https://baike.baidu.com/item/%E5%AD%99%E5%AD%90%E5%AE%9A%E7%90%86/2841597</a></p>
<p>3.拓展欧几里得算法-简书<br><a href="https://www.jianshu.com/p/9d60995a0e89" target="_blank" rel="noopener">https://www.jianshu.com/p/9d60995a0e89</a></p>
]]></content>
      <categories>
        <category>数论</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>欧几里得定理</tag>
        <tag>拓展欧几里得定理</tag>
        <tag>中国剩余定理</tag>
        <tag>拓展中国剩余定理</tag>
      </tags>
  </entry>
  <entry>
    <title>基于遗传算法和线性规划的快递包装盒下料问题研究</title>
    <url>/ZLY201.github.io/2020/09/01/%E5%9F%BA%E4%BA%8E%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95%E5%92%8C%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92%E7%9A%84%E5%BF%AB%E9%80%92%E5%8C%85%E8%A3%85%E7%9B%92%E4%B8%8B%E6%96%99%E9%97%AE%E9%A2%98%E7%A0%94%E7%A9%B6/</url>
    <content><![CDATA[<h2 id="摘-要"><a href="#摘-要" class="headerlink" title="摘 要"></a><center>摘 要</center></h2><p>&emsp;&emsp;板材下料是多数生产制造企业的第一道工序，如何在满足客户需求的基础上实现材料利用率的提高与利润的最大化，一直是厂家关注的问题。</p>
<p>&emsp;&emsp;本文旨在通过建立系列数学模型，对企业生产包装纸箱的原材料切割方式及生产规模进行规划，使得该企业利润达到最大化。首先，本文依据遗传算法建立下料模型，确定使得原材料利用率较优的原材料切割方案，并在此基础上，建立合理的线性规划模型，求解利润最大化的最终生产方案。随后，考虑到客户需求的弹性，本文在原有线性规划模型基础上进行优化，确定部分包装可替代条件下的生产方案。最后，本文进行了进一步的分析，探究不同种类快递纸箱的需求变化对生产计划的敏感性，为企业与下游快递公司的合作提供帮助。</p>
<p>&emsp;&emsp;针对问题一，本文将生产方案的制定进行划分，先确定瓦楞板怎样切割再确定各切割方案怎样生产。首先，以瓦楞纸的最大利用率为目标，建立了以遗传算法为基础的下料模型。在保证各瓦楞纸的切割方案能够覆盖所有的包装种类的前提下，最终排布出了16种固定的切割方案，每种切割方式的平均利用率达到了94.79%。接着，在此基础上，本文根据需求量，以利润最大为目标进行整数线性规划，求得最终生产计划。具体结果为：三层纸箱总利润约为239.599元，原料利用率约为81.08%；五层纸箱总利润约为176.87元，原料利用率约为78.67%，利润总计约416.469元。</p>
<p>&emsp;&emsp;针对问题二，在明确纸箱的具体代替情况后，对前问整数线性规划模型进行改进。由于实际生产中的需求是弹性的，容积差值在一定范围内可以使用大纸箱替代小纸箱，本文在问题一的基础上，对具体的约束条件及目标函数进行优化。增加纸箱替代数量这一变量，重新进行规划求解，具体结果为：三层纸箱总利润约为243.089元，利用率约为67.78%；五层纸箱总利润约为181.425元，利用率约为79.86%。利润合计约为424.514元。</p>
<p>&emsp;&emsp;针对问题三，本文采用将各箱子的需求量依次增加10%的策略进行探究，根据问题一建立的相关模型将变动后数据代入进行求解并对利润进行比对，最终得到第1、2号箱子的需求量对生产计划最为敏感。并且总体上利润变化率基本在5%以内，最大也仅在10%左右，说明系统稳定性良好，灵敏度校验效果较好。</p>
<p>&emsp;&emsp;最后，本文对该模型的优缺点进行了分析，发现，但却可以在原材料变更、需求量变更的情况下灵活使用，适用度良好。</p>
<p><strong>关键字：二维矩阵下料问题；遗传算法；整数线性规划；灵敏度分析</strong></p>
<h2 id="问题重述"><a href="#问题重述" class="headerlink" title="问题重述"></a><center>问题重述</center></h2><h3 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h3><p>&emsp;&emsp;随着电商行业的蓬勃发展，物流行业对快递纸箱的数量需求越来越多[1]，且规格需求越来越复杂，导致纸箱包装生产企业面临着不小的竞争压力。如何降低成本、实现利润的最大化是当今各个纸箱包装生产企业亟待解决的问题，最大限度地节约材料，提高材料利用率是生产中提高效益的一个重要手段，在此基础上，又要制定合理的生产计划，以应对客户多变的需求。如何使原材料利用率最高、利润最大，即如何下料与如何进行生产规划，成为企业生产的重中之重。</p>
<p>&emsp;&emsp;“下料问题”[2]是把相同形状的一些原材料分割加工成若干个不同规格大小的零件的问题。在传统下料模式中面临两个问题，一是大多并不能从整体上寻求一个较优的结果，而只是依据加工形状从板材直接顺序剪切，这就会造成材料的大量浪费；二是下料切割方案分配不合理，很难定时定量定额地管理下料过程。因此，对于纸箱包装生产企业来说，合理地制定板材下料及生产方案，可以帮助企业提高材料利用率、节约生产成本，是使得企业在激烈市场竞争中站稳脚跟的关键。</p>
<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>&emsp;&emsp;某企业使用边长分别为2.5m，2.0m，1.8m，1.5m的正方形瓦楞板为快递公司生产包装纸箱，其中三层瓦楞板成本分别为10.0，6.5，4.8，4.0元，五层瓦楞板成本为对应三层板的 1.3 倍。在切割工程中剩余的瓦楞板可以以每平米1.4元在其企业内部回收利用</p>
<p>&emsp;&emsp;问题一要求根据所给数据，确定该企业的一天内生产计划，使其利润最大。</p>
<p>&emsp;&emsp;问题二假设在容积误差 30%之内的纸箱可以以大纸箱代替小纸箱供货，要求在该给定假设的前提下求出该企业的一天内生产计划，使其利润最大。</p>
<p>&emsp;&emsp;问题三要求对问题一中的模型进行灵敏度分析，并根据结果求出需求变化对生产计划最为敏感的快递纸箱。</p>
<h2 id="模型假设"><a href="#模型假设" class="headerlink" title="模型假设"></a><center>模型假设</center></h2><ol>
<li><p>本文使用数据真实有效；</p>
</li>
<li><p>不考虑瓦楞板切割工艺造成的损耗；</p>
</li>
<li><p>不考虑纸箱拼装时的板材需求；</p>
</li>
<li><p>将纸箱平面展开图视为规则矩形。</p>
</li>
</ol>
<h2 id="符号说明"><a href="#符号说明" class="headerlink" title="符号说明"></a><center>符号说明</center></h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">符号</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">$l_{i}$</td>
<td style="text-align:center">第$i$号纸箱切割长度</td>
</tr>
<tr>
<td style="text-align:center">$w_{i}$</td>
<td style="text-align:center">第i号纸箱切割宽度</td>
</tr>
<tr>
<td style="text-align:center">$m_{i}$</td>
<td style="text-align:center">第i号纸箱单价</td>
</tr>
<tr>
<td style="text-align:center">$d_{i}$</td>
<td style="text-align:center">第i号纸箱需求量</td>
</tr>
<tr>
<td style="text-align:center">$a_{j}$</td>
<td style="text-align:center">第j种切割模式的瓦楞板边长</td>
</tr>
<tr>
<td style="text-align:center">$c_{j}$</td>
<td style="text-align:center">第j种切割模式的瓦楞板成本</td>
</tr>
<tr>
<td style="text-align:center">$x_{j}$</td>
<td style="text-align:center">第j种切割模式的使用次数</td>
</tr>
<tr>
<td style="text-align:center">$m_{re}$</td>
<td style="text-align:center">回收价格</td>
</tr>
<tr>
<td style="text-align:center">$I_{i,j}$</td>
<td style="text-align:center">第i种纸箱由第j种纸箱替换的个数</td>
</tr>
<tr>
<td style="text-align:center">$A_{MN}$</td>
<td style="text-align:center">$M \times N$矩阵，表示各模式生产各类纸箱的数量，$M$为需求纸箱的种类数量，$N$为生产模式的数量利润</td>
</tr>
<tr>
<td style="text-align:center">$z$</td>
<td style="text-align:center">利润</td>
</tr>
</tbody>
</table>
</div>
<h2 id="问题一模型的建立与求解"><a href="#问题一模型的建立与求解" class="headerlink" title="问题一模型的建立与求解"></a><center>问题一模型的建立与求解</center></h2><h3 id="问题一的分析"><a href="#问题一的分析" class="headerlink" title="问题一的分析"></a>问题一的分析</h3><p>&emsp;&emsp;问题一要求根据企业1天的订单数确定该企业的生产计划，可以划分为制定瓦楞板的下料方案、制定生产计划满足需求两个步骤。在制定瓦楞板的下料方案时，需要能够兼顾每一种需求纸箱的下料生产，以及板材利用率最大两项需求。而在制定生产计划时，则需要在考虑各项纸箱的成产计划数量大于各自的需求数量的基础之上，合理规划使得企业的利润最大化。为此，我们在第一步采用遗传算法[3]，分别为四种板材制定出共16种切割方案，在第二步，在已有的切割方式下，采用线性规划的方法根据需求量列出相关方程，并设置目标函数为纯利润，将问题数学模型化进行求解，最终得出企业该日的生产计划。</p>
<h3 id="数据预处理"><a href="#数据预处理" class="headerlink" title="数据预处理"></a>数据预处理</h3><p>&emsp;&emsp;考虑到快递纸箱并非简单的立方体展开模型，其顶部与底部是由两对纸板拼合组成（图1），由图2快递纸箱的平面展开示意图可知，快递纸箱大致呈现为矩形[4]。为将问题简化，本文将展开后的纸箱形状视为规则矩形。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"><img src="../基于遗传算法和线性规划的快递包装盒下料问题研究/img/wps7.jpg" alt="img"></th>
<th style="text-align:center"><img src="../基于遗传算法和线性规划的快递包装盒下料问题研究/img/wps8.jpg" alt="img"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">图1 快递纸箱示意图</td>
<td style="text-align:center">图2 快递纸箱展开平面示意图</td>
</tr>
</tbody>
</table>
</div>
<p>&emsp;&emsp;根据题中所给相关参数求出各个纸箱平面图大小如表1所示：</p>
<center>表1 各纸箱平面图大小</center>

<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">纸箱编号</th>
<th style="text-align:center">需要长度</th>
<th style="text-align:center">需要宽度</th>
<th style="text-align:center">纸箱编号</th>
<th style="text-align:center">需要长度</th>
<th style="text-align:center">需要宽度</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">1660</td>
<td style="text-align:center">670</td>
<td style="text-align:center">7</td>
<td style="text-align:center">720</td>
<td style="text-align:center">290</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">1540</td>
<td style="text-align:center">530</td>
<td style="text-align:center">8</td>
<td style="text-align:center">640</td>
<td style="text-align:center">250</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">1280</td>
<td style="text-align:center">480</td>
<td style="text-align:center">9</td>
<td style="text-align:center">600</td>
<td style="text-align:center">240</td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center">1080</td>
<td style="text-align:center">420</td>
<td style="text-align:center">10</td>
<td style="text-align:center">540</td>
<td style="text-align:center">210</td>
</tr>
<tr>
<td style="text-align:center">5</td>
<td style="text-align:center">920</td>
<td style="text-align:center">360</td>
<td style="text-align:center">11</td>
<td style="text-align:center">460</td>
<td style="text-align:center">190</td>
</tr>
<tr>
<td style="text-align:center">6</td>
<td style="text-align:center">800</td>
<td style="text-align:center">330</td>
<td style="text-align:center">12</td>
<td style="text-align:center">420</td>
<td style="text-align:center">170</td>
</tr>
</tbody>
</table>
</div>
<h3 id="遗传算法模型的建立"><a href="#遗传算法模型的建立" class="headerlink" title="遗传算法模型的建立"></a>遗传算法模型的建立</h3><p>&emsp;&emsp;为了便于生产且简化运算，首先我们使用了遗传算法对瓦楞纸的切割方式做出了规划。</p>
<p>&emsp;&emsp;遗传算法(Genetic Algorithm, GA)是一种通过模拟自然生命现象，借鉴生物界的自然选择和进化机制演化而来的随机搜索方法，是基于生物进化和随机选择的全局搜索优化计算技术。针对不同问题，通过设计不同的编码方法来表示问题的可行解，采用多种不同的遗传算子来模拟不同环境下的生物遗传特性，以得出全局最优解或较优解。</p>
<h4 id="适应度函数的选择"><a href="#适应度函数的选择" class="headerlink" title="适应度函数的选择"></a>适应度函数的选择</h4><p>&emsp;&emsp;遗传算法评价染色体优劣的标准就是染色体适应度值。在用遗传算法解决实际应用问题时，需要设计具有针对性的适应度函数。由于在实际生产中，板材切割后剩余废料越少越好，即利用率最大，故本文针将板材利用率，即所有矩形纸箱的面积和除以所占用的板材的总面积，作为就可以衡量切割方案优劣的标准，板材利用率函数为：</p>
<script type="math/tex; mode=display">f(i)=\sum_{i=1}^{n}(x_{i},y_{i})/(L \times W)</script><p>&emsp;&emsp;其中，$\sum_{i=1}^{n}$为所有矩形纸箱的面积和，$(L \times W)$为所占用的板材的总面积，</p>
<p>&emsp;&emsp;适应度的取值范围在[0, 1]之间，适应度值越接近于1，说明个体越优秀，反之，说明个体性能越差，在进行下一步迭代的过程中就可能被淘汰。</p>
<h4 id="遗传操作"><a href="#遗传操作" class="headerlink" title="遗传操作"></a>遗传操作</h4><p>（1）初始种群的生成</p>
<p>&emsp;&emsp;本文采用十进制编码，设置初始种群大小为20。对于瓦楞板采用”一刀切”的方式进行切割，初始种群生成流程如下：</p>
<p>&emsp;&emsp;Step 1：建立坐标系，确定上限宽度与长度，即瓦楞板大小；</p>
<p>&emsp;&emsp;Step 2：产生一个随机数序列，取值范围为[1, 12]；</p>
<p>&emsp;&emsp;Step 3：根据随机数序列将纸箱按层排列，当大小超出上限后跳出循坏给出编码；</p>
<p>&emsp;&emsp;Step 4：重复上述步骤直至产生20个初始个体。</p>
<p>（2）选择</p>
<p>&emsp;&emsp;遗传算法中的“选择”是模拟自然界中优胜略汰的自然选择，即从群体中选择优胜的个体，淘汰劣质个体，其目的是把优化的解直接或间接遗传到下一代。选择操作是建立在群体中个体的适应度评估基础上的，本文在计算出适应度的基础上进行排序，采用适应度比例方法留下优化的解：</p>
<script type="math/tex; mode=display">p=f(i)/\sum_{i=1}^{n}</script><p>&emsp;&emsp;其中，$p$为染色体i被选择的概率，$f(i)$为染色体i的适应度，即染色体i被选择的概率 = 染色体i的适应度 / 所有染色体的适应度之和。</p>
<p>（3）交叉</p>
<p>&emsp;&emsp;自然界中生物进化的多样性依靠生物遗传基因的重组或变异，遗传算法中采用交叉算子模拟该过程。交叉是指把两个父代个体的部分结构加以替换重组而生成新个体的操作，这使得遗传算法的搜索能力得以飞跃提高。本文将交叉概率设置为0.7。</p>
<p>（4）变异</p>
<p>&emsp;&emsp;变异的基本内容是对群体中的个体串的某些基因位置上的基因值作变动，是解的进化中产生新个体的辅助方法。变异的目的一是提高算法局部搜索能力，二是使遗传算法可维持群体多样性，以防止出现未成熟收敛现象。本文将变异概率设置为0.1。</p>
<h4 id="终止条件的设置"><a href="#终止条件的设置" class="headerlink" title="终止条件的设置"></a>终止条件的设置</h4><p>&emsp;&emsp;常见的终止条件设置为，当最优个体的适应度达到给定的阈值，或者最优个体的适应度和群体适应度不再上升时，或者迭代次数达到预设的代数时，算法终止。本文采用设置迭代次数的方式进行终止，迭代次数为100次。</p>
<p><img src="../基于遗传算法和线性规划的快递包装盒下料问题研究/img/wps17.png" alt="img"></p>
<center>图3 遗传算法流程图</center>

<h4 id="遗传算法模型的求解"><a href="#遗传算法模型的求解" class="headerlink" title="遗传算法模型的求解"></a>遗传算法模型的求解</h4><p>&emsp;&emsp;将预处理的数据带入到建立的模型中求解，最终得到各瓦楞板利用率较高的几种使用方式(表2)。</p>
<center>表2 各瓦楞板切割方式</center>

<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">切割方式编号</th>
<th style="text-align:center">1</th>
<th style="text-align:center">2</th>
<th style="text-align:center">3</th>
<th style="text-align:center">4</th>
<th style="text-align:center">5</th>
<th style="text-align:center">6</th>
<th style="text-align:center">7</th>
<th style="text-align:center">8</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">瓦楞板边长</td>
<td style="text-align:center">2500</td>
<td style="text-align:center">2500</td>
<td style="text-align:center">2500</td>
<td style="text-align:center">2500</td>
<td style="text-align:center">2000</td>
<td style="text-align:center">2000</td>
<td style="text-align:center">2000</td>
<td style="text-align:center">1800</td>
</tr>
<tr>
<td style="text-align:center">提供1号纸箱数目</td>
<td style="text-align:center">2</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">提供2号纸箱数目</td>
<td style="text-align:center">0</td>
<td style="text-align:center">2</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">提供3号纸箱数目</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">3</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">提供4号纸箱数目</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">3</td>
<td style="text-align:center">0</td>
<td style="text-align:center">3</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">提供5号纸箱数目</td>
<td style="text-align:center">0</td>
<td style="text-align:center">4</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">3</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">提供6号纸箱数目</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">15</td>
<td style="text-align:center">0</td>
<td style="text-align:center">6</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">提供7号纸箱数目</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">3</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">6</td>
</tr>
<tr>
<td style="text-align:center">提供8号纸箱数目</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">2</td>
<td style="text-align:center">0</td>
<td style="text-align:center">2</td>
</tr>
<tr>
<td style="text-align:center">提供9号纸箱数目</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">12</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">提供10号纸箱数目</td>
<td style="text-align:center">8</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">6</td>
<td style="text-align:center">0</td>
<td style="text-align:center">5</td>
</tr>
<tr>
<td style="text-align:center">提供11号纸箱数目</td>
<td style="text-align:center">0</td>
<td style="text-align:center">11</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">14</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">提供12号纸箱数目</td>
<td style="text-align:center">14</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">利用率</td>
<td style="text-align:center">96.13%</td>
<td style="text-align:center">95.10%</td>
<td style="text-align:center">98.33%</td>
<td style="text-align:center">92.16%</td>
<td style="text-align:center">91.02%</td>
<td style="text-align:center">92.16%</td>
<td style="text-align:center">93.69%</td>
<td style="text-align:center">99.54%</td>
</tr>
</tbody>
</table>
</div>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">切割方式编号</th>
<th style="text-align:center">1</th>
<th style="text-align:center">2</th>
<th style="text-align:center">3</th>
<th style="text-align:center">4</th>
<th style="text-align:center">5</th>
<th style="text-align:center">6</th>
<th style="text-align:center">7</th>
<th style="text-align:center">8</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">瓦楞板边长</td>
<td style="text-align:center">2500</td>
<td style="text-align:center">2500</td>
<td style="text-align:center">2500</td>
<td style="text-align:center">2500</td>
<td style="text-align:center">2000</td>
<td style="text-align:center">2000</td>
<td style="text-align:center">2000</td>
<td style="text-align:center">1800</td>
</tr>
<tr>
<td style="text-align:center">提供1号纸箱数目</td>
<td style="text-align:center">2</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">提供2号纸箱数目</td>
<td style="text-align:center">0</td>
<td style="text-align:center">2</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">提供3号纸箱数目</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">3</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">提供4号纸箱数目</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">3</td>
<td style="text-align:center">0</td>
<td style="text-align:center">3</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">提供5号纸箱数目</td>
<td style="text-align:center">0</td>
<td style="text-align:center">4</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">3</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">提供6号纸箱数目</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">15</td>
<td style="text-align:center">0</td>
<td style="text-align:center">6</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">提供7号纸箱数目</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">3</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">6</td>
</tr>
<tr>
<td style="text-align:center">提供8号纸箱数目</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">2</td>
<td style="text-align:center">0</td>
<td style="text-align:center">2</td>
</tr>
<tr>
<td style="text-align:center">提供9号纸箱数目</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">12</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">提供10号纸箱数目</td>
<td style="text-align:center">8</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">6</td>
<td style="text-align:center">0</td>
<td style="text-align:center">5</td>
</tr>
<tr>
<td style="text-align:center">提供11号纸箱数目</td>
<td style="text-align:center">0</td>
<td style="text-align:center">11</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">14</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">提供12号纸箱数目</td>
<td style="text-align:center">14</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">利用率</td>
<td style="text-align:center">96.13%</td>
<td style="text-align:center">95.10%</td>
<td style="text-align:center">98.33%</td>
<td style="text-align:center">92.16%</td>
<td style="text-align:center">91.02%</td>
<td style="text-align:center">92.16%</td>
<td style="text-align:center">93.69%</td>
<td style="text-align:center">99.54%</td>
</tr>
</tbody>
</table>
</div>
<h3 id="基于整数线性规划的生产规模规划"><a href="#基于整数线性规划的生产规模规划" class="headerlink" title="基于整数线性规划的生产规模规划"></a>基于整数线性规划的生产规模规划</h3><p>&emsp;&emsp;在完成切割方式的确定后，接下来对生产规模进行整数线性规划[5~6]。</p>
<p>&emsp;&emsp;对于线性规划模型的建立，首先考虑需求量的约束，在上述遗传算法中，我们已得到了每种模式具体的生产每种箱子的数量，则可知每种生产模式与生产数量之积的和可以代表实际生产量，对此我们建立了实际生产量 &lt; 需求量的约束；接下来对目标函数$z$(利润)进行建立，即箱子售价总和与成本之差再加上回收费用，并求其在需求量约束下的最大值。</p>
<script type="math/tex; mode=display">max\ z = \sum_{i = 1}^{M}d_{i} \cdot m_{i} - \sum_{j=1}^{N}x_{j} \cdot c_{j} + m_{re} \cdot (\sum_{j = 1}^{N}x_{j} \cdot a_{j}^{2}-\sum_{i=0}^{M}d_{i} \cdot l_{i} \cdot w_{i})</script><p>&emsp;&emsp;需满足的约束条件：</p>
<p>1、各类纸箱生产数量大于其需求量：$A \dot x_{i} \geq d_{i}$</p>
<p>2、切割模式的使用次数为非负整数：$x_{i}$为整数，$x_{i} \leq 0$</p>
<p>&emsp;&emsp;三层纸箱需求量约束方程组如下所示：</p>
<script type="math/tex; mode=display">\begin{cases}2\times x_1+2\times x_{14} \geq 40\\
2\times x_2+2\times x_{15}\geq 67\\
3\times x_3+2\times x_{16}\geq 86\\
3\times x_5+3\times x_7+2\times x_{13}\geq 89\\
4\times x_2+3\times x_5+2\times x_{11}\geq 108\\
15\times x_4+6\times x_6+\geq 111\\
3\times x_3+6\times x_8+4\times x_{11}+4\times x_{16}\geq 123\\
x_2+x_5+2\times x_6+2\times x_8+10\times x_9\geq 129\\
12\times x_3+15\times x_{10}+3\times x_{16}\geq 140\\
8\times x_1+6\times x_6+5\times x_8+6\times x_9+8*x_{12}+3\times x_{14}+x_{16}\geq 110\\
11\times x_2+14\times x_7+x_8+2\times x_{12}\geq 96\\
14\times x_1+x_3+8\times x_{11}+6\times x_{12}+6\times x_{13}\end{cases}</script><p>&emsp;&emsp;使用python中的pulp库函数求解，得到最终结果如下表所示：</p>
<center>表3 问题一线性规划求解结果</center>

<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">切割方式编号</th>
<th style="text-align:center">三层瓦楞板对应切割方式使用次数</th>
<th style="text-align:center">五层瓦楞板对应切割方式使用次数</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">1</td>
<td style="text-align:center">2</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">28</td>
<td style="text-align:center">26</td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center">7</td>
<td style="text-align:center">6</td>
</tr>
<tr>
<td style="text-align:center">5</td>
<td style="text-align:center">24</td>
<td style="text-align:center">21</td>
</tr>
<tr>
<td style="text-align:center">6</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">7</td>
<td style="text-align:center">6</td>
<td style="text-align:center">4</td>
</tr>
<tr>
<td style="text-align:center">8</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">9</td>
<td style="text-align:center">10</td>
<td style="text-align:center">6</td>
</tr>
<tr>
<td style="text-align:center">10</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">11</td>
<td style="text-align:center">16</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">12</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">13</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">14</td>
<td style="text-align:center">20</td>
<td style="text-align:center">43</td>
</tr>
<tr>
<td style="text-align:center">15</td>
<td style="text-align:center">33</td>
<td style="text-align:center">46</td>
</tr>
<tr>
<td style="text-align:center">16</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
</tr>
</tbody>
</table>
</div>
<p>&emsp;&emsp;求得三层纸箱总利润约为239.599元，原料利用率约为81.08%；五层纸箱总利润约为176.87元，原料利用率约为78.67%，利润总计约416.469元。</p>
<h2 id="问题二模型的建立与求解"><a href="#问题二模型的建立与求解" class="headerlink" title="问题二模型的建立与求解"></a><center>问题二模型的建立与求解</center></h2><h3 id="问题二的分析"><a href="#问题二的分析" class="headerlink" title="问题二的分析"></a>问题二的分析</h3><p>&emsp;&emsp;问题二在问题一的基础上进行了调整，增加了的纸箱在容积误差 30%之内可以以大纸箱代替小纸箱供货的条件，其中怎样进行生产计划的弹性调整是解决问题的关键。为了解决这个问题，本文首先求出容积差在30%以内的纸箱，其次，采取递推策略，将小纸箱的需求设置为原需求-被替换数，之后利用线性规划进行求解。</p>
<h3 id="问题二模型的建立"><a href="#问题二模型的建立" class="headerlink" title="问题二模型的建立"></a>问题二模型的建立</h3><p>&emsp;&emsp;首先通过计算，我们找出了容积差在30%以内的可替换策略共有4种，分别为5号替换6号纸箱，6号替换7号纸箱，8号替换9号纸箱和11号替换12号纸箱。</p>
<p>&emsp;&emsp;在问题一的线性规划基础上，增加变量$I_{p,q}$表示实际生产中包装$p$由包装$q$代替的数量，由于此时的生产纸箱数量并不是需求数量，而是原有需求数量-由其他纸箱替代数量+替代其他纸箱数量，表达为原有的$d_{i}$替换为$(d_{i}-\sum_{q=1}^{M}I_{i,q}+\sum_{p=1}^{M}I_{p,i})$。</p>
<p>&emsp;&emsp;新建立的利润最大化目标函数如下：</p>
<script type="math/tex; mode=display">max\ z = \sum_{i = 1}^{M}(d_{i}-\sum_{q=1}^{M}I_{i,q}+\sum_{p=1}^{M}I_{p,i}) \cdot m_{i} - \sum_{j=1}^{N}x_{j} \cdot c_{j} + m_{re} \cdot [\sum_{j = 1}^{N}x_{j} \cdot a_{j}^{2}-\sum_{i=0}^{M}(d_{i}-\sum_{q=1}^{M}I_{i,q}+\sum_{p=1}^{M}I_{p,i}) \cdot l_{i} \cdot w_{i}]</script><p>&emsp;&emsp;满足的约束条件为：</p>
<ol>
<li><p>各类纸箱生产数量大于其需求量：$A \cdot x_{i} \geq d_{i} - \sum_{q=1}^{M}I_{p,q}+\sum_{p=1}^{M}I_{p.i}$</p>
</li>
<li><p>切割模式的使用次数为非负整数：$x_{i}$为整数，$x \geq 0$</p>
</li>
</ol>
<p>&emsp;&emsp;建立相关三层纸箱需求量线性规划约束方程组如下：</p>
<script type="math/tex; mode=display">\begin{cases}2\times x_1+2\times x_{14} \geq 40\\2\times x_2+2\times x_{15}\geq 67\\
3\times x_3+2\times x_{16}\geq 86\\
3\times x_5+3\times x_7+2\times x_{13}\geq 89\\
4\times x_2+3\times x_5+2\times x_{11}\geq 108+I_{5,6}\\
15\times x_4+6\times x_6+\geq 111-I_{5,6}+I_{6,7}\\
3\times x_3+6\times x_8+4\times x_{11}+4\times x_{16}\geq 123-I_{6,7}\\
x_2+x_5+2\times x_6+2\times x_8+10\times x_9\geq 129+I_{8,9}\\
12\times x_3+15\times x_{10}+3\times x_{16}\geq 140-I_{8,9}\\
8\times x_1+6\times x_6+5\times x_8+6\times x_9+8*x_{12}+3\times x_{14}+x_{16}\geq 110\\
11\times x_2+14\times x_7+x_8+2\times x_{12}\geq 96+I_{11,12}\\
14\times x_1+x_3+8\times x_{11}+6\times x_{12}+6\times x_{13}\end{cases}</script><h3 id="问题二模型的求解"><a href="#问题二模型的求解" class="headerlink" title="问题二模型的求解"></a>问题二模型的求解</h3><p>&emsp;&emsp;根据以上建立的相关方程组，使用python中的pulp库函数求解，得到最优生产计划如下表所示：</p>
<center>表4 问题二线性规划求解结果</center>

<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">切割方式编号</th>
<th style="text-align:center">三层瓦楞板对应切割方式使用次数</th>
<th style="text-align:center">五层瓦楞板对应切割方式使用次数</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">0</td>
<td style="text-align:center">5</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">28</td>
<td style="text-align:center">26</td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center">0</td>
<td style="text-align:center">4</td>
</tr>
<tr>
<td style="text-align:center">5</td>
<td style="text-align:center">23</td>
<td style="text-align:center">24</td>
</tr>
<tr>
<td style="text-align:center">6</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">7</td>
<td style="text-align:center">7</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">8</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">9</td>
<td style="text-align:center">11</td>
<td style="text-align:center">5</td>
</tr>
<tr>
<td style="text-align:center">10</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">11</td>
<td style="text-align:center">75</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">12</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">13</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">14</td>
<td style="text-align:center">20</td>
<td style="text-align:center">43</td>
</tr>
<tr>
<td style="text-align:center">15</td>
<td style="text-align:center">34</td>
<td style="text-align:center">43</td>
</tr>
<tr>
<td style="text-align:center">16</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
</tr>
</tbody>
</table>
</div>
<p>&emsp;&emsp;并解得最优替换策略如下表所示：</p>
<center>表5 最大利润下的替换策略</center>

<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">替换方法</th>
<th style="text-align:center">三层纸箱</th>
<th style="text-align:center">五层纸箱</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">5号替换6号次数</td>
<td style="text-align:center">111</td>
<td style="text-align:center">22</td>
</tr>
<tr>
<td style="text-align:center">6号替换7号次数</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">8号替换9号次数</td>
<td style="text-align:center">4</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">11号替换12号次数</td>
<td style="text-align:center">2</td>
<td style="text-align:center">4</td>
</tr>
</tbody>
</table>
</div>
<p>&emsp;&emsp;其中三层纸箱总利润约为243.089元，利用率约为67.78%；五层纸箱总利润约为181.425元，利用率约为79.86%。利润合计约为424.514元。</p>
<h2 id="问题三模型的建立与求解"><a href="#问题三模型的建立与求解" class="headerlink" title="问题三模型的建立与求解"></a><center>问题三模型的建立与求解</center></h2><h3 id="问题三的分析"><a href="#问题三的分析" class="headerlink" title="问题三的分析"></a>问题三的分析</h3><p>&emsp;&emsp;问题三要求求出哪一种快递纸箱的需求变化量对生产计划最敏感。在这里我们利用生产总利润代表生产计划，这样不仅可以使该问题能够在上述模型的基础上进行求解，而且结果直观准确，能够直接地反映出各纸箱需求量变化对生产计划的敏感度。为了体现各纸箱对于生产需求的敏感度，本文采用控制变量法，分别将各个纸箱的需求量提高10%，后带入到问题一建立的线性规划模型中求解最优生产计划下的总利润，设置目标函数为利润变化率对其进行灵敏度分析[7]。</p>
<h3 id="灵敏度分析"><a href="#灵敏度分析" class="headerlink" title="灵敏度分析"></a>灵敏度分析</h3><p>&emsp;&emsp;在各纸箱需求量大小的情况下根据问题一的模型解出最大利润，并求出最大利润变化率，得到结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">三层：</span><br><span class="line">原利润为：239.599360</span><br><span class="line">第1个纸箱需求量增加10%后，利润变为249.439360，变化率为0.041069</span><br><span class="line">第2个纸箱需求量增加10%后，利润变为252.067360，变化率为0.052037</span><br><span class="line">第3个纸箱需求量增加10%后，利润变为250.279360，变化率为0.044574</span><br><span class="line">第4个纸箱需求量增加10%后，利润变为248.949360，变化率为0.039023</span><br><span class="line">第5个纸箱需求量增加10%后，利润变为248.479360，变化率为0.037062</span><br><span class="line">第6个纸箱需求量增加10%后，利润变为247.149360，变化率为0.031511</span><br><span class="line">第7个纸箱需求量增加10%后，利润变为247.759360，变化率为0.034057</span><br><span class="line">第8个纸箱需求量增加10%后，利润变为245.865360，变化率为0.026152</span><br><span class="line">第9个纸箱需求量增加10%后，利润变为246.599360，变化率为0.029215</span><br><span class="line">第10个纸箱需求量增加10%后，利润变为243.889360，变化率为0.017905</span><br><span class="line">第11个纸箱需求量增加10%后，利润变为242.325360，变化率为0.011377</span><br><span class="line">第12个纸箱需求量增加10%后，利润变为241.919360，变化率为0.009683</span><br><span class="line"></span><br><span class="line">五层：</span><br><span class="line">原利润为：176.870300</span><br><span class="line">第1个纸箱需求量增加10%后，利润变为195.710300，变化率为0.106519</span><br><span class="line">第2个纸箱需求量增加10%后，利润变为195.434300，变化率为0.104958</span><br><span class="line">第3个纸箱需求量增加10%后，利润变为183.520300，变化率为0.037598</span><br><span class="line">第4个纸箱需求量增加10%后，利润变为184.436300，变化率为0.042777</span><br><span class="line">第5个纸箱需求量增加10%后，利润变为183.678300，变化率为0.038491</span><br><span class="line">第6个纸箱需求量增加10%后，利润变为185.430300，变化率为0.048397</span><br><span class="line">第7个纸箱需求量增加10%后，利润变为182.910300，变化率为0.034149</span><br><span class="line">第8个纸箱需求量增加10%后，利润变为180.320300，变化率为0.019506</span><br><span class="line">第9个纸箱需求量增加10%后，利润变为180.710300，变化率为0.021711</span><br><span class="line">第10个纸箱需求量增加10%后，利润变为180.050300，变化率为0.017979</span><br><span class="line">第12个纸箱需求量增加10%后，利润变为179.450300，变化率为0.014587</span><br><span class="line">第12个纸箱需求量增加10%后，利润变为179.460300，变化率为0.014643</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;可以看出，需求量分别增加10%后，1号和2号纸箱的利润变化率较大，说明其对需求量较为灵敏。除此之外，其余纸箱利润率变化基本在5%以下，最大的也仅在10%左右，说明系统稳定性良好，灵敏度检验效果较好。</p>
<h2 id="模型的优缺点"><a href="#模型的优缺点" class="headerlink" title="模型的优缺点"></a><center>模型的优缺点</center></h2><h3 id="模型优点"><a href="#模型优点" class="headerlink" title="模型优点"></a>模型优点</h3><p>&emsp;&emsp;遗传算法[8]作为现代优化算法之一，有着一定的优点，如：能够求出优化问题的全局最优解；优化结果与初始条件无关；算法独立于求解域；具有较强的鲁棒性；适合于求解复杂的优化问题；应用较为广泛。</p>
<p>&emsp;&emsp;而线性规划是决策系统的静态最优化数学规划方法之一，在现代决策中的应用是非常广泛的，它可以在各种相互关联的多变量约束条件下,解决或规划一个对象的线性目标函数最优的问题，非常适用于本题。</p>
<p>&emsp;&emsp;因此，本文建立的数学模型不仅适用范围广，而且结果准确。</p>
<h3 id="模型缺点"><a href="#模型缺点" class="headerlink" title="模型缺点"></a>模型缺点</h3><p>&emsp;&emsp;遗传算法收敛速度慢，局部搜索能力差。并且染色体数、交叉概率、变异概率、终止条件都需一定的主观性判断，需经多次实验才可找到较优解。</p>
<p>&emsp;&emsp;而线性规划是一个静态模型，随着条件的改变，约束条件与目标函数可能都要随之进行调整，这种机械性决定它在某种意义上不可避免的局限性。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a><center>参考文献</center></h2><p>&emsp;[1] 瓦楞纸箱需求增长趋势[J]. 中国包装, 2019, 39(03):86.</p>
<p>&emsp;[2] 马俊燕, 韩志会, 骆德铖, 韩贺春, 肖海华. 不确定环境下一维下料问题[J]. 锻压技术, 2020, 45(03):190-196.</p>
<p>&emsp;[3] 田康. 基于遗传算法对二维下料问题的研究[J]. 科技风, 2020(09):198.</p>
<p>&emsp;[4] 朱艳华. 瓦楞纸板生产线的工艺控制和标准化[J]. 印刷技术, 2017(07):51-53.</p>
<p>&emsp;[5] 王茹, 黄亚辉. 线性规划在实际生产生活中的应用[J]. 科技创新导报, 2018, 15(09):155-156.</p>
<p>&emsp;[6] 姚凯翊. 线性规划在企业生产中的案例研究[J]. 现代商业, 2020(17):108-109.</p>
<p>&emsp;[7] 勒晓阳, 李松仁, 贾春霖. 线性规划灵敏度分析模型[J]. 中南矿冶学院学报, 1990(06):602-609.</p>
<p>&emsp;[8] 唐文琦, 曾干敏, 刘泽宇. 浅谈遗传算法及其部分改进算法[J]. 科技风, 2019(12):57.</p>
<h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a><center>附录</center></h2><h3 id="数据预处理相关python代码-data-process-py"><a href="#数据预处理相关python代码-data-process-py" class="headerlink" title="数据预处理相关python代码 data_process.py"></a>数据预处理相关python代码 data_process.py</h3><div><div class="fold_hider"><div class="close hider_title"></div></div><div class="fold">
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> sko</span><br><span class="line"><span class="keyword">from</span> sko.GA <span class="keyword">import</span> GA</span><br><span class="line"></span><br><span class="line">box = [[<span class="number">530</span>, <span class="number">300</span>, <span class="number">370</span>], [<span class="number">530</span>, <span class="number">240</span>, <span class="number">290</span>],</span><br><span class="line">       [<span class="number">430</span>, <span class="number">210</span>, <span class="number">270</span>], [<span class="number">350</span>, <span class="number">190</span>, <span class="number">230</span>],</span><br><span class="line">       [<span class="number">290</span>, <span class="number">170</span>, <span class="number">190</span>], [<span class="number">250</span>, <span class="number">150</span>, <span class="number">180</span>],</span><br><span class="line">       [<span class="number">230</span>, <span class="number">130</span>, <span class="number">160</span>], [<span class="number">210</span>, <span class="number">110</span>, <span class="number">140</span>],</span><br><span class="line">       [<span class="number">195</span>, <span class="number">105</span>, <span class="number">135</span>], [<span class="number">175</span>, <span class="number">95</span>, <span class="number">115</span>],</span><br><span class="line">       [<span class="number">145</span>, <span class="number">85</span>, <span class="number">105</span>], [<span class="number">130</span>, <span class="number">80</span>, <span class="number">90</span>]]</span><br><span class="line">box_need_three = [<span class="number">40</span>, <span class="number">67</span>, <span class="number">86</span>, <span class="number">89</span>, <span class="number">108</span>, <span class="number">111</span>,</span><br><span class="line">                  <span class="number">123</span>, <span class="number">129</span>, <span class="number">140</span>, <span class="number">110</span>, <span class="number">96</span>, <span class="number">84</span>]</span><br><span class="line">box_need_five = [<span class="number">85</span>, <span class="number">95</span>, <span class="number">80</span>, <span class="number">75</span>, <span class="number">70</span>, <span class="number">82</span>,</span><br><span class="line">                 <span class="number">76</span>, <span class="number">79</span>, <span class="number">69</span>, <span class="number">60</span>, <span class="number">65</span>, <span class="number">78</span>]</span><br><span class="line">box_price_three = [<span class="number">2.91</span>, <span class="number">2.21</span>, <span class="number">1.76</span>, <span class="number">1.35</span>, <span class="number">1.02</span>, <span class="number">0.80</span>,</span><br><span class="line">                   <span class="number">0.68</span>, <span class="number">0.55</span>, <span class="number">0.50</span>, <span class="number">0.39</span>, <span class="number">0.34</span>, <span class="number">0.29</span>]</span><br><span class="line">box_price_five = [<span class="number">3.78</span>, <span class="number">2.82</span>, <span class="number">2.25</span>, <span class="number">1.71</span>, <span class="number">1.30</span>, <span class="number">1.07</span>,</span><br><span class="line">                  <span class="number">0.87</span>, <span class="number">0.70</span>, <span class="number">0.64</span>, <span class="number">0.53</span>, <span class="number">0.43</span>, <span class="number">0.37</span>]</span><br><span class="line">board = [<span class="number">2500</span>, <span class="number">2000</span>, <span class="number">1800</span>, <span class="number">1500</span>]</span><br><span class="line">board_price_three = [<span class="number">10</span>, <span class="number">6.5</span>, <span class="number">4.8</span>, <span class="number">4.0</span>]</span><br><span class="line">board_price_five = [(x * <span class="number">1.3</span>) <span class="keyword">for</span> x <span class="keyword">in</span> board_price_three]</span><br><span class="line"></span><br><span class="line">arr = []</span><br><span class="line"><span class="keyword">for</span> boxx <span class="keyword">in</span> box:</span><br><span class="line">    arr.append([<span class="number">2</span> * (boxx[<span class="number">0</span>] + boxx[<span class="number">1</span>]), <span class="number">2</span> * boxx[<span class="number">1</span>] + boxx[<span class="number">2</span>]])</span><br><span class="line"><span class="comment"># print(arr)</span></span><br><span class="line"></span><br><span class="line">q = <span class="number">1.4</span></span><br><span class="line">sum_three = <span class="number">0</span></span><br><span class="line">all_three = <span class="number">0</span></span><br><span class="line">sum_five = <span class="number">0</span></span><br><span class="line">all_five = <span class="number">0</span></span><br><span class="line">delta_three = []</span><br><span class="line">delta_five = []</span><br><span class="line">all_instead_three = <span class="number">0</span></span><br><span class="line">all_instead_five = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(box)):</span><br><span class="line">    <span class="keyword">if</span> i == <span class="number">4</span>:</span><br><span class="line">        all_instead_three += arr[i][<span class="number">0</span>] * arr[i][<span class="number">1</span>] * (box_need_three[i] + <span class="number">111</span>)</span><br><span class="line">    <span class="keyword">elif</span> i == <span class="number">5</span>:</span><br><span class="line">        k = <span class="number">0</span></span><br><span class="line">    <span class="keyword">elif</span> i == <span class="number">7</span>:</span><br><span class="line">        all_instead_three += arr[i][<span class="number">0</span>] * arr[i][<span class="number">1</span>] * (box_need_three[i] + <span class="number">4</span>)</span><br><span class="line">    <span class="keyword">elif</span> i == <span class="number">8</span>:</span><br><span class="line">        all_instead_three += arr[i][<span class="number">0</span>] * arr[i][<span class="number">1</span>] * (box_need_three[i] - <span class="number">4</span>)</span><br><span class="line">    <span class="keyword">elif</span> i == <span class="number">10</span>:</span><br><span class="line">        all_instead_three += arr[i][<span class="number">0</span>] * arr[i][<span class="number">1</span>] * (box_need_three[i] + <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">elif</span> i == <span class="number">11</span>:</span><br><span class="line">        all_instead_three += arr[i][<span class="number">0</span>] * arr[i][<span class="number">1</span>] * (box_need_three[i] - <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        all_instead_three += arr[i][<span class="number">0</span>] * arr[i][<span class="number">1</span>] * box_need_three[i]</span><br><span class="line">    <span class="keyword">if</span> i == <span class="number">4</span>:</span><br><span class="line">        all_instead_five += arr[i][<span class="number">0</span>] * arr[i][<span class="number">1</span>] * (box_need_five[i] + <span class="number">22</span>)</span><br><span class="line">    <span class="keyword">elif</span> i == <span class="number">5</span>:</span><br><span class="line">        all_instead_five += arr[i][<span class="number">0</span>] * arr[i][<span class="number">1</span>] * (box_need_five[i] - <span class="number">22</span>)</span><br><span class="line">    <span class="keyword">elif</span> i == <span class="number">10</span>:</span><br><span class="line">        all_instead_five += arr[i][<span class="number">0</span>] * arr[i][<span class="number">1</span>] * (box_need_five[i] + <span class="number">4</span>)</span><br><span class="line">    <span class="keyword">elif</span> i == <span class="number">11</span>:</span><br><span class="line">        all_instead_five += arr[i][<span class="number">0</span>] * arr[i][<span class="number">1</span>] * (box_need_five[i] - <span class="number">4</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        all_instead_five += arr[i][<span class="number">0</span>] * arr[i][<span class="number">1</span>] * box_need_five[i]</span><br><span class="line">    delta_three.append(box_price_three[i] - q * arr[i][<span class="number">0</span>] * arr[i][<span class="number">1</span>] * <span class="number">1e-6</span>)</span><br><span class="line">    delta_five.append(box_price_five[i] - q * arr[i][<span class="number">0</span>] * arr[i][<span class="number">1</span>] * <span class="number">1e-6</span>)</span><br><span class="line">    all_five += arr[i][<span class="number">0</span>] * arr[i][<span class="number">1</span>] * box_need_five[i]</span><br><span class="line">    sum_five += box_need_five[i] * (box_price_five[i] - q * arr[i][<span class="number">0</span>] * arr[i][<span class="number">1</span>] * <span class="number">1e-6</span>)</span><br><span class="line">    all_three += arr[i][<span class="number">0</span>] * arr[i][<span class="number">1</span>] * box_need_three[i]</span><br><span class="line">    sum_three += box_need_three[i] * (box_price_three[i] - q * arr[i][<span class="number">0</span>] * arr[i][<span class="number">1</span>] * <span class="number">1e-6</span>)</span><br><span class="line"><span class="comment"># print(sum_three)</span></span><br><span class="line"><span class="comment"># print(all_three)</span></span><br><span class="line"><span class="comment"># print(sum_five)</span></span><br><span class="line"><span class="comment"># print(all_five)</span></span><br><span class="line"></span><br><span class="line">Volume = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(box)):</span><br><span class="line">    Volume.append(box[i][<span class="number">0</span>] * box[i][<span class="number">1</span>] * box[i][<span class="number">2</span>])</span><br><span class="line"><span class="comment"># print(Volume)</span></span><br><span class="line"></span><br><span class="line">instead = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(Volume)):</span><br><span class="line">    temp = []</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(i):</span><br><span class="line">        <span class="keyword">if</span> (Volume[j] - Volume[i]) / Volume[j] &lt; <span class="number">0.3</span>:</span><br><span class="line">            temp.append(j)</span><br><span class="line">    instead.append(temp)</span><br><span class="line"><span class="comment"># print(instead)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># print(delta_three)</span></span><br><span class="line"><span class="comment"># print(delta_five)</span></span><br><span class="line">print(all_instead_three)</span><br><span class="line">print(all_instead_five)</span><br></pre></td></tr></table></figure>

</div></div>
<h3 id="问题一线性规划模型相关python代码-FirstProblemSolve-py"><a href="#问题一线性规划模型相关python代码-FirstProblemSolve-py" class="headerlink" title="问题一线性规划模型相关python代码 FirstProblemSolve.py"></a>问题一线性规划模型相关python代码 FirstProblemSolve.py</h3><div><div class="fold_hider"><div class="close hider_title"></div></div><div class="fold">
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pulp <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">size = &#123;<span class="string">'x1'</span>: <span class="number">2500</span>, <span class="string">'x2'</span>: <span class="number">2500</span>, <span class="string">'x3'</span>: <span class="number">2500</span>, <span class="string">'x4'</span>: <span class="number">2500</span>, <span class="string">'x5'</span>: <span class="number">2000</span>, <span class="string">'x6'</span>: <span class="number">2000</span>, <span class="string">'x7'</span>: <span class="number">2000</span>, <span class="string">'x8'</span>: <span class="number">1800</span>,</span><br><span class="line">        <span class="string">'x9'</span>: <span class="number">1800</span>, <span class="string">'x10'</span>: <span class="number">1800</span>, <span class="string">'x11'</span>: <span class="number">1800</span>, <span class="string">'x12'</span>: <span class="number">1500</span>, <span class="string">'x13'</span>: <span class="number">1500</span>, <span class="string">'x14'</span>: <span class="number">2000</span>, <span class="string">'x15'</span>: <span class="number">1800</span>, <span class="string">'x16'</span>: <span class="number">2000</span>&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solve</span><span class="params">(con, all_need, sum_get, c)</span>:</span></span><br><span class="line">    prob = LpProblem(<span class="string">'myPro'</span>, LpMinimize)</span><br><span class="line">    x1 = LpVariable(<span class="string">'x1'</span>, lowBound=<span class="number">0</span>, cat=<span class="string">'Integer'</span>)</span><br><span class="line">    x2 = LpVariable(<span class="string">'x2'</span>, lowBound=<span class="number">0</span>, cat=<span class="string">'Integer'</span>)</span><br><span class="line">    x3 = LpVariable(<span class="string">'x3'</span>, lowBound=<span class="number">0</span>, cat=<span class="string">'Integer'</span>)</span><br><span class="line">    x4 = LpVariable(<span class="string">'x4'</span>, lowBound=<span class="number">0</span>, cat=<span class="string">'Integer'</span>)</span><br><span class="line">    x5 = LpVariable(<span class="string">'x5'</span>, lowBound=<span class="number">0</span>, cat=<span class="string">'Integer'</span>)</span><br><span class="line">    x6 = LpVariable(<span class="string">'x6'</span>, lowBound=<span class="number">0</span>, cat=<span class="string">'Integer'</span>)</span><br><span class="line">    x7 = LpVariable(<span class="string">'x7'</span>, lowBound=<span class="number">0</span>, cat=<span class="string">'Integer'</span>)</span><br><span class="line">    x8 = LpVariable(<span class="string">'x8'</span>, lowBound=<span class="number">0</span>, cat=<span class="string">'Integer'</span>)</span><br><span class="line">    x9 = LpVariable(<span class="string">'x9'</span>, lowBound=<span class="number">0</span>, cat=<span class="string">'Integer'</span>)</span><br><span class="line">    x10 = LpVariable(<span class="string">'x10'</span>, lowBound=<span class="number">0</span>, cat=<span class="string">'Integer'</span>)</span><br><span class="line">    x11 = LpVariable(<span class="string">'x11'</span>, lowBound=<span class="number">0</span>, cat=<span class="string">'Integer'</span>)</span><br><span class="line">    x12 = LpVariable(<span class="string">'x12'</span>, lowBound=<span class="number">0</span>, cat=<span class="string">'Integer'</span>)</span><br><span class="line">    x13 = LpVariable(<span class="string">'x13'</span>, lowBound=<span class="number">0</span>, cat=<span class="string">'Integer'</span>)</span><br><span class="line">    x14 = LpVariable(<span class="string">'x14'</span>, lowBound=<span class="number">0</span>, cat=<span class="string">'Integer'</span>)</span><br><span class="line">    x15 = LpVariable(<span class="string">'x15'</span>, lowBound=<span class="number">0</span>, cat=<span class="string">'Integer'</span>)</span><br><span class="line">    x16 = LpVariable(<span class="string">'x16'</span>, lowBound=<span class="number">0</span>, cat=<span class="string">'Integer'</span>)</span><br><span class="line">    X = [x1, x2, x3, x4, x5, x6, x7, x8,</span><br><span class="line">         x9, x10, x11, x12, x13, x14, x15, x16]</span><br><span class="line"></span><br><span class="line">    z = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(X)):</span><br><span class="line">        z += X[i] * c[i]</span><br><span class="line">    prob += z</span><br><span class="line"></span><br><span class="line">    prob += <span class="number">2</span> * x1 + <span class="number">2</span> * x14 &gt;= con[<span class="number">0</span>]</span><br><span class="line">    prob += <span class="number">2</span> * x2 + <span class="number">2</span> * x15 &gt;= con[<span class="number">1</span>]</span><br><span class="line">    prob += <span class="number">3</span> * x3 + <span class="number">2</span> * x16 &gt;= con[<span class="number">2</span>]</span><br><span class="line">    prob += <span class="number">3</span> * x5 + <span class="number">3</span> * x7 + <span class="number">2</span> * x13 &gt;= con[<span class="number">3</span>]</span><br><span class="line">    prob += <span class="number">4</span> * x2 + <span class="number">3</span> * x5 + <span class="number">2</span> * x11 &gt;= con[<span class="number">4</span>]</span><br><span class="line">    prob += <span class="number">15</span> * x4 + <span class="number">6</span> * x6 &gt;= con[<span class="number">5</span>]</span><br><span class="line">    prob += <span class="number">3</span> * x3 + <span class="number">6</span> * x8 + <span class="number">4</span> * x11 + <span class="number">4</span> * x16 &gt;= con[<span class="number">6</span>]</span><br><span class="line">    prob += x2 + x5 + <span class="number">2</span> * x6 + <span class="number">2</span> * x8 + <span class="number">10</span> * x9 &gt;= con[<span class="number">7</span>]</span><br><span class="line">    prob += <span class="number">12</span> * x3 + <span class="number">15</span> * x10 + <span class="number">3</span> * x16 &gt;= con[<span class="number">8</span>]</span><br><span class="line">    prob += <span class="number">8</span> * x1 + <span class="number">6</span> * x6 + <span class="number">5</span> * x8 + <span class="number">6</span> * x9 + <span class="number">8</span> * x12 + <span class="number">3</span> * x14 + x16 &gt;= con[<span class="number">9</span>]</span><br><span class="line">    prob += <span class="number">11</span> * x2 + <span class="number">14</span> * x7 + x8 + <span class="number">2</span> * x12 &gt;= con[<span class="number">10</span>]</span><br><span class="line">    prob += <span class="number">14</span> * x1 + x3 + <span class="number">8</span> * x11 + <span class="number">6</span> * x12 + <span class="number">6</span> * x13 + <span class="number">7</span> * x15 &gt;= con[<span class="number">11</span>]</span><br><span class="line"></span><br><span class="line">    status = prob.solve()</span><br><span class="line">    print(<span class="string">'总利润：'</span>, sum_get - value(prob.objective))  <span class="comment"># 计算结果</span></span><br><span class="line">    sum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> prob.variables():</span><br><span class="line">        sum += size[i.name] * size[i.name] * i.varValue</span><br><span class="line">        print(i.name, <span class="string">": "</span>, i.varValue)</span><br><span class="line">    print(<span class="string">'需要面积：'</span>, all_need)</span><br><span class="line">    print(<span class="string">'使用面积：'</span>, sum)</span><br><span class="line">    print(<span class="string">'利用率：'</span>, all_need / sum)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">c_three = [<span class="number">1.25</span>, <span class="number">1.25</span>, <span class="number">1.25</span>, <span class="number">1.25</span>, <span class="number">0.9</span>, <span class="number">0.9</span>, <span class="number">0.9</span>, <span class="number">0.264</span>,</span><br><span class="line">           <span class="number">0.264</span>, <span class="number">0.264</span>, <span class="number">0.264</span>, <span class="number">0.85</span>, <span class="number">0.85</span>, <span class="number">0.9</span>, <span class="number">0.264</span>, <span class="number">0.9</span>]</span><br><span class="line">c_five = [<span class="number">4.25</span>, <span class="number">4.25</span>, <span class="number">4.25</span>, <span class="number">4.25</span>, <span class="number">2.8500000000000014</span>, <span class="number">2.8500000000000014</span>, <span class="number">2.8500000000000014</span>, <span class="number">1.7040000000000006</span>, <span class="number">1.7040000000000006</span>, <span class="number">1.7040000000000006</span>,</span><br><span class="line">          <span class="number">1.7040000000000006</span>, <span class="number">2.0500000000000003</span>, <span class="number">2.0500000000000003</span>, <span class="number">2.8500000000000014</span>, <span class="number">1.7040000000000006</span>, <span class="number">2.8500000000000014</span>]</span><br><span class="line">con_three = [<span class="number">40</span>, <span class="number">67</span>, <span class="number">86</span>, <span class="number">89</span>, <span class="number">108</span>, <span class="number">111</span>,</span><br><span class="line">             <span class="number">123</span>, <span class="number">129</span>, <span class="number">140</span>, <span class="number">110</span>, <span class="number">96</span>, <span class="number">84</span>]</span><br><span class="line">con_five = [<span class="number">85</span>, <span class="number">95</span>, <span class="number">80</span>, <span class="number">75</span>, <span class="number">70</span>, <span class="number">82</span>,</span><br><span class="line">            <span class="number">76</span>, <span class="number">79</span>, <span class="number">69</span>, <span class="number">60</span>, <span class="number">65</span>, <span class="number">78</span>]</span><br><span class="line">all_need_three = <span class="number">508707600</span></span><br><span class="line">sum_get_three = <span class="number">347.23936000000003</span></span><br><span class="line">all_need_five = <span class="number">516965500</span></span><br><span class="line">sum_get_five = <span class="number">606.6283</span></span><br><span class="line">print(<span class="string">"三层："</span>)</span><br><span class="line">solve(con_three, all_need_three, sum_get_three, c_three)</span><br><span class="line">print(<span class="string">"\n"</span>)</span><br><span class="line">print(<span class="string">"五层："</span>)</span><br><span class="line">solve(con_five, all_need_five, sum_get_five, c_five)</span><br></pre></td></tr></table></figure>

</div></div>
<h3 id="问题一遗传算法模型相关javascript代码-GA-html"><a href="#问题一遗传算法模型相关javascript代码-GA-html" class="headerlink" title="问题一遗传算法模型相关javascript代码 GA.html"></a>问题一遗传算法模型相关javascript代码 GA.html</h3><div><div class="fold_hider"><div class="close hider_title"></div></div><div class="fold">
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE &gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>/&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">id</span>=<span class="string">"button"</span>&gt;</span>计算结果<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="actionscript">			<span class="keyword">var</span> totalNum = <span class="number">50</span>, <span class="comment">// 种群中染色体的总数</span></span></span><br><span class="line"><span class="actionscript">			width=<span class="number">2500</span>,<span class="comment">//毛坯的宽</span></span></span><br><span class="line"><span class="actionscript">			length=<span class="number">2500</span>,<span class="comment">//毛坯的长</span></span></span><br><span class="line"><span class="actionscript">			N,<span class="comment">//记录需要的毛坯数量</span></span></span><br><span class="line"><span class="actionscript">            bit = <span class="number">1183</span>, <span class="comment">// 基因数为20位</span></span></span><br><span class="line"><span class="javascript">            total = <span class="keyword">new</span> <span class="built_in">Array</span>(); <span class="comment">// 种群中的染色体</span></span></span><br><span class="line"><span class="actionscript">            bestFitness = <span class="number">0</span>, <span class="comment">// 最佳适应值</span></span></span><br><span class="line"><span class="actionscript">            generation = <span class="number">0</span>, <span class="comment">// 染色体代号</span></span></span><br><span class="line"><span class="actionscript">            bestGeneration = <span class="number">0</span>, <span class="comment">// 最好的一旦染色体代号</span></span></span><br><span class="line"><span class="actionscript">            bestStr = <span class="string">''</span>; <span class="comment">// 最好的染色体基因序列</span></span></span><br><span class="line"><span class="actionscript">            <span class="keyword">var</span> size=[[<span class="number">1660</span>, <span class="number">970</span>], [<span class="number">1540</span>, <span class="number">770</span>], [<span class="number">1280</span>, <span class="number">690</span>], [<span class="number">1080</span>, <span class="number">610</span>], [<span class="number">920</span>, <span class="number">530</span>], [<span class="number">800</span>, <span class="number">480</span>], </span></span><br><span class="line"><span class="actionscript"> [<span class="number">720</span>, <span class="number">420</span>], [<span class="number">640</span>, <span class="number">360</span>], [<span class="number">600</span>, <span class="number">345</span>], [<span class="number">540</span>, <span class="number">305</span>], [<span class="number">460</span>, <span class="number">275</span>], [<span class="number">420</span>, <span class="number">250</span>]];<span class="comment">//记录小矩形块的长宽</span></span></span><br><span class="line"><span class="actionscript">            <span class="keyword">var</span> num=[<span class="number">40</span>, <span class="number">67</span>, <span class="number">86</span>, <span class="number">89</span>, <span class="number">108</span>, <span class="number">111</span>,</span></span><br><span class="line"><span class="actionscript">                  <span class="number">123</span>, <span class="number">129</span>, <span class="number">140</span>, <span class="number">110</span>, <span class="number">96</span>, <span class="number">84</span>]; <span class="comment">//记录小矩形块的需求数量</span></span></span><br><span class="line"><span class="actionscript">            <span class="keyword">var</span> sizeTotal = [];</span></span><br><span class="line"><span class="actionscript">            <span class="comment">/*将基因组对应的小矩形块的长宽记录下来*/</span></span></span><br><span class="line"><span class="actionscript">            <span class="keyword">var</span> cnt = <span class="number">0</span>;</span></span><br><span class="line"><span class="actionscript">			<span class="keyword">var</span> sum = <span class="number">0</span>;</span></span><br><span class="line"><span class="actionscript">            <span class="keyword">var</span> pre = [];</span></span><br><span class="line"><span class="actionscript">            <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; num.length; ++i) &#123;</span></span><br><span class="line"><span class="actionscript">                <span class="keyword">for</span>(<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; num[i]; ++j) &#123;</span></span><br><span class="line">                    sizeTotal.push(size[i]);</span><br><span class="line">                    pre.push(i);</span><br><span class="line">                &#125;</span><br><span class="line">				sum += size[i][0] * size[i][1] * num[i];</span><br><span class="line">            &#125;</span><br><span class="line"><span class="actionscript">            <span class="comment">/*初始化一条染色体*/</span></span></span><br><span class="line"><span class="actionscript">            <span class="function"><span class="keyword">function</span> <span class="title">initChar</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">				<span class="keyword">var</span> arr = [];</span></span><br><span class="line"><span class="actionscript">        		<span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;bit;i++)&#123;</span></span><br><span class="line">            		getx(arr);</span><br><span class="line">        		&#125;	</span><br><span class="line"><span class="actionscript">        		<span class="function"><span class="keyword">function</span> <span class="title">getx</span><span class="params">(arr)</span></span>&#123;</span></span><br><span class="line"><span class="actionscript">            		<span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&gt;<span class="number">-1</span>;i++)&#123;</span></span><br><span class="line"><span class="actionscript">                		<span class="keyword">var</span> flag = <span class="literal">true</span>;</span></span><br><span class="line"><span class="javascript">                		<span class="keyword">var</span> num = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random()*sizeTotal.length);</span></span><br><span class="line"><span class="actionscript">                		<span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">in</span> arr)&#123;</span></span><br><span class="line">                    		if(arr[i] == num)&#123;</span><br><span class="line"><span class="actionscript">                        		flag= <span class="literal">false</span>;</span></span><br><span class="line"><span class="actionscript">                        		<span class="keyword">break</span>;</span></span><br><span class="line">                    		&#125;</span><br><span class="line">                		&#125;</span><br><span class="line"><span class="actionscript">                		<span class="keyword">if</span>(flag == <span class="literal">true</span>)&#123;</span></span><br><span class="line">                    	arr.push(num);</span><br><span class="line"><span class="actionscript">                    	<span class="keyword">return</span>;</span></span><br><span class="line">                		&#125;</span><br><span class="line">            		&#125;</span><br><span class="line"><span class="actionscript">        		&#125;<span class="keyword">return</span> arr;</span></span><br><span class="line">        	&#125;</span><br><span class="line"><span class="actionscript">            <span class="comment">/*初始化一个种群*/</span></span></span><br><span class="line"><span class="actionscript">            <span class="function"><span class="keyword">function</span> <span class="title">initTotal</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">	            <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;totalNum;i++)&#123;</span></span><br><span class="line">	                total[i] = initChar();</span><br><span class="line">	            &#125;</span><br><span class="line"><span class="actionscript">	            <span class="keyword">return</span> total;</span></span><br><span class="line">	        &#125;</span><br><span class="line">            </span><br><span class="line"><span class="actionscript">            <span class="comment">/*找出数组中的最大值*/</span></span></span><br><span class="line"><span class="actionscript">			<span class="function"><span class="keyword">function</span> <span class="title">findMax</span><span class="params">(tmp)</span></span>&#123;</span></span><br><span class="line"><span class="actionscript">				<span class="keyword">var</span> max = tmp[<span class="number">0</span>];</span></span><br><span class="line"><span class="actionscript">				<span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">1</span>;i&lt;tmp.length;i++)&#123; </span></span><br><span class="line">					if(max&lt;=tmp[i])&#123;</span><br><span class="line">						max=tmp[i];</span><br><span class="line">					&#125;</span><br><span class="line"><span class="actionscript">				&#125;<span class="keyword">return</span> max;</span></span><br><span class="line">	       	&#125;</span><br><span class="line">			</span><br><span class="line"><span class="actionscript">			<span class="comment">/*找出数组中的最小值*/</span></span></span><br><span class="line"><span class="actionscript">			<span class="function"><span class="keyword">function</span> <span class="title">findMin</span><span class="params">(tmp)</span></span>&#123;</span></span><br><span class="line"><span class="actionscript">	        	<span class="keyword">var</span> min=tmp[<span class="number">0</span>];</span></span><br><span class="line"><span class="actionscript">	        	<span class="keyword">var</span> index=<span class="number">0</span>;</span></span><br><span class="line"><span class="actionscript">	        	<span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">1</span>;i&lt;tmp.length;i++)&#123;</span></span><br><span class="line">	        		if(min&gt;tmp[i])&#123;</span><br><span class="line">	        			min=tmp[i];</span><br><span class="line">	        			index=i;</span><br><span class="line">	        		&#125;</span><br><span class="line">	        	&#125;</span><br><span class="line"><span class="actionscript">	        	<span class="keyword">return</span> min;</span></span><br><span class="line">	        &#125;</span><br><span class="line">			</span><br><span class="line"><span class="actionscript">			<span class="comment">/*找出数组中最小值的index*/</span></span></span><br><span class="line"><span class="actionscript">			<span class="function"><span class="keyword">function</span> <span class="title">findMaxIndex</span><span class="params">(tmp)</span></span>&#123;</span></span><br><span class="line"><span class="actionscript">	        	<span class="keyword">var</span> max=tmp[<span class="number">0</span>];</span></span><br><span class="line"><span class="actionscript">	        	<span class="keyword">var</span> index=<span class="number">0</span>;</span></span><br><span class="line"><span class="actionscript">	        	<span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">1</span>;i&lt;tmp.length;i++)&#123;</span></span><br><span class="line">	        		if(max&lt;tmp[i])&#123;</span><br><span class="line">	        			max=tmp[i];</span><br><span class="line">	        			index=i;</span><br><span class="line">	        		&#125;</span><br><span class="line">	        	&#125;</span><br><span class="line"><span class="actionscript">	        	<span class="keyword">return</span> index;</span></span><br><span class="line">	        &#125;</span><br><span class="line">			</span><br><span class="line"><span class="actionscript">			<span class="comment">/*计算适应度函数（也是直接计算需要的矩形块数量）*/</span></span></span><br><span class="line"><span class="actionscript">			<span class="function"><span class="keyword">function</span> <span class="title">calculateFitness</span><span class="params">(arr)</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">				<span class="keyword">var</span> newArr=[];<span class="comment">//记录每一行的矩形块的宽</span></span></span><br><span class="line"><span class="actionscript">	            <span class="keyword">var</span> addLenght=<span class="number">0</span>;<span class="comment">//累计长</span></span></span><br><span class="line"><span class="actionscript">	            <span class="keyword">var</span> remLength=<span class="number">0</span>;<span class="comment">//剩余长</span></span></span><br><span class="line"><span class="actionscript">				<span class="keyword">var</span> fitness=<span class="number">0</span>;</span></span><br><span class="line"><span class="actionscript">				<span class="keyword">var</span> n=<span class="number">0</span>;<span class="comment">//累计在出现addLenght&gt;length的情况时i循环的次数的个数</span></span></span><br><span class="line"><span class="actionscript">				<span class="keyword">var</span> neededNum=<span class="number">0</span>;</span></span><br><span class="line"><span class="actionscript">	            <span class="keyword">var</span> index1,index2;</span></span><br><span class="line"><span class="actionscript">	            <span class="keyword">var</span> count=<span class="number">0</span>;<span class="comment">//记录是否出现每行的remLenth还能再放一个矩形块的情况</span></span></span><br><span class="line"><span class="actionscript">                <span class="keyword">var</span> <span class="keyword">use</span> = <span class="number">0</span>;</span></span><br><span class="line"><span class="actionscript">				<span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span></span><br><span class="line"><span class="actionscript">                    <span class="keyword">use</span> += sizeTotal[arr[i]][<span class="number">0</span>] * sizeTotal[arr[i]][<span class="number">1</span>];</span></span><br><span class="line">	            	addLenght+=sizeTotal[arr[i]][0];</span><br><span class="line">	            	n++;</span><br><span class="line">	            	if(addLenght&gt;length)&#123;</span><br><span class="line">	            		if(i&lt;n)&#123;</span><br><span class="line"><span class="actionscript">	            			<span class="keyword">for</span>(<span class="keyword">var</span> j=<span class="number">0</span>;j&lt;i;j++)&#123;</span></span><br><span class="line">				            	newArr[j]=sizeTotal[arr[j]][1];</span><br><span class="line">				            &#125;</span><br><span class="line"><span class="actionscript">	            		&#125;<span class="keyword">else</span>&#123;</span></span><br><span class="line"><span class="actionscript">	            			<span class="keyword">for</span>(<span class="keyword">var</span> j=<span class="number">0</span>;j&lt;i;j++)&#123;</span></span><br><span class="line">				            	newArr[j]=sizeTotal[arr[j]][1];</span><br><span class="line">				            &#125;</span><br><span class="line"><span class="actionscript">	            			<span class="keyword">for</span>(<span class="keyword">var</span> a=<span class="number">0</span>;a&lt;i-n;a++)&#123;</span></span><br><span class="line">				            	newArr.shift();</span><br><span class="line">				            &#125;</span><br><span class="line">	            		&#125;</span><br><span class="line">	            		remLength=length+sizeTotal[arr[i]][0]-addLenght;</span><br><span class="line">	            		if(remLength&gt;5)&#123;</span><br><span class="line"><span class="actionscript">	            			outerMost:<span class="comment">//定义外层循环</span></span></span><br><span class="line"><span class="actionscript">	            			<span class="keyword">for</span>(<span class="keyword">var</span> m=i;m&lt;arr.length;m++)&#123;</span></span><br><span class="line"><span class="actionscript">	            				<span class="keyword">for</span>(<span class="keyword">var</span> h=<span class="number">0</span>;h&lt;<span class="number">2</span>;h++)&#123;</span></span><br><span class="line">	            					if( sizeTotal[arr[m]][h] &lt;= remLength)&#123;</span><br><span class="line">	            						index1=m;</span><br><span class="line">		            					index2=h;</span><br><span class="line">					            		count=1;</span><br><span class="line">					            		if(index2==0)&#123;</span><br><span class="line">					            			newArr.push(sizeTotal[arr[index1]][1]);</span><br><span class="line"><span class="actionscript">					            		&#125;<span class="keyword">else</span>&#123;</span></span><br><span class="line">					            			newArr.push(sizeTotal[arr[index1]][0]);</span><br><span class="line">					            		&#125;</span><br><span class="line">					            		if(index1!=i)&#123;</span><br><span class="line">					            			arr.splice(i,0,arr[index1]);</span><br><span class="line">					            			arr.splice(index1+1,1);</span><br><span class="line">					            		&#125;</span><br><span class="line">					            		if(i&lt;arr.length-1)&#123;</span><br><span class="line">					        				i++;</span><br><span class="line">					            		&#125;</span><br><span class="line"><span class="actionscript">		            					<span class="keyword">break</span> outerMost;<span class="comment">//终止外层循环</span></span></span><br><span class="line">	            					&#125;</span><br><span class="line">	            				&#125;</span><br><span class="line">	            			&#125;</span><br><span class="line">	            		&#125;</span><br><span class="line">			            fitness+=findMax(newArr);</span><br><span class="line">	            		addLenght=sizeTotal[arr[i]][0];</span><br><span class="line">	            		n=0;</span><br><span class="line">	            	&#125;</span><br><span class="line"><span class="actionscript">	            	<span class="keyword">var</span> newArrRest=[];<span class="comment">//储存排在最后一行的矩形块的宽</span></span></span><br><span class="line">	            	if(i==arr.length-1)&#123;</span><br><span class="line">						if(count==0)&#123;</span><br><span class="line"><span class="actionscript">							<span class="keyword">for</span>(<span class="keyword">var</span> z=<span class="number">0</span>;z&lt;arr.length;z++)&#123;</span></span><br><span class="line">								newArrRest[z]=sizeTotal[arr[z]][1];</span><br><span class="line">							&#125;</span><br><span class="line"><span class="actionscript">							<span class="keyword">for</span>(<span class="keyword">var</span> b=<span class="number">0</span>;b&lt;i-n;b++)&#123;</span></span><br><span class="line">								newArrRest.shift();</span><br><span class="line">							&#125;							</span><br><span class="line">							fitness+=findMax(newArrRest);</span><br><span class="line"><span class="actionscript">						&#125;<span class="keyword">else</span>&#123;</span></span><br><span class="line"><span class="actionscript">							<span class="keyword">for</span>(<span class="keyword">var</span> z=<span class="number">0</span>;z&lt;arr.length;z++)&#123;</span></span><br><span class="line">								newArrRest[z]=sizeTotal[arr[z]][1];</span><br><span class="line">							&#125;</span><br><span class="line"><span class="actionscript">							<span class="keyword">for</span>(<span class="keyword">var</span> b=<span class="number">0</span>;b&lt;i-n<span class="number">-1</span>;b++)&#123;</span></span><br><span class="line">								newArrRest.shift();</span><br><span class="line">							&#125;							</span><br><span class="line">							fitness+=findMax(newArrRest);</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">	            	if(fitness&gt;width)&#123;</span><br><span class="line">	            		neededNum++;</span><br><span class="line">	            		fitness=findMax(newArr);</span><br><span class="line"><span class="actionscript">                        <span class="keyword">break</span>;</span></span><br><span class="line">					&#125;</span><br><span class="line">	            	count=0;</span><br><span class="line">	            &#125;</span><br><span class="line"><span class="actionscript">	          	<span class="keyword">return</span> (length * width) / <span class="keyword">use</span>;</span></span><br><span class="line">	        &#125;</span><br><span class="line">			</span><br><span class="line"><span class="actionscript">			<span class="comment">/*轮盘赌选择*/</span></span></span><br><span class="line"><span class="actionscript">			<span class="function"><span class="keyword">function</span> <span class="title">select</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">	            <span class="keyword">var</span> evals = <span class="keyword">new</span> <span class="built_in">Array</span>(totalNum); <span class="comment">// 所有染色体适应值 </span></span></span><br><span class="line"><span class="javascript">	            <span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Array</span>(totalNum); <span class="comment">// 各染色体选择概率</span></span></span><br><span class="line"><span class="javascript">	            <span class="keyword">var</span> q = <span class="keyword">new</span> <span class="built_in">Array</span>(totalNum); <span class="comment">// 累计概率</span></span></span><br><span class="line"><span class="actionscript">	            <span class="keyword">var</span> F = <span class="number">0</span>; <span class="comment">// 累计适应值总合</span></span></span><br><span class="line"><span class="actionscript">	            <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;totalNum;i++)&#123; <span class="comment">// 记录下种群的最优解</span></span></span><br><span class="line">	                evals[i] = calculateFitness(total[i]);</span><br><span class="line">	                if(evals[i] &gt; bestFitness) &#123;</span><br><span class="line">	                    bestFitness = evals[i];</span><br><span class="line">	                    bestStr = total[i];</span><br><span class="line">	                &#125;</span><br><span class="line">	                F += evals[i];</span><br><span class="line">	            &#125;</span><br><span class="line"><span class="actionscript">	            <span class="keyword">for</span>(<span class="keyword">var</span> j=<span class="number">0</span>;j&lt;totalNum;j++)&#123; <span class="comment">// 计算累计概率</span></span></span><br><span class="line">	                p[j] = evals[j]/F;</span><br><span class="line">	                if(j == 0)&#123;</span><br><span class="line">	                    q[j] = p[j];</span><br><span class="line">	                &#125;</span><br><span class="line"><span class="actionscript">	                <span class="keyword">else</span>&#123;</span></span><br><span class="line">	                    q[j]=q[j-1]+p[j];</span><br><span class="line">	                &#125;</span><br><span class="line">	            &#125;</span><br><span class="line"><span class="javascript">	            <span class="keyword">var</span> temp = <span class="keyword">new</span> <span class="built_in">Array</span>(totalNum);</span></span><br><span class="line"><span class="actionscript">	            <span class="keyword">for</span>(<span class="keyword">var</span> k=<span class="number">0</span>;k&lt;totalNum;k++)&#123; <span class="comment">//</span></span></span><br><span class="line"><span class="javascript">	                <span class="keyword">var</span> r = <span class="built_in">Math</span>.random();</span></span><br><span class="line">	                if(r &lt;= q[0])&#123;</span><br><span class="line">	                    temp = total[0];</span><br><span class="line"><span class="actionscript">	                    <span class="keyword">break</span>;</span></span><br><span class="line">	                &#125;</span><br><span class="line"><span class="actionscript">	                <span class="keyword">else</span>&#123;</span></span><br><span class="line"><span class="actionscript">	                    <span class="keyword">for</span>(<span class="keyword">var</span> z=<span class="number">1</span>;z&lt;totalNum;z++)&#123;</span></span><br><span class="line">	                        if(r&lt;q[z])&#123;</span><br><span class="line">	                            temp = total[z];</span><br><span class="line"><span class="actionscript">	                            <span class="keyword">break</span>;</span></span><br><span class="line">	                        &#125;</span><br><span class="line">	                    &#125;</span><br><span class="line">	                &#125;</span><br><span class="line">	            &#125;</span><br><span class="line"><span class="actionscript">	            <span class="keyword">return</span> temp;</span></span><br><span class="line">	        &#125;</span><br><span class="line">			</span><br><span class="line">			</span><br><span class="line">			/*染色体交叉</span><br><span class="line">			 *交叉概率为70%</span><br><span class="line">			 */</span><br><span class="line"><span class="actionscript">			<span class="function"><span class="keyword">function</span> <span class="title">jiaocha</span><span class="params">(population1,population2)</span></span>&#123;</span></span><br><span class="line"><span class="javascript">				<span class="keyword">var</span> returnPopulation1 = <span class="keyword">new</span> <span class="built_in">Array</span>(bit);</span></span><br><span class="line"><span class="javascript">				<span class="keyword">var</span> returnPopulation2 = <span class="keyword">new</span> <span class="built_in">Array</span>(bit);</span></span><br><span class="line"><span class="javascript">				<span class="keyword">var</span> temp=<span class="built_in">Math</span>.random();</span></span><br><span class="line">				if(temp&lt;0.7)&#123;</span><br><span class="line"><span class="actionscript">					<span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;bit;i++)&#123;</span></span><br><span class="line">						if(i&lt;bit-2)&#123;</span><br><span class="line">							returnPopulation1[i]=population1[i];</span><br><span class="line">							returnPopulation2[i]=population2[i];</span><br><span class="line"><span class="actionscript">						&#125;<span class="keyword">else</span>&#123;</span></span><br><span class="line">							returnPopulation1[i]=population2[i];</span><br><span class="line">							returnPopulation2[i]=population1[i];</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line"><span class="actionscript">					<span class="comment">//找出重合的基因,并将相同基因改正</span></span></span><br><span class="line"><span class="actionscript">					<span class="keyword">for</span>(<span class="keyword">var</span> j=bit<span class="number">-1</span>;j&gt;bit<span class="number">-3</span>;j--)&#123;</span></span><br><span class="line"><span class="actionscript">						<span class="keyword">for</span>(<span class="keyword">var</span> k=<span class="number">0</span>;k&lt;bit<span class="number">-2</span>;k++)&#123;</span></span><br><span class="line">							if(returnPopulation1[k]==returnPopulation1[j])&#123;</span><br><span class="line">								returnPopulation1[k]=returnPopulation2[j];</span><br><span class="line">							&#125;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line"><span class="actionscript">				&#125;<span class="keyword">else</span>&#123;</span></span><br><span class="line">					returnPopulation1=population1;</span><br><span class="line">					returnPopulation2=population2;</span><br><span class="line">				&#125;</span><br><span class="line"><span class="actionscript">				<span class="keyword">return</span> returnPopulation1;</span></span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line"><span class="actionscript">			<span class="comment">/*染色体变异*/</span></span></span><br><span class="line"><span class="actionscript">			<span class="function"><span class="keyword">function</span> <span class="title">change</span><span class="params">(arr)</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">	            <span class="keyword">if</span>(<span class="built_in">Math</span>.random()&lt;<span class="number">0.1</span>)&#123;</span></span><br><span class="line"><span class="actionscript">	            	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span></span><br><span class="line"><span class="javascript">	            		<span class="keyword">var</span> temp1=<span class="built_in">parseInt</span>(<span class="built_in">Math</span>.random()*bit);</span></span><br><span class="line"><span class="javascript">	            		<span class="keyword">var</span> temp2=<span class="built_in">parseInt</span>(<span class="built_in">Math</span>.random()*bit);</span></span><br><span class="line">	            		if(temp1!=temp2)&#123;</span><br><span class="line"><span class="actionscript">	            			<span class="keyword">break</span>;</span></span><br><span class="line">	            		&#125;</span><br><span class="line">	            	&#125;</span><br><span class="line"><span class="actionscript">	            	<span class="keyword">var</span> temp=arr[temp1];</span></span><br><span class="line">	            	arr[temp1]=arr[temp2];</span><br><span class="line">	            	arr[temp2]=temp;</span><br><span class="line">	            &#125;</span><br><span class="line"><span class="actionscript">	            <span class="keyword">return</span> arr;</span></span><br><span class="line">	        &#125;</span><br><span class="line"><span class="actionscript">			<span class="comment">/*执行过程*/</span></span></span><br><span class="line"><span class="javascript">	        <span class="keyword">var</span> d1 = <span class="keyword">new</span> <span class="built_in">Date</span>();</span></span><br><span class="line"><span class="javascript">			<span class="built_in">document</span>.getElementById(<span class="string">'button'</span>).onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line">	            total = initTotal();</span><br><span class="line"><span class="actionscript">	            <span class="keyword">var</span> arr=[];</span></span><br><span class="line"><span class="actionscript">	            <span class="keyword">var</span> bestArr=[];</span></span><br><span class="line"><span class="actionscript">	            <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">10000</span>;i++)&#123;</span></span><br><span class="line">	            	bestArr[i]=change(jiaocha(select(),select()));</span><br><span class="line">	            	arr[i] = calculateFitness(bestArr[i]);</span><br><span class="line">	            &#125;</span><br><span class="line"><span class="actionscript">	            <span class="comment">//var minFitness=findMin(arr);</span></span></span><br><span class="line"><span class="actionscript">	            <span class="comment">//bestStr = bestArr[findMaxIndex(arr)];</span></span></span><br><span class="line"><span class="actionscript">	            <span class="comment">//console.log(bestStr);</span></span></span><br><span class="line"><span class="javascript">	            <span class="built_in">console</span>.log(<span class="number">1</span> / calculateFitness(bestStr));</span></span><br><span class="line"><span class="javascript">	            <span class="keyword">var</span> d2 = <span class="keyword">new</span> <span class="built_in">Date</span>();</span></span><br><span class="line"><span class="actionscript">	            <span class="keyword">var</span> time=d2-d1;</span></span><br><span class="line"><span class="javascript">	            <span class="built_in">console</span>.log(<span class="string">'一共执行了'</span>+time+<span class="string">'ms'</span>);</span></span><br><span class="line">	        &#125;</span><br><span class="line">		<span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

</div></div>
<h3 id="问题二线性规划模型相关python代码-SecondProblemSolve-py"><a href="#问题二线性规划模型相关python代码-SecondProblemSolve-py" class="headerlink" title="问题二线性规划模型相关python代码 SecondProblemSolve.py"></a>问题二线性规划模型相关python代码 SecondProblemSolve.py</h3><div><div class="fold_hider"><div class="close hider_title"></div></div><div class="fold">
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pulp <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">size = &#123;<span class="string">'x1'</span>: <span class="number">2500</span>, <span class="string">'x2'</span>: <span class="number">2500</span>, <span class="string">'x3'</span>: <span class="number">2500</span>, <span class="string">'x4'</span>: <span class="number">2500</span>, <span class="string">'x5'</span>: <span class="number">2000</span>, <span class="string">'x6'</span>: <span class="number">2000</span>, <span class="string">'x7'</span>: <span class="number">2000</span>, <span class="string">'x8'</span>: <span class="number">1800</span>,</span><br><span class="line">        <span class="string">'x9'</span>: <span class="number">1800</span>, <span class="string">'x10'</span>: <span class="number">1800</span>, <span class="string">'x11'</span>: <span class="number">1800</span>, <span class="string">'x12'</span>: <span class="number">1500</span>, <span class="string">'x13'</span>: <span class="number">1500</span>, <span class="string">'x14'</span>: <span class="number">2000</span>, <span class="string">'x15'</span>: <span class="number">1800</span>, <span class="string">'x16'</span>: <span class="number">2000</span>&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solve</span><span class="params">(con, all_need, sum_get, c, delta)</span>:</span></span><br><span class="line">    prob = LpProblem(<span class="string">'myPro'</span>, LpMinimize)</span><br><span class="line">    x1 = LpVariable(<span class="string">'x1'</span>, lowBound=<span class="number">0</span>, cat=<span class="string">'Integer'</span>)</span><br><span class="line">    x2 = LpVariable(<span class="string">'x2'</span>, lowBound=<span class="number">0</span>, cat=<span class="string">'Integer'</span>)</span><br><span class="line">    x3 = LpVariable(<span class="string">'x3'</span>, lowBound=<span class="number">0</span>, cat=<span class="string">'Integer'</span>)</span><br><span class="line">    x4 = LpVariable(<span class="string">'x4'</span>, lowBound=<span class="number">0</span>, cat=<span class="string">'Integer'</span>)</span><br><span class="line">    x5 = LpVariable(<span class="string">'x5'</span>, lowBound=<span class="number">0</span>, cat=<span class="string">'Integer'</span>)</span><br><span class="line">    x6 = LpVariable(<span class="string">'x6'</span>, lowBound=<span class="number">0</span>, cat=<span class="string">'Integer'</span>)</span><br><span class="line">    x7 = LpVariable(<span class="string">'x7'</span>, lowBound=<span class="number">0</span>, cat=<span class="string">'Integer'</span>)</span><br><span class="line">    x8 = LpVariable(<span class="string">'x8'</span>, lowBound=<span class="number">0</span>, cat=<span class="string">'Integer'</span>)</span><br><span class="line">    x9 = LpVariable(<span class="string">'x9'</span>, lowBound=<span class="number">0</span>, cat=<span class="string">'Integer'</span>)</span><br><span class="line">    x10 = LpVariable(<span class="string">'x10'</span>, lowBound=<span class="number">0</span>, cat=<span class="string">'Integer'</span>)</span><br><span class="line">    x11 = LpVariable(<span class="string">'x11'</span>, lowBound=<span class="number">0</span>, cat=<span class="string">'Integer'</span>)</span><br><span class="line">    x12 = LpVariable(<span class="string">'x12'</span>, lowBound=<span class="number">0</span>, cat=<span class="string">'Integer'</span>)</span><br><span class="line">    x13 = LpVariable(<span class="string">'x13'</span>, lowBound=<span class="number">0</span>, cat=<span class="string">'Integer'</span>)</span><br><span class="line">    x14 = LpVariable(<span class="string">'x14'</span>, lowBound=<span class="number">0</span>, cat=<span class="string">'Integer'</span>)</span><br><span class="line">    x15 = LpVariable(<span class="string">'x15'</span>, lowBound=<span class="number">0</span>, cat=<span class="string">'Integer'</span>)</span><br><span class="line">    x16 = LpVariable(<span class="string">'x16'</span>, lowBound=<span class="number">0</span>, cat=<span class="string">'Integer'</span>)</span><br><span class="line">    I56 = LpVariable(<span class="string">'I56'</span>, lowBound=<span class="number">0</span>, upBound=con[<span class="number">5</span>], cat=<span class="string">'Integer'</span>)</span><br><span class="line">    I67 = LpVariable(<span class="string">'I67'</span>, lowBound=<span class="number">0</span>, upBound=con[<span class="number">6</span>], cat=<span class="string">'Integer'</span>)</span><br><span class="line">    I89 = LpVariable(<span class="string">'I89'</span>, lowBound=<span class="number">0</span>, upBound=con[<span class="number">8</span>], cat=<span class="string">'Integer'</span>)</span><br><span class="line">    I1112 = LpVariable(<span class="string">'I1112'</span>, lowBound=<span class="number">0</span>, upBound=con[<span class="number">11</span>], cat=<span class="string">'Integer'</span>)</span><br><span class="line">    X = [x1, x2, x3, x4, x5, x6, x7, x8,</span><br><span class="line">         x9, x10, x11, x12, x13, x14, x15, x16]</span><br><span class="line"></span><br><span class="line">    z = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(c)):</span><br><span class="line">        z += X[i] * c[i]</span><br><span class="line">    z += I56 * (delta[<span class="number">5</span>] - delta[<span class="number">4</span>])</span><br><span class="line">    z += I67 * (delta[<span class="number">6</span>] - delta[<span class="number">5</span>])</span><br><span class="line">    z += I89 * (delta[<span class="number">8</span>] - delta[<span class="number">7</span>])</span><br><span class="line">    z += I1112 * (delta[<span class="number">11</span>] - delta[<span class="number">10</span>])</span><br><span class="line">    prob += z</span><br><span class="line"></span><br><span class="line">    prob += <span class="number">2</span> * x1 + <span class="number">2</span> * x14 &gt;= con[<span class="number">0</span>]</span><br><span class="line">    prob += <span class="number">2</span> * x2 + <span class="number">2</span> * x15 &gt;= con[<span class="number">1</span>]</span><br><span class="line">    prob += <span class="number">3</span> * x3 + <span class="number">2</span> * x16 &gt;= con[<span class="number">2</span>]</span><br><span class="line">    prob += <span class="number">3</span> * x5 + <span class="number">3</span> * x7 + <span class="number">2</span> * x13 &gt;= con[<span class="number">3</span>]</span><br><span class="line">    prob += <span class="number">4</span> * x2 + <span class="number">3</span> * x5 + <span class="number">2</span> * x11 - I56 &gt;= con[<span class="number">4</span>]</span><br><span class="line">    prob += <span class="number">15</span> * x4 + <span class="number">6</span> * x6 + I56 - I67 &gt;= con[<span class="number">5</span>]</span><br><span class="line">    prob += <span class="number">3</span> * x3 + <span class="number">6</span> * x8 + <span class="number">4</span> * x11 + <span class="number">4</span> * x16 + I67 &gt;= con[<span class="number">6</span>]</span><br><span class="line">    prob += x2 + x5 + <span class="number">2</span> * x6 + <span class="number">2</span> * x8 + <span class="number">10</span> * x9 - I89 &gt;= con[<span class="number">7</span>]</span><br><span class="line">    prob += <span class="number">12</span> * x3 + <span class="number">15</span> * x10 + <span class="number">3</span> * x16 + I89 &gt;= con[<span class="number">8</span>]</span><br><span class="line">    prob += <span class="number">8</span> * x1 + <span class="number">6</span> * x6 + <span class="number">5</span> * x8 + <span class="number">6</span> * x9 + <span class="number">8</span> * x12 + <span class="number">3</span> * x14 + x16 &gt;= con[<span class="number">9</span>]</span><br><span class="line">    prob += <span class="number">11</span> * x2 + <span class="number">14</span> * x7 + x8 + <span class="number">2</span> * x12 - I1112 &gt;= con[<span class="number">10</span>]</span><br><span class="line">    prob += <span class="number">14</span> * x1 + x3 + <span class="number">8</span> * x11 + <span class="number">6</span> * x12 + <span class="number">6</span> * x13 + <span class="number">7</span> * x15 + I1112 &gt;= con[<span class="number">11</span>]</span><br><span class="line"></span><br><span class="line">    status = prob.solve()</span><br><span class="line">    print(<span class="string">'总利润：'</span>, sum_get - value(prob.objective))  <span class="comment"># 计算结果</span></span><br><span class="line">    sum = <span class="number">0</span></span><br><span class="line">    cnt = <span class="number">0</span></span><br><span class="line">    all = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> prob.variables():</span><br><span class="line">        <span class="keyword">if</span> cnt &gt;= <span class="number">4</span>:</span><br><span class="line">            sum += size[i.name] * size[i.name] * i.varValue</span><br><span class="line">        print(i.name, <span class="string">": "</span>, i.varValue)</span><br><span class="line">        cnt += <span class="number">1</span></span><br><span class="line">    print(<span class="string">'需要面积：'</span>, all_need)</span><br><span class="line">    print(<span class="string">'使用面积：'</span>, sum)</span><br><span class="line">    print(<span class="string">'利用率：'</span>, all_need / sum)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">c_three = [<span class="number">1.25</span>, <span class="number">1.25</span>, <span class="number">1.25</span>, <span class="number">1.25</span>, <span class="number">0.9</span>, <span class="number">0.9</span>, <span class="number">0.9</span>, <span class="number">0.264</span>,</span><br><span class="line">           <span class="number">0.264</span>, <span class="number">0.264</span>, <span class="number">0.264</span>, <span class="number">0.85</span>, <span class="number">0.85</span>, <span class="number">0.9</span>, <span class="number">0.264</span>, <span class="number">0.9</span>]</span><br><span class="line">c_five = [<span class="number">4.25</span>, <span class="number">4.25</span>, <span class="number">4.25</span>, <span class="number">4.25</span>, <span class="number">2.8500000000000014</span>, <span class="number">2.8500000000000014</span>, <span class="number">2.8500000000000014</span>,</span><br><span class="line">          <span class="number">1.7040000000000006</span>, <span class="number">1.7040000000000006</span>, <span class="number">1.7040000000000006</span>, <span class="number">1.7040000000000006</span>, <span class="number">2.0500000000000003</span>,</span><br><span class="line">          <span class="number">2.0500000000000003</span>, <span class="number">2.8500000000000014</span>, <span class="number">1.7040000000000006</span>, <span class="number">2.8500000000000014</span>]</span><br><span class="line">con_three = [<span class="number">40</span>, <span class="number">67</span>, <span class="number">86</span>, <span class="number">89</span>, <span class="number">108</span>, <span class="number">111</span>,</span><br><span class="line">             <span class="number">123</span>, <span class="number">129</span>, <span class="number">140</span>, <span class="number">110</span>, <span class="number">96</span>, <span class="number">84</span>]</span><br><span class="line">con_five = [<span class="number">85</span>, <span class="number">95</span>, <span class="number">80</span>, <span class="number">75</span>, <span class="number">70</span>, <span class="number">82</span>,</span><br><span class="line">            <span class="number">76</span>, <span class="number">79</span>, <span class="number">69</span>, <span class="number">60</span>, <span class="number">65</span>, <span class="number">78</span>]</span><br><span class="line">delta_three = [<span class="number">0.6557200000000001</span>, <span class="number">0.5498800000000001</span>, <span class="number">0.52352</span>, <span class="number">0.42768000000000017</span>, <span class="number">0.33736</span>, <span class="number">0.2624000000000001</span>,</span><br><span class="line">               <span class="number">0.25664000000000015</span>, <span class="number">0.2274400000000001</span>, <span class="number">0.2102</span>, <span class="number">0.15942000000000003</span>, <span class="number">0.16290000000000004</span>, <span class="number">0.143</span>]</span><br><span class="line">delta_five = [<span class="number">1.5257199999999997</span>, <span class="number">1.15988</span>, <span class="number">1.01352</span>, <span class="number">0.78768</span>, <span class="number">0.61736</span>,</span><br><span class="line">              <span class="number">0.5324000000000001</span>, <span class="number">0.4466400000000001</span>, <span class="number">0.37744</span>, <span class="number">0.3502</span>, <span class="number">0.29942</span>, <span class="number">0.2529</span>, <span class="number">0.223</span>]</span><br><span class="line">all_need_three = <span class="number">508707600</span></span><br><span class="line">sum_get_three = <span class="number">347.23936000000003</span></span><br><span class="line">all_need_five = <span class="number">516965500</span></span><br><span class="line">sum_get_five = <span class="number">606.6283</span></span><br><span class="line">print(<span class="string">"三层："</span>)</span><br><span class="line">solve(con_three, all_need_three, sum_get_three, c_three, delta_three)</span><br><span class="line">print(<span class="string">"\n"</span>)</span><br><span class="line">print(<span class="string">"五层："</span>)</span><br><span class="line">solve(con_five, all_need_five, sum_get_five, c_five, delta_five)</span><br></pre></td></tr></table></figure>

</div></div>
<h3 id="问题三灵敏度分析模型相关python代码-ThirdProblemSolve-py"><a href="#问题三灵敏度分析模型相关python代码-ThirdProblemSolve-py" class="headerlink" title="问题三灵敏度分析模型相关python代码  ThirdProblemSolve.py"></a>问题三灵敏度分析模型相关python代码  ThirdProblemSolve.py</h3><div><div class="fold_hider"><div class="close hider_title"></div></div><div class="fold">
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pulp <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line">size = &#123;<span class="string">'x1'</span>: <span class="number">2500</span>, <span class="string">'x2'</span>: <span class="number">2500</span>, <span class="string">'x3'</span>: <span class="number">2500</span>, <span class="string">'x4'</span>: <span class="number">2500</span>, <span class="string">'x5'</span>: <span class="number">2000</span>, <span class="string">'x6'</span>: <span class="number">2000</span>, <span class="string">'x7'</span>: <span class="number">2000</span>, <span class="string">'x8'</span>: <span class="number">1800</span>,</span><br><span class="line">        <span class="string">'x9'</span>: <span class="number">1800</span>, <span class="string">'x10'</span>: <span class="number">1800</span>, <span class="string">'x11'</span>: <span class="number">1800</span>, <span class="string">'x12'</span>: <span class="number">1500</span>, <span class="string">'x13'</span>: <span class="number">1500</span>, <span class="string">'x14'</span>: <span class="number">2000</span>, <span class="string">'x15'</span>: <span class="number">1800</span>, <span class="string">'x16'</span>: <span class="number">2000</span>&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solve</span><span class="params">(con, all_need, sum_get, c)</span>:</span></span><br><span class="line">    prob = LpProblem(<span class="string">'myPro'</span>, LpMinimize)</span><br><span class="line">    x1 = LpVariable(<span class="string">'x1'</span>, lowBound=<span class="number">0</span>, cat=<span class="string">'Integer'</span>)</span><br><span class="line">    x2 = LpVariable(<span class="string">'x2'</span>, lowBound=<span class="number">0</span>, cat=<span class="string">'Integer'</span>)</span><br><span class="line">    x3 = LpVariable(<span class="string">'x3'</span>, lowBound=<span class="number">0</span>, cat=<span class="string">'Integer'</span>)</span><br><span class="line">    x4 = LpVariable(<span class="string">'x4'</span>, lowBound=<span class="number">0</span>, cat=<span class="string">'Integer'</span>)</span><br><span class="line">    x5 = LpVariable(<span class="string">'x5'</span>, lowBound=<span class="number">0</span>, cat=<span class="string">'Integer'</span>)</span><br><span class="line">    x6 = LpVariable(<span class="string">'x6'</span>, lowBound=<span class="number">0</span>, cat=<span class="string">'Integer'</span>)</span><br><span class="line">    x7 = LpVariable(<span class="string">'x7'</span>, lowBound=<span class="number">0</span>, cat=<span class="string">'Integer'</span>)</span><br><span class="line">    x8 = LpVariable(<span class="string">'x8'</span>, lowBound=<span class="number">0</span>, cat=<span class="string">'Integer'</span>)</span><br><span class="line">    x9 = LpVariable(<span class="string">'x9'</span>, lowBound=<span class="number">0</span>, cat=<span class="string">'Integer'</span>)</span><br><span class="line">    x10 = LpVariable(<span class="string">'x10'</span>, lowBound=<span class="number">0</span>, cat=<span class="string">'Integer'</span>)</span><br><span class="line">    x11 = LpVariable(<span class="string">'x11'</span>, lowBound=<span class="number">0</span>, cat=<span class="string">'Integer'</span>)</span><br><span class="line">    x12 = LpVariable(<span class="string">'x12'</span>, lowBound=<span class="number">0</span>, cat=<span class="string">'Integer'</span>)</span><br><span class="line">    x13 = LpVariable(<span class="string">'x13'</span>, lowBound=<span class="number">0</span>, cat=<span class="string">'Integer'</span>)</span><br><span class="line">    x14 = LpVariable(<span class="string">'x14'</span>, lowBound=<span class="number">0</span>, cat=<span class="string">'Integer'</span>)</span><br><span class="line">    x15 = LpVariable(<span class="string">'x15'</span>, lowBound=<span class="number">0</span>, cat=<span class="string">'Integer'</span>)</span><br><span class="line">    x16 = LpVariable(<span class="string">'x16'</span>, lowBound=<span class="number">0</span>, cat=<span class="string">'Integer'</span>)</span><br><span class="line">    X = [x1, x2, x3, x4, x5, x6, x7, x8,</span><br><span class="line">         x9, x10, x11, x12, x13, x14, x15, x16]</span><br><span class="line"></span><br><span class="line">    z = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(X)):</span><br><span class="line">        z += X[i] * c[i]</span><br><span class="line">    prob += z</span><br><span class="line"></span><br><span class="line">    prob += <span class="number">2</span> * x1 + <span class="number">2</span> * x14 &gt;= con[<span class="number">0</span>]</span><br><span class="line">    prob += <span class="number">2</span> * x2 + <span class="number">2</span> * x15 &gt;= con[<span class="number">1</span>]</span><br><span class="line">    prob += <span class="number">3</span> * x3 + <span class="number">2</span> * x16 &gt;= con[<span class="number">2</span>]</span><br><span class="line">    prob += <span class="number">3</span> * x5 + <span class="number">3</span> * x7 + <span class="number">2</span> * x13 &gt;= con[<span class="number">3</span>]</span><br><span class="line">    prob += <span class="number">4</span> * x2 + <span class="number">3</span> * x5 + <span class="number">2</span> * x11 &gt;= con[<span class="number">4</span>]</span><br><span class="line">    prob += <span class="number">15</span> * x4 + <span class="number">6</span> * x6 &gt;= con[<span class="number">5</span>]</span><br><span class="line">    prob += <span class="number">3</span> * x3 + <span class="number">6</span> * x8 + <span class="number">4</span> * x11 + <span class="number">4</span> * x16 &gt;= con[<span class="number">6</span>]</span><br><span class="line">    prob += x2 + x5 + <span class="number">2</span> * x6 + <span class="number">2</span> * x8 + <span class="number">10</span> * x9 &gt;= con[<span class="number">7</span>]</span><br><span class="line">    prob += <span class="number">12</span> * x3 + <span class="number">15</span> * x10 + <span class="number">3</span> * x16 &gt;= con[<span class="number">8</span>]</span><br><span class="line">    prob += <span class="number">8</span> * x1 + <span class="number">6</span> * x6 + <span class="number">5</span> * x8 + <span class="number">6</span> * x9 + <span class="number">8</span> * x12 + <span class="number">3</span> * x14 + x16 &gt;= con[<span class="number">9</span>]</span><br><span class="line">    prob += <span class="number">11</span> * x2 + <span class="number">14</span> * x7 + x8 + <span class="number">2</span> * x12 &gt;= con[<span class="number">10</span>]</span><br><span class="line">    prob += <span class="number">14</span> * x1 + x3 + <span class="number">8</span> * x11 + <span class="number">6</span> * x12 + <span class="number">6</span> * x13 + <span class="number">7</span> * x15 &gt;= con[<span class="number">11</span>]</span><br><span class="line"></span><br><span class="line">    prob.solve()</span><br><span class="line">    <span class="keyword">return</span> sum_get - value(prob.objective)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">arr = [[<span class="number">1660</span>, <span class="number">970</span>], [<span class="number">1540</span>, <span class="number">770</span>], [<span class="number">1280</span>, <span class="number">690</span>], [<span class="number">1080</span>, <span class="number">610</span>], [<span class="number">920</span>, <span class="number">530</span>], [<span class="number">800</span>, <span class="number">480</span>],</span><br><span class="line">       [<span class="number">720</span>, <span class="number">420</span>], [<span class="number">640</span>, <span class="number">360</span>], [<span class="number">600</span>, <span class="number">345</span>], [<span class="number">540</span>, <span class="number">305</span>], [<span class="number">460</span>, <span class="number">275</span>], [<span class="number">420</span>, <span class="number">250</span>]]</span><br><span class="line">c_three = [<span class="number">1.25</span>, <span class="number">1.25</span>, <span class="number">1.25</span>, <span class="number">1.25</span>, <span class="number">0.9</span>, <span class="number">0.9</span>, <span class="number">0.9</span>, <span class="number">0.264</span>,</span><br><span class="line">           <span class="number">0.264</span>, <span class="number">0.264</span>, <span class="number">0.264</span>, <span class="number">0.85</span>, <span class="number">0.85</span>, <span class="number">0.9</span>, <span class="number">0.264</span>, <span class="number">0.9</span>]</span><br><span class="line">c_five = [<span class="number">4.25</span>, <span class="number">4.25</span>, <span class="number">4.25</span>, <span class="number">4.25</span>, <span class="number">2.8500000000000014</span>, <span class="number">2.8500000000000014</span>, <span class="number">2.8500000000000014</span>, <span class="number">1.7040000000000006</span>, <span class="number">1.7040000000000006</span>, <span class="number">1.7040000000000006</span>,</span><br><span class="line">          <span class="number">1.7040000000000006</span>, <span class="number">2.0500000000000003</span>, <span class="number">2.0500000000000003</span>, <span class="number">2.8500000000000014</span>, <span class="number">1.7040000000000006</span>, <span class="number">2.8500000000000014</span>]</span><br><span class="line">con_three = [<span class="number">40</span>, <span class="number">67</span>, <span class="number">86</span>, <span class="number">89</span>, <span class="number">108</span>, <span class="number">111</span>,</span><br><span class="line">             <span class="number">123</span>, <span class="number">129</span>, <span class="number">140</span>, <span class="number">110</span>, <span class="number">96</span>, <span class="number">84</span>]</span><br><span class="line">con_five = [<span class="number">85</span>, <span class="number">95</span>, <span class="number">80</span>, <span class="number">75</span>, <span class="number">70</span>, <span class="number">82</span>,</span><br><span class="line">            <span class="number">76</span>, <span class="number">79</span>, <span class="number">69</span>, <span class="number">60</span>, <span class="number">65</span>, <span class="number">78</span>]</span><br><span class="line">all_need_three = <span class="number">508707600</span></span><br><span class="line">sum_get_three = <span class="number">347.23936000000003</span></span><br><span class="line">all_need_five = <span class="number">516965500</span></span><br><span class="line">sum_get_five = <span class="number">606.6283</span></span><br><span class="line"></span><br><span class="line">box_price_three = [<span class="number">2.91</span>, <span class="number">2.21</span>, <span class="number">1.76</span>, <span class="number">1.35</span>, <span class="number">1.02</span>, <span class="number">0.80</span>,</span><br><span class="line">                   <span class="number">0.68</span>, <span class="number">0.55</span>, <span class="number">0.50</span>, <span class="number">0.39</span>, <span class="number">0.34</span>, <span class="number">0.29</span>]</span><br><span class="line">box_price_five = [<span class="number">3.78</span>, <span class="number">2.82</span>, <span class="number">2.25</span>, <span class="number">1.71</span>, <span class="number">1.30</span>, <span class="number">1.07</span>,</span><br><span class="line">                  <span class="number">0.87</span>, <span class="number">0.70</span>, <span class="number">0.64</span>, <span class="number">0.53</span>, <span class="number">0.43</span>, <span class="number">0.37</span>]</span><br><span class="line"></span><br><span class="line">Get_three = solve(con_three, all_need_three, sum_get_three, c_three)</span><br><span class="line">Get_five = solve(con_five, all_need_five, sum_get_five, c_five)</span><br><span class="line">get_three_change = []</span><br><span class="line">get_five_change = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(con_three)):</span><br><span class="line">    con = con_three.copy()</span><br><span class="line">    con[i] = math.floor(con[i] * <span class="number">1.1</span>)</span><br><span class="line">    sum_get = sum_get_three + box_price_three[i] * (con[i] - con_three[i])</span><br><span class="line">    get_three_change.append(solve(con, all_need_three, sum_get, c_three))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(con_three)):</span><br><span class="line">    con = con_five.copy()</span><br><span class="line">    con[i] = math.floor(con[i] * <span class="number">1.1</span>)</span><br><span class="line">    sum_get = sum_get_five + box_price_five[i] * (con[i] - con_five[i])</span><br><span class="line">    get_five_change.append(solve(con, all_need_five, sum_get, c_five))</span><br><span class="line"></span><br><span class="line">print(<span class="string">"三层："</span>)</span><br><span class="line">print(<span class="string">"原利润为：%f"</span> % Get_three)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(get_three_change)):</span><br><span class="line">    print(<span class="string">"第%d个纸箱需求量增加10%%后，利润变为%f，变化率为%f"</span> % (i, get_three_change[i], (get_three_change[i] - Get_three) / Get_three))</span><br><span class="line"></span><br><span class="line">print(<span class="string">"\n"</span>)</span><br><span class="line">print(<span class="string">"五层："</span>)</span><br><span class="line">print(<span class="string">"原利润为：%f"</span> % Get_five)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(get_five_change)):</span><br><span class="line">print(<span class="string">"第%d个纸箱需求量增加10%%后，利润变为%f，变化率为%f"</span> % (i, get_five_change[i], (get_five_change[i] - Get_five) / Get_five))</span><br></pre></td></tr></table></figure>

</div></div>]]></content>
      <categories>
        <category>数学建模</category>
      </categories>
      <tags>
        <tag>数学建模</tag>
        <tag>遗传算法</tag>
        <tag>二维矩阵下料问题</tag>
        <tag>线性规划</tag>
        <tag>灵敏度分析</tag>
      </tags>
  </entry>
  <entry>
    <title>树的直径</title>
    <url>/ZLY201.github.io/2020/09/04/%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84/</url>
    <content><![CDATA[<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>&emsp;定义一颗树上最远两个叶子结点的距离为树的直径。</p>
<h3 id="求解"><a href="#求解" class="headerlink" title="求解"></a>求解</h3><p>&emsp;很容易想到一个$O(n^2)$的暴力算法，即遍历所有的叶子结点，找到距离最远的那两个，距离即为所求，但是复杂度过高，对于$n \geq 1e5$的情况便会显得力不从心。</p>
<p>&emsp;现在给出$O(n)$算法步骤：</p>
<ol>
<li>以任意节点为根（以下称该点为$root$），找到距离该节点最远的叶子结点$x$；</li>
<li>以叶子节点$x$为根节点，找到距离该节点最远的叶子结点$y$；</li>
<li>$dis(x,y)$即为所求；</li>
</ol>
<h3 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h3><p>&emsp;假设$dis(x,y)$不为最大值，那么必然存在叶子结点$x,y$使得$dis(x’,y’)&gt;dis(x,y)$，通过以下步骤，可证明$x’=x,y’=y$。</p>
<ol>
<li><p>路径$x \to y$一定会经过$x \to root$上的部分节点，否则与$x$为距离$root$的最远叶子结点的前提相违背；</p>
</li>
<li><p>设$x \to y$与$x \to root$的分叉节点为$z$，即$x \to z \to y$，$x \to z \to root$，那么显然有$dis(z,x) \geq dis(z,y)$；</p>
</li>
<li>由于树上任意两节点联通，设$x’ \to y’$与$root$的联通节点为$z’$，由于$x \to y$是所有与节点中与$x$距离最远的，所以显然有$dis(z,y)\geq dis(z,y’) \geq dis(z’,y’)$，同理有$dis(z,y)\geq dis(z,x’) \geq dis(z’,x’)$，，那么$x’,y’$中必有一点等于$y$，否则将会产生一条新的最长链大于$dis(x’,y’)$；</li>
<li>假设$y’=y$，现在只需证明$x’=x$即可，又因为$2$中以证明$dis(z,x) \geq dis(z,y)$，且根据$3$中$dis(z,y)\geq dis(z,y’) \geq dis(z’,y’)$，$x’=x$是显然的，理由同$3$。</li>
</ol>
<center><b>证毕</b></center>

<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><div><div class="fold_hider"><div class="close hider_title"></div></div><div class="fold">
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> dis[maxn], Max = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = v[u].size();</span><br><span class="line">    <span class="keyword">if</span>(len == <span class="number">1</span> &amp;&amp; dis[u] &gt; dis[Max]) Max = u; </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(v[u][i] == fa) <span class="keyword">continue</span>;</span><br><span class="line">        dis[v[u][i]] = dis[u] + <span class="number">1</span>;</span><br><span class="line">        dfs(v[u][i], u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//read data before...</span></span><br><span class="line">    dfs(<span class="number">1</span>);</span><br><span class="line">    dis[Max] = <span class="number">0</span>;</span><br><span class="line">    dfs(Max);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; dis[Max] &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div>]]></content>
      <categories>
        <category>树</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>欧拉函数</title>
    <url>/ZLY201.github.io/2020/07/05/%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h2 id="欧拉函数"><a href="#欧拉函数" class="headerlink" title="欧拉函数"></a>欧拉函数</h2><p>对于一个正整数x，小于且和x互质的正整数（包括1）的个数，计做$\phi(x)$</p>
<p>其通项公式为$\phi(x)=x\prod_{i=1}^{n}(1-\frac{1}{p_{i}})$</p>
<p>其中$p_{i}$代表x的某一个质因数，n为质因数个数</p>
<p>特别的，我们规定$\phi(1)=1$</p>
<p>那么我们根据公式可以求出任意正整数x的$\phi(x)$值，代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ll <span class="title">eular</span><span class="params">(ll n)</span> </span>&#123;</span><br><span class="line">    ll res = n;</span><br><span class="line">    ll k = <span class="built_in">sqrt</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= k; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(n % i == <span class="number">0</span>) &#123;</span><br><span class="line">            res = res / i * (i - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">while</span>(n % i == <span class="number">0</span>) n /= i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n &gt; <span class="number">1</span>) res = res / n * (n - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是如果实时让你输出任意指定范围内x的$\phi(x)$值，上述代码的时间复杂度显然不满足要求，于是我们采取打表的方法求出1-n中所有数的$\phi(x)$值，代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">euler</span><span class="params">(ll n)</span> </span>&#123;</span><br><span class="line">	phi[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!phi[i]) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt;= n; j += i) &#123;</span><br><span class="line">				<span class="keyword">if</span> (!phi[j]) phi[j] = j;</span><br><span class="line">				phi[j] = phi[j] / i * (i - <span class="number">1</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="欧拉函数的性质"><a href="#欧拉函数的性质" class="headerlink" title="欧拉函数的性质"></a>欧拉函数的性质</h2><ol>
<li><p>若n是质数p的k次幂，即$n=p^{k}$，那么有$\phi(n)=(p-1)p^{k-1}$</p>
</li>
<li><p>若n与m互质，那么$\phi(nm)=(n-1)(m-1)=\phi(n)\phi(m)$</p>
</li>
<li><p>若n为奇数，则$\phi(n)=\phi(2n)$</p>
</li>
<li><p>小于n，且与n互质的数之和为$\frac{n \times \phi(n)}{2}$</p>
</li>
</ol>
<h2 id="例题：Mathematically-Hard-LightOJ-1007"><a href="#例题：Mathematically-Hard-LightOJ-1007" class="headerlink" title="例题：Mathematically Hard LightOJ - 1007"></a>例题：<a href="http://lightoj.com/volume_showproblem.php?problem=1007" target="_blank" rel="noopener">Mathematically Hard LightOJ - 1007</a></h2><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>给你正整数a和b，定义$score(x) = n^{2}$，其中n为小于x的质因子的个数，问你区间[a, b]内score(i)的和是多少</p>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>根据定义可知$n = \phi(x)$，那么我们使用打表法线性求出范围内的$\phi(x)$求平方和即可</p>
<h3 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h3><div><div class="fold_hider"><div class="close hider_title"></div></div><div class="fold">
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">5e6</span> + <span class="number">10</span>;</span><br><span class="line">ll phi[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">euler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	phi[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; maxn; ++i) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!phi[i]) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; maxn; j += i) &#123;</span><br><span class="line">				<span class="keyword">if</span> (!phi[j]) phi[j] = j;</span><br><span class="line">				phi[j] = phi[j] / i * (i - <span class="number">1</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; maxn; ++i) &#123;</span><br><span class="line">		phi[i] = phi[i - <span class="number">1</span>] + phi[i] * phi[i];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> T;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">	<span class="keyword">int</span> cas = <span class="number">0</span>;</span><br><span class="line">	euler();</span><br><span class="line">	<span class="keyword">while</span> (T--) &#123;</span><br><span class="line">		<span class="keyword">int</span> a, b;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Case %d: %llu\n"</span>, ++cas, phi[b] - phi[a - <span class="number">1</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></div>]]></content>
      <categories>
        <category>数论</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>欧拉函数</tag>
      </tags>
  </entry>
</search>
