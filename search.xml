<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Welcome To My Own Blog</title>
    <url>/ZLY201.github.io/2020/07/03/hellow/</url>
    <content><![CDATA[<div style="text-align: center">
    <table>
        <tr><td colspan="2" style="text-align: center"><font size="4">博主个人信息</font></td></tr>
        <tr>
            <td style="text-align: center">姓名</td>
            <td style="text-align: center">保密</td>
        </tr>
        <tr>
            <td style="text-align: center">性别</td>
            <td style="text-align: center">反正不是女的</td>
        </tr>
        <tr>
            <td style="text-align: center">年龄</td>
            <td style="text-align: center">别问，问就是18（orz）</td>
        </tr>
        <tr>
            <td style="text-align: center">学校</td>
            <td style="text-align: center">中国地质大学（武汉）</td>
        </tr>
        <tr>
            <td style="text-align: center">专业</td>
            <td style="text-align: center">计算机科学与技术</td>
        </tr>
        <tr><td rowspan="4" style="text-align: center">获奖情况</td></tr>
        <tr><td style="text-align: center">1. 信工学院编程大赛一等奖</td></tr>
        <tr><td style="text-align: center">2. 中国地质大学（武汉）暨华中地区ICPC邀请赛三等奖</td></tr>
        <tr><td style="text-align: center">3. 中国地质大学（武汉）数学建模校内选拔赛一等奖</td></tr>
    </table>
</div>

<p>欢迎访问我的其他博客主页（可能有惊喜哦）<br><a href="https://blog.csdn.net/weixin_44211980" target="_blank" rel="noopener">csdn博客主页</a><br><a href="https://www.luogu.com.cn/blog/226316/" target="_blank" rel="noopener">luogu博客主页</a></p>
<p>祝您玩的开心（0^_^0）！</p>
]]></content>
      <categories>
        <category>Hellow</category>
      </categories>
  </entry>
  <entry>
    <title>FatMouse&#39;s Speed HDU - 1160</title>
    <url>/ZLY201.github.io/2020/07/12/HDU%20-%201160/</url>
    <content><![CDATA[<h2 id="FatMouse’s-Speed-HDU-1160"><a href="#FatMouse’s-Speed-HDU-1160" class="headerlink" title="FatMouse’s Speed HDU - 1160"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1160" target="_blank" rel="noopener">FatMouse’s Speed HDU - 1160</a></h2><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>给你$1-k$每个人的$W$和$S$，让你构造一个$W[m[1]] &lt; W[m[2]] &lt; … &lt; W[m[n]]$和$S[m[1]] &gt; S[m[2]] &gt; … &gt; S[m[n]]$的序列，其中$m$为每个人的标号，输出$n$和序列$m$</p>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>将数组按照$W$优先降序，$S$优先升序（一会说为什么反过来）排序，$dp[i]$表示以$i$为结尾的序列最大长度，那么对于$\forall j &lt; i,\ 如果W[i] &lt; W[j] \ \&amp;\&amp; \ S[i] &gt; S[j]$，那么$dp[i] = max(dp[j]) + 1$，我们可以使用类似于并查集的数组反向记录$dp[j] + 1&gt;dp[i]$的$j$的标号，然后回溯输出序列，由于这样记录下来的序列是反向的，所以前面我们需要将比较条件反过来排序</p>
<p>注：这题比较坑的是输入，cin是从后往前运行的，所以++cnt要放在后面，而且读入EOF会使得cnt多加一次，所以读完后要将其减一</p>
<h3 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h3><div><div class="fold_hider"><div class="close hider_title"></div></div><div class="fold">
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> w, s, id;</span><br><span class="line">&#125;a[<span class="number">1010</span>];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(Node a, Node b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (a.w == b.w) <span class="keyword">return</span> a.s &lt; b.s;</span><br><span class="line">	<span class="keyword">return</span> a.w &gt; b.w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">1010</span>], pre[<span class="number">1010</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a[cnt].w, &amp;a[++cnt].s)) a[cnt].id = cnt;</span><br><span class="line">	--cnt;</span><br><span class="line">	sort(a + <span class="number">1</span>, a + cnt + <span class="number">1</span>, cmp);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= cnt; ++i) &#123;</span><br><span class="line">		dp[i] = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= cnt; ++i) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; ++j) &#123;</span><br><span class="line">			<span class="keyword">if</span> (a[i].w &lt; a[j].w &amp;&amp; a[i].s &gt; a[j].s &amp;&amp; dp[i] &lt; dp[j] + <span class="number">1</span>) &#123;</span><br><span class="line">				dp[i] = dp[j] + <span class="number">1</span>;</span><br><span class="line">				pre[i] = j;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (dp[i] &gt; dp[pos]) pos = i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, dp[pos]);</span><br><span class="line">	<span class="keyword">while</span> (pos) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, a[pos].id);</span><br><span class="line">		pos = pre[pos];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></div>
]]></content>
      <categories>
        <category>HDU</category>
      </categories>
      <tags>
        <tag>HDU</tag>
        <tag>动态规划</tag>
        <tag>最长上升子序列</tag>
      </tags>
  </entry>
  <entry>
    <title>Phalanx HDU - 2859</title>
    <url>/ZLY201.github.io/2020/07/12/HDU%20-%202859/</url>
    <content><![CDATA[<h2 id="Phalanx-HDU-2859"><a href="#Phalanx-HDU-2859" class="headerlink" title="Phalanx HDU - 2859"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=2859" target="_blank" rel="noopener">Phalanx HDU - 2859</a></h2><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>给你一个$n \times n$的字符矩阵，问你其最大的对称子矩阵的大小</p>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>考虑现在已经有了一个以$(i, j)$为左下角，$m \times m$大小的子矩阵，我们要想将其扩大，那么必须以$(i + 1, j - 1)$为左下角并且$\forall k \leq m+1,\ s[i+1-k]=s[j-1+k]$</p>
<p>那么我们定义$dp[i][j]$表示以$(i, j)$为左下角的对称矩阵的大小，如果$\forall k \leq dp[i-1][j+1]+1，s[i+1-k]=s[j-1+k]$，那么$dp[i][j]=dp[i-1][j+1]+1$，否则$dp[i][j]=max(k), \forall l \leq k,\ s[i+1-l]=s[j-1+l]$</p>
<h3 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h3><div><div class="fold_hider"><div class="close hider_title"></div></div><div class="fold">
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e3</span> + <span class="number">10</span>;</span><br><span class="line"><span class="built_in">string</span> s[maxn];</span><br><span class="line"><span class="keyword">int</span> dp[maxn][maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">cin</span>.tie(<span class="number">0</span>), <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!n) <span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; s[i];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">		<span class="keyword">int</span> Max = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">				dp[i][j] = <span class="number">1</span>;</span><br><span class="line">				<span class="keyword">int</span> x = i, y = j;</span><br><span class="line">				<span class="keyword">while</span> (x &gt;= <span class="number">1</span> &amp;&amp; y &lt; n &amp;&amp; s[i][y] == s[x][j]) &#123;</span><br><span class="line">					--x, ++y;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">int</span> tmp = i - x;</span><br><span class="line">				<span class="keyword">if</span> (tmp &gt; dp[i - <span class="number">1</span>][j + <span class="number">1</span>]) dp[i][j] = dp[i - <span class="number">1</span>][j + <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">				<span class="keyword">else</span> dp[i][j] = tmp;</span><br><span class="line">				Max = max(Max, dp[i][j]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; Max &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></div>
]]></content>
      <categories>
        <category>HDU</category>
      </categories>
      <tags>
        <tag>HDU</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>Treats for the Cows POJ - 3186</title>
    <url>/ZLY201.github.io/2020/07/12/POJ%20-%203186/</url>
    <content><![CDATA[<h2 id="Treats-for-the-Cows-POJ-3186"><a href="#Treats-for-the-Cows-POJ-3186" class="headerlink" title="Treats for the Cows POJ - 3186"></a><a href="http://poj.org/problem?id=3186" target="_blank" rel="noopener">Treats for the Cows POJ - 3186</a></h2><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>有一个数组$a$，每次你可以将数组的头部或尾部添加到新数组$b$的结尾，问你$W = \sum_{i=1}^{n}b_{i} \times i$的最大值是多少</p>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>对于$b[i]$仅有两个状态，要么是当前$a$数组的开头，要么是$a$数组的结尾，那么我们定义$dp[i][j]$为当前$a$数组开头取了$i$个，结尾取了$j$个的最大值，其状态转移方程为：</p>
<script type="math/tex; mode=display">dp[i][j]=max(dp[i-1][j] + a[i] \times (i + j), dp[i][j - 1] + a[n - j + 1] \times (i + j))</script><p>初始条件为：</p>
<script type="math/tex; mode=display">\begin
{cases}
dp[i][0] += dp[i - 1][0] + a[i] * i \\
dp[0][i] += dp[0][i - 1] + a[n - i + 1] * i \\
\end
{cases}</script><h3 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h3><div><div class="fold_hider"><div class="close hider_title"></div></div><div class="fold">
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e3</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line"><span class="keyword">int</span> dp[maxn][maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">cin</span>.tie(<span class="number">0</span>), <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">		dp[i][<span class="number">0</span>] += dp[i - <span class="number">1</span>][<span class="number">0</span>] + a[i] * i;</span><br><span class="line">		dp[<span class="number">0</span>][i] += dp[<span class="number">0</span>][i - <span class="number">1</span>] + a[n - i + <span class="number">1</span>] * i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> Max = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; i + j &lt;= n; ++j) &#123;</span><br><span class="line">			dp[i][j] = max(dp[i - <span class="number">1</span>][j] + a[i] * (i + j), dp[i][j - <span class="number">1</span>] + a[n - j + <span class="number">1</span>] * (i + j));</span><br><span class="line">			Max = max(Max, dp[i][j]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; Max &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></div>
]]></content>
      <categories>
        <category>POJ</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>POJ</tag>
      </tags>
  </entry>
  <entry>
    <title>Common Subsequence POJ - 1458</title>
    <url>/ZLY201.github.io/2020/07/12/POJ%20-%201458/</url>
    <content><![CDATA[<h2 id="Common-Subsequence-POJ-1458"><a href="#Common-Subsequence-POJ-1458" class="headerlink" title="Common Subsequence POJ - 1458"></a><a href="http://poj.org/problem?id=1458" target="_blank" rel="noopener">Common Subsequence POJ - 1458</a></h2><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>给你两个字符串$s$和$p$，让你求最长公共子串的长度</p>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>对于字符$s[i]$和$p[j]$可以分为相同和不同两种情况，如果相同则可以将其加入到$s[i]$之前与$p[j]$之前的最长公共子串中去，否则忽略，那么我们定义$dp[i][j]$表示$s$中前$i$个字符与$p$中前$j$个字符的最长公共子串的长度，其状态转移方程为：</p>
<script type="math/tex; mode=display">dp[i][j]=
\begin
{cases}
{dp[i-1][j-1] + 1} & {s[i]=p[j]} \\
{max(dp[i-1][j],dp[i][j-1])} & {s[i]!=p[j]}
\end
{cases}</script><h3 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h3><div><div class="fold_hider"><div class="close hider_title"></div></div><div class="fold">
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">1010</span>][<span class="number">1010</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">string</span> s, p;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; s &gt;&gt; p) &#123;</span><br><span class="line">		s = <span class="string">" "</span> + s;</span><br><span class="line">		p = <span class="string">" "</span> + p;</span><br><span class="line">		<span class="keyword">int</span> ls = s.length();</span><br><span class="line">		<span class="keyword">int</span> lp = p.length();</span><br><span class="line">		<span class="keyword">int</span> Max = <span class="number">0</span>;</span><br><span class="line">		<span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; ls; ++i) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; lp; ++j) &#123;</span><br><span class="line">				<span class="keyword">if</span> (s[i] == p[j]) dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">				<span class="keyword">else</span> dp[i][j] = max(dp[i][j - <span class="number">1</span>], dp[i - <span class="number">1</span>][j]);</span><br><span class="line">				Max = max(dp[i][j], Max);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; Max &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></div>
]]></content>
      <categories>
        <category>POJ</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>POJ</tag>
        <tag>最长公共子串</tag>
      </tags>
  </entry>
  <entry>
    <title>Max Sum Plus Plus HDU - 1024</title>
    <url>/ZLY201.github.io/2020/07/11/HDU%20-%201024/</url>
    <content><![CDATA[<h2 id="Max-Sum-Plus-Plus-HDU-1024"><a href="#Max-Sum-Plus-Plus-HDU-1024" class="headerlink" title="Max Sum Plus Plus HDU - 1024"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1024" target="_blank" rel="noopener">Max Sum Plus Plus HDU - 1024</a></h2><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>将$n$个数分成$m$组互不相交的连续子序列（$m$组不一定包含所有数），问你这$m$组的和最大是多少</p>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>假设前$i$个数已经分成了$j$组，那么第$i$个数可以分到$j$组中的任意一组或者变成第$j+1$组的第一个数<br>由此我们定义$dp[i][j]$为前$i$个数分成$j$组的最大值，那么转移方程为：</p>
<script type="math/tex; mode=display">dp[i][j]=max(dp[i-1][j] + a[i], (max_{k=1}^{i-1}dp[k][j-1]) + a[i])</script><p>其中$dp[i-1][j] + a[i]$表示将第$i$个数分到前$j$组中的任意一组，$(max_{k=1}^{i-1}dp[k][j-1]) + a[i]$表示将第$i$个数自成一组并合并到前$k$个数分成$j-1$组中最大的情况中</p>
<p>但是这样做的时间复杂度是$O(mn^{2})$，显然不符合要求</p>
<p>观察上式，我们发现$max_{k=1}^{i-1}dp[k][j-1]$由于与$j-1$之前的情况无关，所以并不用每一次都重新计算，而是在统计组数为$j-1$时将其记录下来即可</p>
<h3 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h3><div><div class="fold_hider"><div class="close hider_title"></div></div><div class="fold">
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line">ll a[maxn];</span><br><span class="line">ll dp[maxn];</span><br><span class="line">ll mmax[maxn];	<span class="comment">//实时记录组数为j-1的情况</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">cin</span>.tie(<span class="number">0</span>), <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">int</span> m, n;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; m &gt;&gt; n) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">			dp[i] = mmax[i] = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j) &#123;</span><br><span class="line">			ll Max = LLONG_MIN;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = j; i &lt;= n; ++i) &#123;</span><br><span class="line">				dp[i] = max(dp[i - <span class="number">1</span>], mmax[i - <span class="number">1</span>]) + a[i];</span><br><span class="line">				<span class="comment">//注意下面两个语句不能颠倒，因为这会影响下一次的循环（i + 1的情况）</span></span><br><span class="line">				mmax[i - <span class="number">1</span>] = Max;</span><br><span class="line">				Max = max(Max, dp[i]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		ll res = LLONG_MIN;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = m; i &lt;= n; ++i) &#123;</span><br><span class="line">			res = max(dp[i], res);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></div>
]]></content>
      <categories>
        <category>HDU</category>
      </categories>
      <tags>
        <tag>HDU</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>免费馅饼 HDU - 1176</title>
    <url>/ZLY201.github.io/2020/07/11/HDU%20-%201176/</url>
    <content><![CDATA[<h2 id="免费馅饼-HDU-1176"><a href="#免费馅饼-HDU-1176" class="headerlink" title="免费馅饼 HDU - 1176"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1176" target="_blank" rel="noopener">免费馅饼 HDU - 1176</a></h2><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>有一条坐标轴，范围为$[0, 10]$，有$n$个馅饼分别会在$t_{i}$秒落在$x_{i}$的位置，你的初始位置为5，每秒能向左或向右移动一格，问你你能拾取的最大数量的馅饼个数是多少</p>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>由于你每次只能向左或向右移动一格，那么在$t$秒你有三种可选择的状态：</p>
<ol>
<li>保持不动</li>
<li>向左移动一格</li>
<li>向右移动一格</li>
</ol>
<p>所以我们可以定义$dp[i][j]$为第$i$秒在$j$位置处所拾取的最大馅饼数目，那么转移方程即为：</p>
<script type="math/tex; mode=display">dp[i][j]=dp[i][j]+max(max(dp[i+1][j-1],dp[i+1][j+1]),dp[i+1][j])</script><p>初始条件为$dp[i][j]=\sum_{k=1}^{n}(t_{k} == i\  \&amp;\&amp; \ x_{k} == j)$</p>
<p>还需注意的是我们枚举时间需要从后往前枚举，因为如果从$t=0$开始枚举的话最终的状态是不确定的，就是说你的位置是不确定的，而由于初始状态为$x=5$，所以从后往前枚举是可行的</p>
<h3 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h3><div><div class="fold_hider"><div class="close hider_title"></div></div><div class="fold">
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> dp[maxn][<span class="number">15</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">cin</span>.tie(<span class="number">0</span>), <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!n) <span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">int</span> Time = <span class="number">0</span>;</span><br><span class="line">		<span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">			<span class="keyword">int</span> x, t;</span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; x &gt;&gt; t;</span><br><span class="line">			++dp[t][x];</span><br><span class="line">			Time = max(Time, t);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = Time - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">10</span>; ++j) &#123;</span><br><span class="line">				dp[i][j] += max(max(dp[i + <span class="number">1</span>][j - <span class="number">1</span>], dp[i + <span class="number">1</span>][j + <span class="number">1</span>]), dp[i + <span class="number">1</span>][j]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; dp[<span class="number">0</span>][<span class="number">5</span>] &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></div>
]]></content>
      <categories>
        <category>HDU</category>
      </categories>
      <tags>
        <tag>HDU</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>Tickets HDU - 1260</title>
    <url>/ZLY201.github.io/2020/07/11/HDU%20-%201260/</url>
    <content><![CDATA[<h2 id="Tickets-HDU-1260"><a href="#Tickets-HDU-1260" class="headerlink" title="Tickets HDU - 1260"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1260" target="_blank" rel="noopener">Tickets HDU - 1260</a></h2><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>有$k$个人去电影院买票，第$i$个人的买票时间为$a[i]$，第$i$和第$i+1$个人一起买票的时间为$b[i]$，问你最少花多长时间可以把票卖完</p>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>考虑第i个人的状态有：</p>
<ol>
<li>单独卖票</li>
<li>和前一个人一起卖票</li>
</ol>
<p>那么我用$dp[i]$表示前i个人卖票所花的最短时间，其状态转移方程为:</p>
<script type="math/tex; mode=display">dp[i]=min(dp[i-1]+a[i],dp[i-2]+b[i-1])</script><p>初始条件为$dp[1]=a[1]$</p>
<h3 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h3><div><div class="fold_hider"><div class="close hider_title"></div></div><div class="fold">
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">2010</span>], b[<span class="number">2010</span>];</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">2010</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> T;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">	<span class="keyword">while</span> (T--) &#123;</span><br><span class="line">		<span class="keyword">int</span> k;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;k);</span><br><span class="line">		<span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; ++i) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; k; ++i) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;b[i]);</span><br><span class="line">		dp[<span class="number">1</span>] = a[<span class="number">1</span>];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= k; ++i) &#123;</span><br><span class="line">			dp[i] = min(dp[i - <span class="number">1</span>] + a[i], dp[i - <span class="number">2</span>] + b[i - <span class="number">1</span>]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> ss = dp[k] % <span class="number">60</span>;</span><br><span class="line">		<span class="keyword">int</span> mm = dp[k] / <span class="number">60</span> % <span class="number">60</span>;</span><br><span class="line">		<span class="keyword">int</span> hh = <span class="number">8</span> + dp[k] / <span class="number">60</span> / <span class="number">60</span>;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%02d:%02d:%02d %s\n"</span>, hh, mm, ss, (hh &gt; <span class="number">12</span> ? <span class="string">"pm"</span> : <span class="string">"am"</span>));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></div>
]]></content>
      <categories>
        <category>HDU</category>
      </categories>
      <tags>
        <tag>HDU</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>Interesting Yang Hui Triangle POJ - 3146</title>
    <url>/ZLY201.github.io/2020/07/09/POJ%20-%203146/</url>
    <content><![CDATA[<h2 id="Interesting-Yang-Hui-Triangle-POJ-3146"><a href="#Interesting-Yang-Hui-Triangle-POJ-3146" class="headerlink" title="Interesting Yang Hui Triangle POJ - 3146"></a><a href="http://poj.org/problem?id=3146" target="_blank" rel="noopener">Interesting Yang Hui Triangle POJ - 3146</a></h2><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>问你杨辉三角第n行有多少个数不能被p整除</p>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>杨辉三角第n行第i个数为$C_{n}^{i-1}$<br>根据卢卡斯定理我们可知，假设$a$和$b$在$p$进制下分别表示为$a_{k}a_{k-1}…a_{0}$和$b_{k}b_{k-1}…b_{0}$，那么<br>$C_{a}^{b} \equiv {C_{a_{k}}^{b_{k}}C_{a_{k-1}}^{b_{k-1}}…C_{a_{0}}^{b_{0}}} \pmod {p}$<br>要使得$C_{a}^{b}$不能被p整除，那么$\forall {i} \in [0, k]$，$a_{i} \geq b_{i}$<br>根据计数原理，我们求出p进制下的$n=n_{k}n_{k-1}…n_{0}$，那么答案即为$(n_{0} + 1)(n_{1} + 1)…(n_{k} + 1)$</p>
<h3 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h3><div><div class="fold_hider"><div class="close hider_title"></div></div><div class="fold">
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ll p, n;</span><br><span class="line">	<span class="keyword">int</span> cas = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; p &gt;&gt; n) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!p &amp;&amp; !n) <span class="keyword">break</span>;</span><br><span class="line">		ll ans = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span> (n) &#123;</span><br><span class="line">			ans = ans * (n % p + <span class="number">1</span>) % <span class="number">10000</span>;</span><br><span class="line">			n /= p;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Case %d: %04lld\n"</span>, ++cas, ans);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></div>]]></content>
      <categories>
        <category>POJ</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>POJ</tag>
        <tag>卢卡斯定理</tag>
      </tags>
  </entry>
  <entry>
    <title>青蛙的约会 POJ - 1061</title>
    <url>/ZLY201.github.io/2020/07/08/POJ%20-%201061/</url>
    <content><![CDATA[<h2 id="青蛙的约会-POJ-1061"><a href="#青蛙的约会-POJ-1061" class="headerlink" title="青蛙的约会 POJ - 1061"></a><a href="http://poj.org/problem?id=1061" target="_blank" rel="noopener">青蛙的约会 POJ - 1061</a></h2><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>两只青蛙在L长的圆形跑道上玩跳跳乐，青蛙A的出发点坐标为x，一次能跳m米，青蛙B的出发点坐标y，一次能跳n米，他们跳一次时间相同，同时起跳，问你跳几次能相遇</p>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>设$t$次后相遇<br>$x + mt \equiv {y + nt} \pmod {L}$<br>$(x + mt) - (y + nt) = qL$<br>$(m - n)t - qL = (y - x)$<br>$(n - m)t + qL = (x - y)$<br>是不是长得很像$ax + by = c$<br>用拓展欧几里得定理求解t即可</p>
<h3 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h3><div><div class="fold_hider"><div class="close hider_title"></div></div><div class="fold">
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a, ll b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> !b ? a : gcd(b, a % b);</span><br><span class="line">&#125;</span><br><span class="line">pair&lt;ll, ll&gt; exgcd(ll a, ll b) &#123;</span><br><span class="line">	<span class="keyword">if</span> (!b) <span class="keyword">return</span> pair&lt;ll, ll&gt;(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">	pair&lt;ll, ll&gt; temp = exgcd(b, a % b);</span><br><span class="line">	<span class="keyword">return</span> pair&lt;ll, ll&gt;(temp.second, temp.first - a / b * temp.second);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">cin</span>.tie(<span class="number">0</span>), <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">	ll x, y, m, n, l;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y &gt;&gt; m &gt;&gt; n &gt;&gt; l;</span><br><span class="line">	ll a = n - m, b = l;</span><br><span class="line">	ll g = gcd(a, b);</span><br><span class="line">	ll delta = x - y;</span><br><span class="line">	<span class="keyword">if</span> (delta % g) <span class="built_in">cout</span> &lt;&lt; <span class="string">"Impossible\n"</span>;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		pair&lt;ll, ll&gt; pp = exgcd(a, b);</span><br><span class="line">		ll t = pp.first, p = pp.second;</span><br><span class="line">		ll mod = l / g;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; (delta / g * t % mod + mod) % mod &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></div>]]></content>
      <categories>
        <category>POJ</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>POJ</tag>
        <tag>拓展欧几里得定理</tag>
      </tags>
  </entry>
  <entry>
    <title>C Looooops POJ - 2115</title>
    <url>/ZLY201.github.io/2020/07/08/POJ%20-%202115/</url>
    <content><![CDATA[<h2 id="C-Looooops-POJ-2115"><a href="#C-Looooops-POJ-2115" class="headerlink" title="C Looooops POJ - 2115"></a><a href="http://poj.org/problem?id=2115" target="_blank" rel="noopener">C Looooops POJ - 2115</a></h2><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (variable = A; variable != B; variable += C) &#123;</span><br><span class="line">	i = (i % (<span class="number">1</span> &lt;&lt; k));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>给你A，B，C和K问你上述代码中循环的次数是多少</p>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>设运行次数为$N$<br>$(A + C \times N) \bmod {2^{k}} = B$<br>$NC + M2^{k} = B - A$<br>是不是长得很像$ax + by = c$<br>利用拓展欧几里得算法求出最小的N即可</p>
<h3 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h3><div><div class="fold_hider"><div class="close hider_title"></div></div><div class="fold">
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a, ll b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> !b ? a : gcd(b, a % b);</span><br><span class="line">&#125;</span><br><span class="line">pair&lt;ll, ll&gt; exgcd(ll a, ll b) &#123;</span><br><span class="line">	<span class="keyword">if</span> (!b) <span class="keyword">return</span> pair&lt;ll, ll&gt;(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">	pair&lt;ll, ll&gt; temp = exgcd(b, a % b);</span><br><span class="line">	<span class="keyword">return</span> pair&lt;ll, ll&gt;(temp.second, temp.first - a / b * temp.second);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">cin</span>.tie(<span class="number">0</span>), <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">	ll a, b, c, k;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; k) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!a &amp;&amp; !b &amp;&amp; !c &amp;&amp; !k) <span class="keyword">break</span>;</span><br><span class="line">		ll kk = (<span class="number">1l</span>l &lt;&lt; k);</span><br><span class="line">		pair&lt;ll, ll&gt; pp = exgcd(c, kk);</span><br><span class="line">		ll n = pp.first, m = pp.second;</span><br><span class="line">		ll delta = b - a;</span><br><span class="line">		ll g = gcd(c, kk);</span><br><span class="line">		ll mod = kk / g;</span><br><span class="line">		<span class="keyword">if</span> (delta % g) <span class="built_in">cout</span> &lt;&lt; <span class="string">"FOREVER\n"</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; (delta / g * n % mod + mod) % mod &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></div>]]></content>
      <categories>
        <category>POJ</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>POJ</tag>
        <tag>拓展欧几里得定理</tag>
      </tags>
  </entry>
  <entry>
    <title>数论四大定理</title>
    <url>/ZLY201.github.io/2020/07/07/%E6%95%B0%E8%AE%BA%E5%9B%9B%E5%A4%A7%E5%AE%9A%E7%90%86/</url>
    <content><![CDATA[<h2 id="欧几里得算法"><a href="#欧几里得算法" class="headerlink" title="欧几里得算法"></a>欧几里得算法</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>欧几里德算法又称辗转相除法，是指用于计算两个正整数a，b的最大公约数。其公式为$gcd(a, b) = gcd(b, a \bmod b)$</p>
<h3 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h3><p>证明如下：<br>不妨设$a &gt; b$，$gcd(a, b)=n$<br>$a = k_{1}n$，$b = k_{2}n$<br>那么$a - b = (k_{1} - k_{2}) \times n$<br>易得$gcd(a, b) = gcd(b, a - b)=gcd(b, a - 2b)=…=gcd(b, a \bmod b)$</p>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><div><div class="fold_hider"><div class="close hider_title"></div></div><div class="fold">
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a, ll b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> b == <span class="number">0</span> ? a : gcd(b, a % b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></div>
<h2 id="拓展欧几里得算法"><a href="#拓展欧几里得算法" class="headerlink" title="拓展欧几里得算法"></a>拓展欧几里得算法</h2><h3 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h3><p>找到最小的$x$和$y$使得式子$ax + by = gcd(a, b)$成立</p>
<h3 id="求解"><a href="#求解" class="headerlink" title="求解"></a>求解</h3><p>不妨设$x &gt; y$<br>若有$ax + by = gcd(a, b)$<br>必有$bx_{1} + (a \bmod b)y_{1}=gcd(b, a \bmod b) = gcd(a, b)$<br>$bx_{1} + (a - [\frac{a}{b}] \times b)y_{1} = gcd(a, b)$<br>$bx_{1} + ay_{1} - [\frac{a}{b}] \times b \times y = gcd(a, b)$<br>$ay_{1} + (x_{1} - [\frac{a}{b}] \times y_{1})b=gcd(a, b)=ax+by$<br>那么显然存在解$x = y_{1}, y = x_{1} - [\frac{a}{b}] \times y_{1}$</p>
<p>这样就可以对式子进行递归求解了，边界条件为$b = 0$时$x_{k}=1, y_{k}=0$</p>
<p>如果你不希望解出现负数的话，可以使用下面的式子进行处理<br>$x = (x + b) \bmod b \qquad y = (y + a) \bmod a$</p>
<h3 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h3><div><div class="fold_hider"><div class="close hider_title"></div></div><div class="fold">
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">pair&lt;ll, ll&gt; exgcd(ll a, ll b) &#123;</span><br><span class="line">	<span class="keyword">if</span> (!b) <span class="keyword">return</span> pair&lt;ll, ll&gt;(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">	pair&lt;ll, ll&gt; temp = exgcd(b, a % b);</span><br><span class="line">	<span class="keyword">return</span> pair&lt;ll, ll&gt;(temp.second, temp.first - a / b * temp.second);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></div>
<h3 id="拓展1"><a href="#拓展1" class="headerlink" title="拓展1"></a>拓展1</h3><p>找到最小的$x$和$y$使得式子$ax + by = c$成立<br>不妨设$gcd(a, b)=n$<br>$a = k_{1}n$，$b = k_{2}n$<br>那么上式即为$k_{1}n \times x + k_{2}n \times y = c$<br>很显然上式有解的充要条件为$n|c$</p>
<p>我们考虑$ax + by = gcd(a, b)$的最小解为$x和y$<br>那么$\frac{c}{gcd(a, b)} \times (ax + by) = \frac{c}{gcd(a, b)} \times gcd(a, b)$<br>令$x’ = \frac{c}{gcd(a, b)} \times x$，$y’ = \frac{c}{gcd(a, b)} \times y$<br>显然$x’$和$y’$为$ax + by = c$的最小解</p>
<h3 id="拓展2"><a href="#拓展2" class="headerlink" title="拓展2"></a>拓展2</h3><p>若$ab + kp = 1$，即$a \times b \equiv 1 \pmod p$，那么根据拓展欧几里得算法求解出来的$b$即为$a$在模$p$意义下的乘法逆元</p>
<h2 id="中国剩余定理"><a href="#中国剩余定理" class="headerlink" title="中国剩余定理"></a>中国剩余定理</h2><h3 id="描述-2"><a href="#描述-2" class="headerlink" title="描述"></a>描述</h3><p>中国剩余定理又称孙子定理，中国南北朝时期（公元5世纪）的数学著作《孙子算经》卷下第二十六题，叫做“物不知数”问题，原文如下：</p>
<blockquote>
<p>“今有物不知其数，三三数之剩二，五五数之剩三，七七数之剩二，问物几何？”</p>
</blockquote>
<p>意思就是有一个数除3余2，除5余3，除7余2，问你这个数是多少</p>
<p>这类问题在数论中我们把它称作一元线性同余方程组问题，数学公式表述如下：<br>$x \equiv {a_{1}} \pmod {m_{1}}$<br>$x \equiv {a_{2}} \pmod {m_{2}}$<br>$…$<br>$x \equiv {a_{n}} \pmod {m_{n}}$<br>其中$m_{1}, m_{2}, …, m_{n}两两互质$<br>求x的最小非负整数解</p>
<h3 id="求解-1"><a href="#求解-1" class="headerlink" title="求解"></a>求解</h3><p>令$M=\prod_{i=1}^{n}m_{i}$，即$M=lcm(m_{1}, m_{2}, …, m_{n})$<br>设$t_{i}$为$\frac{M}{m_{i}}t_{i} \equiv {1} \pmod {m_{i}}$的最小非负整数解<br>那么$x = \sum_{i=1}^{n}a_{i}\frac{M}{m_{i}}t_{i}$为同余方程组的最小非负整数解<br>而$t_{i}$显然为$\frac{M}{m_{i}}$在模$m_{i}$意义下的乘法逆元（因为$\frac{M}{m_{i}}t_{i} \equiv {1} \pmod {m_{i}}$）</p>
<h3 id="证明-1"><a href="#证明-1" class="headerlink" title="证明"></a>证明</h3><p>将$x = \sum_{i=1}^{n}a_{i}\frac{M}{m_{i}}t_{i}$带入到第$k$个方程中<br>对于$\forall i \neq k$，$a_{i}\frac{M}{m_{i}}t_{i} \equiv {0} \pmod {m_{k}}$，因为$\frac{M}{m_{i}} \bmod m_{k} = 0$<br>对于$i = k$，由于$\frac{M}{m_{i}}t_{i} \equiv {1} \pmod {m_{k}}$，那么自然$a_{i}\frac{M}{m_{i}}t_{i} \equiv {a_{i}} \pmod {m_{k}}$，即得证</p>
<h3 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h3><div><div class="fold_hider"><div class="close hider_title"></div></div><div class="fold">
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">pair&lt;ll, ll&gt; exgcd(ll a, ll b) &#123;</span><br><span class="line">	<span class="keyword">if</span> (!b) <span class="keyword">return</span> pair&lt;ll, ll&gt;(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">	pair&lt;ll, ll&gt; temp = exgcd(b, a % b);</span><br><span class="line">	<span class="keyword">return</span> pair&lt;ll, ll&gt;(temp.second, temp.first - a / b * temp.second);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">CRT</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	ll M = <span class="number">1</span>, res = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) M *= m[i];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">		ll tmp = M / m[i];</span><br><span class="line">		pair&lt;ll, ll&gt; pp = exgcd(tmp, m[i]);</span><br><span class="line">		res = (res + a[i] * pp.first % M * tmp % M) % M;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> (res + M) % M;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></div>
<h2 id="拓展中国剩余定理"><a href="#拓展中国剩余定理" class="headerlink" title="拓展中国剩余定理"></a>拓展中国剩余定理</h2><h3 id="描述-3"><a href="#描述-3" class="headerlink" title="描述"></a>描述</h3><p>$x \equiv {a_{1}} \pmod {m_{1}}$<br>$x \equiv {a_{2}} \pmod {m_{2}}$<br>$…$<br>$x \equiv {a_{n}} \pmod {m_{n}}$<br>不保证$m_{1}, m_{2}, …, m_{n}两两互质$<br>求x的最小非负整数解</p>
<h3 id="求解-2"><a href="#求解-2" class="headerlink" title="求解"></a>求解</h3><p><img src="../数论四大定理/拓展中国剩余定理-1.png" alt=""><br><img src="../数论四大定理/拓展中国剩余定理-2.png" alt=""></p>
<h3 id="Code-3"><a href="#Code-3" class="headerlink" title="Code"></a>Code</h3><div><div class="fold_hider"><div class="close hider_title"></div></div><div class="fold">
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">pair&lt;ll, ll&gt; exgcd(ll a, ll b) &#123;</span><br><span class="line">	<span class="keyword">if</span> (!b) <span class="keyword">return</span> pair&lt;ll, ll&gt;(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">	pair&lt;ll, ll&gt; temp = exgcd(b, a % b);</span><br><span class="line">	<span class="keyword">return</span> pair&lt;ll, ll&gt;(temp.second, temp.first - a / b * temp.second);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">excrt</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	ll aa = a[<span class="number">1</span>], bb = b[<span class="number">1</span>];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">		ll d = gcd(aa, a[i]);</span><br><span class="line">		pair&lt;ll, ll&gt; temp = exgcd(aa / d, a[i] / d);</span><br><span class="line">		<span class="keyword">while</span> (temp.first &lt; <span class="number">0</span>) temp.first += a[i] / d;</span><br><span class="line">		<span class="keyword">if</span> ((b[i] - bb) % d) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		ll p = a[i] / d;</span><br><span class="line">		ll lcm = aa * p;</span><br><span class="line">		bb = ((temp.first * (b[i] - bb) / d % p + p) % p * aa % lcm + bb) % lcm;</span><br><span class="line">		aa = lcm;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> bb;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></div>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>1.中国剩余定理与扩展中国剩余定理-csdn<br><a href="https://blog.csdn.net/enjoy_pascal/article/details/98521475" target="_blank" rel="noopener">https://blog.csdn.net/enjoy_pascal/article/details/98521475</a></p>
<p>2.孙子定理-百度百科<br><a href="https://baike.baidu.com/item/%E5%AD%99%E5%AD%90%E5%AE%9A%E7%90%86/2841597" target="_blank" rel="noopener">https://baike.baidu.com/item/%E5%AD%99%E5%AD%90%E5%AE%9A%E7%90%86/2841597</a></p>
<p>3.拓展欧几里得算法-简书<br><a href="https://www.jianshu.com/p/9d60995a0e89" target="_blank" rel="noopener">https://www.jianshu.com/p/9d60995a0e89</a></p>
]]></content>
      <categories>
        <category>数论</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>欧几里得定理</tag>
        <tag>拓展欧几里得定理</tag>
        <tag>中国剩余定理</tag>
        <tag>拓展中国剩余定理</tag>
      </tags>
  </entry>
  <entry>
    <title>LCM Extreme LightOJ - 1375</title>
    <url>/ZLY201.github.io/2020/07/06/LightOJ%20-%201375/</url>
    <content><![CDATA[<h2 id="LCM-Extreme-LightOJ-1375"><a href="#LCM-Extreme-LightOJ-1375" class="headerlink" title="LCM Extreme LightOJ - 1375"></a><a href="http://lightoj.com/volume_showproblem.php?problem=1375" target="_blank" rel="noopener">LCM Extreme LightOJ - 1375</a></h2><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="title">allPairLcm</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">            res += lcm(i, j); <span class="comment">// lcm means least common multiple</span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>给出n，输出上述程序的运行结果</p>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>$res=\sum_{i=1}^{n}\sum_{j=i+1}^{n}lcm(i, j)=\sum_{i=2}^{n}\sum_{j=1}^{i-1}lcm(i, j)$<br>令$s(x)=\sum_{i=1}^{x-1}lcm(i, x)$，那么答案就是$\sum_{i=2}^{n}s(i)$，显然可以预处理<br>对于$s(x)$，有：<br>$s(x)=\sum_{i=1}^{x-1}lcm(i, x)=\sum_{i=1}^{x-1}\frac{i \times x}{gcd(i, x)}=x \times \sum_{i=1}^{x-1}\frac{i}{gcd(i, x)}$<br>令$g = gcd(i, x)$<br>$s(x)=x \times \sum_{i=1}^{x-1}\frac{i}{g}$<br>其中$g|x$，并且$gcd(i, x) = g$<br>令$i = \frac{i}{g}$，那么$s(x)=x \times \sum_{i=1}^{\frac{x}{g}-1}i$<br>其中$gcd(i, \frac{x}{g})=1$，即$i$与$\frac{x}{g}$互质<br>由欧拉定理可知</p>
<blockquote>
<p>小于$n$，且与$n$互质的数之和等于$\frac{n \times \phi(n)}{2}$</p>
</blockquote>
<p>那么$s(x)=x \times \sum_{g|x}\frac{\frac{x}{g} \times \phi(\frac{x}{g})}{2}$<br>这样我们预处理出$\phi(n)$，然后枚举$g$求出$s(x)$，最后求出前缀和即可</p>
<h3 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h3><div><div class="fold_hider"><div class="close hider_title"></div></div><div class="fold">
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">3e6</span> + <span class="number">10</span>;</span><br><span class="line">ll phi[maxn];</span><br><span class="line">ll s[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">eulor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	phi[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; maxn; ++i) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!phi[i]) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; maxn; j += i) &#123;</span><br><span class="line">				<span class="keyword">if</span> (!phi[j]) phi[j] = j;</span><br><span class="line">				phi[j] = phi[j] / i * (i - <span class="number">1</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> g = <span class="number">1</span>; g &lt; maxn; ++g) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> x = g; x &lt; maxn; x += g) &#123;</span><br><span class="line">			<span class="keyword">int</span> t = x / g;</span><br><span class="line">			s[x] += phi[t] * t / <span class="number">2</span> * x;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; maxn; ++i) &#123;</span><br><span class="line">		s[i] += s[i - <span class="number">1</span>];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> T;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">	<span class="keyword">int</span> cas = <span class="number">0</span>;</span><br><span class="line">	eulor();</span><br><span class="line">	<span class="keyword">while</span> (T--) &#123;</span><br><span class="line">		<span class="keyword">int</span> n;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Case %d: %llu\n"</span>, ++cas, s[n]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></div>
<h3 id="编写参考"><a href="#编写参考" class="headerlink" title="编写参考"></a>编写参考</h3><p><a href="https://www.cnblogs.com/-Wallace-/p/12897967.html" target="_blank" rel="noopener">https://www.cnblogs.com/-Wallace-/p/12897967.html</a></p>
]]></content>
      <categories>
        <category>LightOJ</category>
      </categories>
      <tags>
        <tag>LightOJ</tag>
        <tag>数论</tag>
        <tag>欧拉函数</tag>
      </tags>
  </entry>
  <entry>
    <title>Bank Robbery LightOJ - 1163</title>
    <url>/ZLY201.github.io/2020/07/06/LightOJ%20-%201163/</url>
    <content><![CDATA[<h2 id="Bank-Robbery-LightOJ-1163"><a href="#Bank-Robbery-LightOJ-1163" class="headerlink" title="Bank Robbery LightOJ - 1163"></a><a href="http://lightoj.com/volume_showproblem.php?problem=1163" target="_blank" rel="noopener">Bank Robbery LightOJ - 1163</a></h2><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>给你k，输出所有使得$A - [\frac{A}{10}] = K$成立的A</p>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>$A - [\frac{A}{10}] = K$<br>$A - \frac{A - A % 10}{10} = k$<br>$9A = 10k - A % 10$<br>$9A = 10k - m$</p>
<p>由于$0\leq m \leq 9$，直接枚举即可</p>
<p>要注意这题longlong会溢出</p>
<h3 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h3><div><div class="fold_hider"><div class="close hider_title"></div></div><div class="fold">
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">3e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> T;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">	<span class="keyword">int</span> cas = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (T--) &#123;</span><br><span class="line">		ll n;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;n);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Case %d:"</span>, ++cas);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">9</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">			<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> tmp = <span class="number">10</span> * n - i;</span><br><span class="line">			<span class="keyword">if</span> (tmp % <span class="number">9</span> == <span class="number">0</span> &amp;&amp; tmp / <span class="number">9</span> % <span class="number">10</span> == i) <span class="built_in">printf</span>(<span class="string">" %lld"</span>, tmp / <span class="number">9</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></div>]]></content>
      <categories>
        <category>LightOJ</category>
      </categories>
      <tags>
        <tag>LightOJ</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>Finding LCM LightOJ - 1215</title>
    <url>/ZLY201.github.io/2020/07/06/LightOJ%20-%201215/</url>
    <content><![CDATA[<h2 id="Finding-LCM-LightOJ-1215"><a href="#Finding-LCM-LightOJ-1215" class="headerlink" title="Finding LCM LightOJ - 1215"></a><a href="http://lightoj.com/volume_showproblem.php?problem=1215" target="_blank" rel="noopener">Finding LCM LightOJ - 1215</a></h2><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>$LCM(a, b, c) = L$<br>现在告诉你a, b, L，问你c的最小值是多少</p>
<h3 id="解题思路（一）"><a href="#解题思路（一）" class="headerlink" title="解题思路（一）"></a>解题思路（一）</h3><p>设$lcm = LCM(a, b)$，即求最小的c使得$LCM(lcm, c) = L$<br>设$g = gcd(lcm, c)$，那么$\frac{lcm \times c}{g}=L$<br>$c = \frac{L}{lcm} \times g$<br>设$k = \frac{L}{lcm}$，那么$c = k \times g$<br>又因为$gcd(lcm, c) = g$<br>所以$gcd(lcm, k \times g) = g$<br>即$gcd(\frac{lcm}{g}, k) = 1$<br>由于$k$已知，要使$c$最小即使$g$最小，其中$g|lcm$<br>那么我们$O(\sqrt{n})$时间找到最小能够使得$gcd(\frac{lcm}{g}, k) = 1$成立的$lcm$的因子即可</p>
<h3 id="AC代码（一）"><a href="#AC代码（一）" class="headerlink" title="AC代码（一）"></a>AC代码（一）</h3><div><div class="fold_hider"><div class="close hider_title"></div></div><div class="fold">
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">3e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a, ll b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> b == <span class="number">0</span> ? a : gcd(b, a % b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> T;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">	<span class="keyword">int</span> cas = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (T--) &#123;</span><br><span class="line">		ll a, b, l;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%lld%lld%lld"</span>, &amp;a, &amp;b, &amp;l);</span><br><span class="line">		ll lcm = a / gcd(a, b) * b;</span><br><span class="line">		<span class="keyword">if</span> (l % lcm) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"Case %d: impossible\n"</span>, ++cas);</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		ll k = l / lcm;</span><br><span class="line">		ll kk = <span class="built_in">sqrt</span>(lcm);</span><br><span class="line">		ll ans = l;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= kk; ++i) &#123;</span><br><span class="line">			<span class="keyword">if</span> (lcm % i == <span class="number">0</span>) &#123;</span><br><span class="line">				<span class="keyword">if</span> (gcd(lcm / i, k) == <span class="number">1</span>)</span><br><span class="line">					ans = min(ans, <span class="number">1l</span>l * i * k);</span><br><span class="line">				<span class="keyword">if</span> (gcd(i, k) == <span class="number">1</span>)</span><br><span class="line">					ans = min(ans, lcm / i * k);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Case %d: %lld\n"</span>, ++cas, ans);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></div>
<h3 id="解题思路（二）"><a href="#解题思路（二）" class="headerlink" title="解题思路（二）"></a>解题思路（二）</h3><p>根据思路一中的结论，我们得到了$gcd(\frac{lcm}{g}, k) = 1$，并且$c=k \times g$<br>那么我们接下来进行这么一系列操作<br>令$g_{1}=gcd(lcm, k)$<br>$g_{2}=gcd(\frac{lcm}{g_{1}},k \times g_{1})$<br>$…$<br>$g_{k + 1} = gcd(\frac{lcm}{g_{1}g_{2}…g_{n}}, k \times g_{1}g_{2}…g_{n})$<br>那么当$n$增大到一定范围时$g_{n + 1} = gcd(\frac{lcm}{g_{1}g_{2}…g_{n}}, k \times g_{1}g_{2}…g_{n})$必定等于1<br>现在我令$g=g_{1}g_{2}…g_{n}$<br>那么$gcd(\frac{lcm}{g}, k \times g)=1$<br>显然$gcd(\frac{lcm}{g}, k)=1$，因为$\frac{lcm}{g}$中一定不会包含任何一个与$k$有关的因子，不然就不满足$gcd(\frac{lcm}{g}, k \times g)=1$<br>所以$c=k \times g$为一个满足条件的解<br>现在证明它是最小的<br>由于$\frac{c}{gcd(lcm, c)}=k$，在$k$已知的情况下要想$c$最小，那么$gcd(lcm, c)$要最小<br>现在$c=k \times g$，那么$gcd(lcm, c)=g=g_{1}g_{2}…g_{n}$，你会发现它的确是最小的，因为你去除任意一个$g_{i}$均会使得<br>$gcd(\frac{lcm}{g_{1}g_{2}…g_{n}}, k \times g_{1}g_{2}…g_{i-1}g_{i+1}…g_{n}) = g_{i} &gt; 1$<br>而如果你去除$g_{i}$后在$g$加入一个无关的因子$g_{m}$，其中$g_{m}&lt;g_{i}$，则会导致$LCM(a, b, c) \neq L$<br>综上所述$c = k \times g_{1}g_{2}…g_{n}$为所求最优解<br>证毕</p>
<p>所以我们使用循环或递归来求出$g_{1}g_{2}…g_{n}$，那么答案即为$k \times g_{1}g_{2}…g_{n}$</p>
<h3 id="AC代码（二）"><a href="#AC代码（二）" class="headerlink" title="AC代码（二）"></a>AC代码（二）</h3><div><div class="fold_hider"><div class="close hider_title"></div></div><div class="fold">
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a, ll b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> b == <span class="number">0</span> ? a : gcd(b, a % b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> T;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">	<span class="keyword">int</span> cas = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (T--) &#123;</span><br><span class="line">		ll a, b, l;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%lld%lld%lld"</span>, &amp;a, &amp;b, &amp;l);</span><br><span class="line">		ll lcm = a / gcd(a, b) * b;</span><br><span class="line">		<span class="keyword">if</span> (l % lcm) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"Case %d: impossible\n"</span>, ++cas);</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		ll k = l / lcm;</span><br><span class="line">		<span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">			ll g = gcd(lcm, k);</span><br><span class="line">			<span class="keyword">if</span> (g == <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">			k *= g;</span><br><span class="line">			lcm /= g;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Case %d: %lld\n"</span>, ++cas, k);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></div>
]]></content>
      <categories>
        <category>LightOJ</category>
      </categories>
      <tags>
        <tag>LightOJ</tag>
        <tag>数论</tag>
        <tag>欧几里得定理</tag>
      </tags>
  </entry>
  <entry>
    <title>A New Function LightOJ - 1098</title>
    <url>/ZLY201.github.io/2020/07/06/LightOJ%20-%201098/</url>
    <content><![CDATA[<h2 id="A-New-Function-LightOJ-1098"><a href="#A-New-Function-LightOJ-1098" class="headerlink" title="A New Function LightOJ - 1098"></a><a href="http://lightoj.com/volume_showproblem.php?problem=1098" target="_blank" rel="noopener">A New Function LightOJ - 1098</a></h2><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>定义$SOD(n)$为$n$除$1$和$n$外的所有正因子之和，例如：<br>$SOD(24)=2+3+4+6+8+12=35$<br>定义$CSOD(n)=\sum_{i=1}^{n}SOD(i)$<br>让你求$2e9$内任意n的$CSOD(n)$</p>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>对于每一个数，我们可以把它写成$a \times b$的形式，那么对于答案的贡献显然就是$a+b(a!=b!=1!=n)$，而对于一个因子$i$，它在$n$内出现的次数应当是$\frac{n}{i}-1$，举个例子：<br>假设$n = 12$<br>$i = 2$时<br>$4 = 2 \times 2$<br>$6 = 2 \times 3$<br>$8 = 2 \times 4$<br>$10 = 2 \times 5$<br>$12 = 2 \times 6$<br>$2$需要被统计$\frac{12}{2}-1= 5$次</p>
<p>但是这样的复杂度是$O(n)$，显然不可行，观察上例，发现右边的因子是连续的，并且根据左边因子的出现次数我们可以得到一个等差数列，这样一来，我们就可以在$O(\sqrt{n})$时间内求出答案</p>
<p>这样做有一个问题，如果对于每一个左因子我统计$\frac{n}{i}-1$次，然后统计右边因子，会出现重复</p>
<p>承接上例<br>$i = 3$时<br>$6 = 3 \times 2$<br>$9 = 3 \times 3$<br>$12 = 3 \times 4$<br>对于$6$来说$6 = 3 \times 2$已经在统计$2$的时候统计过了，所以我们统计时右边因子的左区间为$i + 1$，右区间为$\frac{n}{i}$，然后单独计算平方数的贡献即可</p>
<h3 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h3><div><div class="fold_hider"><div class="close hider_title"></div></div><div class="fold">
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> T;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">	<span class="keyword">int</span> cas = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (T--) &#123;</span><br><span class="line">		<span class="keyword">int</span> n;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">		ll res = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> k = <span class="built_in">sqrt</span>(n);</span><br><span class="line">		<span class="comment">//枚举左边因子</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= k; ++i) &#123;</span><br><span class="line">			res += i;	<span class="comment">//单独统计平方数的因子</span></span><br><span class="line">			<span class="comment">//右边因子的等差数列区间</span></span><br><span class="line">			ll l = i + <span class="number">1</span>, r = n / i;</span><br><span class="line">			<span class="keyword">if</span> (r &lt; l) <span class="keyword">continue</span>;</span><br><span class="line">			res += (r - l + <span class="number">1</span>) * i + (r - l + <span class="number">1</span>) * (l + r) / <span class="number">2</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Case %d: %lld\n"</span>, ++cas, res);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></div>
]]></content>
      <categories>
        <category>LightOJ</category>
      </categories>
      <tags>
        <tag>LightOJ</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>How Many Points? LightOJ - 1077</title>
    <url>/ZLY201.github.io/2020/07/05/LightOJ%20-%201077/</url>
    <content><![CDATA[<h2 id="How-Many-Points-LightOJ-1077"><a href="#How-Many-Points-LightOJ-1077" class="headerlink" title="How Many Points? LightOJ - 1077"></a><a href="http://lightoj.com/volume_showproblem.php?problem=1077" target="_blank" rel="noopener">How Many Points? LightOJ - 1077</a></h2><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>多组输入，每次给你两个坐标，问你这两点连成的线段上坐标均为整数的个数是多少</p>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>考虑x，y为满足条件的一组坐标，那么有</p>
<p>$\frac{y_{2}-y_{1}}{x_{2}-x_{1}}=\frac{y-y_{1}}{x-x_{1}}$</p>
<p>将$(x_{1}, y_{1})$当做坐标原点，则有</p>
<p>$\frac{y_{2}}{x_{2}}=\frac{y}{x}$</p>
<p>$\frac{ngcd(y_{2},x_{2})}{mgcd(y_{2},x_{2})}=\frac{n}{m}=\frac{2n}{2m}=…=\frac{ngcd(y_{2},x_{2})}{mgcd(y_{2},x_{2})}$</p>
<p>那么其总个数即为$gcd(abs(x_{2}-x_{1}), abs(y_{2}-y_{1})) + 1$</p>
<h3 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h3><div><div class="fold_hider"><div class="close hider_title"></div></div><div class="fold">
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll x, ll y)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> y == <span class="number">0</span> ? x : gcd(y, x % y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> T;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">	<span class="keyword">int</span> cas = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (T--) &#123;</span><br><span class="line">		ll x1, y1, x2, y2;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%lld%lld%lld%lld"</span>, &amp;x1, &amp;y1, &amp;x2, &amp;y2);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Case %d: %lld\n"</span>, ++cas, gcd(<span class="built_in">abs</span>(x1 - x2), <span class="built_in">abs</span>(y1 - y2)) + <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></div>]]></content>
      <categories>
        <category>LightOJ</category>
      </categories>
      <tags>
        <tag>LightOJ</tag>
        <tag>数学</tag>
        <tag>数论</tag>
        <tag>欧几里得定理</tag>
      </tags>
  </entry>
  <entry>
    <title>Digits of Factorial LightOJ - 1045</title>
    <url>/ZLY201.github.io/2020/07/05/LightOJ%20-%201045/</url>
    <content><![CDATA[<h2 id="Digits-of-Factorial-LightOJ-1045"><a href="#Digits-of-Factorial-LightOJ-1045" class="headerlink" title="Digits of Factorial LightOJ - 1045"></a><a href="http://lightoj.com/volume_showproblem.php?problem=1045" target="_blank" rel="noopener">Digits of Factorial LightOJ - 1045</a></h2><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>多组输入，每次给你一个n和m，输出n的阶乘在m进制下的位数</p>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>考虑n!在m下的位数是k，则有：</p>
<p>$m^{k-1}\leq n!&lt;m^{k}$</p>
<p>$k-1\leq log_{m}^{n!}&lt;k$</p>
<p>$k-1\leq log_{m}^{1} + log_{m}^{2} + … + log_{m}^{n}&lt;k$</p>
<p>那么预处理处范围内的lg和，最后利用$log_{m}^{n}=\frac {lg^{n}}{lg^{m}}$进行求解即可</p>
<h3 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h3><div><div class="fold_hider"><div class="close hider_title"></div></div><div class="fold">
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">double</span> sum[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> T;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">	<span class="keyword">int</span> cas = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; maxn; ++i) &#123;</span><br><span class="line">		sum[i] = sum[i - <span class="number">1</span>] + <span class="built_in">log</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (T--) &#123;</span><br><span class="line">		<span class="keyword">int</span> n, m;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">		<span class="keyword">double</span> res = sum[n] / <span class="built_in">log</span>(m);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Case %d: %d\n"</span>, ++cas, <span class="keyword">int</span>(res) + <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></div>
]]></content>
      <categories>
        <category>LightOJ</category>
      </categories>
      <tags>
        <tag>LightOJ</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>唯一分解定理</title>
    <url>/ZLY201.github.io/2020/07/05/%E5%94%AF%E4%B8%80%E5%88%86%E8%A7%A3%E5%AE%9A%E7%90%86/</url>
    <content><![CDATA[<h2 id="唯一分解定理"><a href="#唯一分解定理" class="headerlink" title="唯一分解定理"></a>唯一分解定理</h2><p>根据欧拉定理，一个数n可以被写成如下格式</p>
<p>$n = p_{1}^{a_{1}}p_{2}^{a_{2}}p_{3}^{a_{3}}…p_{k}^{a_{k}}$</p>
<p>其中$p_{i}$为n的质因子</p>
<p>那么有如下结论</p>
<ol>
<li>设$F(n)$代表n的正因子数目，则$F(n) = (a_{1}+ 1)(a_{2} + 1)(a_{3} + 1)…(a_{n} + 1)$</li>
<li>设$G(n)$代表n的正因子之和，则<br>$G(n) = (1 + p_{1} + p_{1}^{2}+…+p_{1}^{a_{1}})(1 + p_{2} + p_{2}^{2}+…+p_{2}^{a_{2}})…(1 + p_{k} + p_{2}^{3}+…+p_{k}^{a_{k}})=\prod_{i=1}^{n}(\frac{p_{i}^{a_{i} + 1}-1}{p_{i}-1})$</li>
</ol>
<h2 id="例题：Trailing-Zeroes-I-LightOJ-1028"><a href="#例题：Trailing-Zeroes-I-LightOJ-1028" class="headerlink" title="例题：Trailing Zeroes (I) LightOJ - 1028"></a>例题：<a href="http://http://lightoj.com/volume_showproblem.php?problem=1028" target="_blank" rel="noopener">Trailing Zeroes (I) LightOJ - 1028</a></h2><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>有多组输入，每次给你一个正整数n，问你n的除1之外的正因子数目</p>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>因为有多组输入，那么如果对于每一个n进行暴力统计显然会超时，可以先预处理出$10^{6}$以内的质数，然后对n进行质数分解，使用公式1进行求解</p>
<h3 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h3><div><div class="fold_hider"><div class="close hider_title"></div></div><div class="fold">
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line"><span class="keyword">bool</span> check[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; maxn; ++i) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!check[i]) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = (i &lt;&lt; <span class="number">1</span>); j &lt; maxn; j += i) &#123;</span><br><span class="line">				check[j] = <span class="literal">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			v.push_back(i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">eulor</span><span class="params">(ll n)</span> </span>&#123;</span><br><span class="line">	ll res = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> len = v.size();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; ll(v[i]) * v[i] &lt;= n &amp;&amp; i &lt; len; ++i) &#123;</span><br><span class="line">		<span class="keyword">if</span> (n % v[i] == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">while</span> (n % v[i] == <span class="number">0</span>) &#123;</span><br><span class="line">				n /= v[i];</span><br><span class="line">				++cnt;</span><br><span class="line">			&#125;</span><br><span class="line">			res *= (cnt + <span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (n &gt; <span class="number">1</span>) res *= <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">return</span> res - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> T;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">	<span class="keyword">int</span> cas = <span class="number">0</span>;</span><br><span class="line">	prime();</span><br><span class="line">	<span class="keyword">while</span> (T--) &#123;</span><br><span class="line">		ll n;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;n);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Case %d: %lld\n"</span>, ++cas, eulor(n));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></div>]]></content>
      <categories>
        <category>数论</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>唯一分解定理</tag>
      </tags>
  </entry>
  <entry>
    <title>欧拉函数</title>
    <url>/ZLY201.github.io/2020/07/05/%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h2 id="欧拉函数"><a href="#欧拉函数" class="headerlink" title="欧拉函数"></a>欧拉函数</h2><p>对于一个正整数x，小于且和x互质的正整数（包括1）的个数，计做$\phi(x)$</p>
<p>其通项公式为$\phi(x)=x\prod_{i=1}^{n}(1-\frac{1}{p_{i}})$</p>
<p>其中$p_{i}$代表x的某一个质因数，n为质因数个数</p>
<p>特别的，我们规定$\phi(1)=1$</p>
<p>那么我们根据公式可以求出任意正整数x的$\phi(x)$值，代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ll <span class="title">eular</span><span class="params">(ll n)</span> </span>&#123;</span><br><span class="line">    ll res = n;</span><br><span class="line">    ll k = <span class="built_in">sqrt</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= k; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(n % i == <span class="number">0</span>) &#123;</span><br><span class="line">            res = res / i * (i - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">while</span>(n % i == <span class="number">0</span>) n /= i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n &gt; <span class="number">1</span>) res = res / n * (n - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是如果实时让你输出任意指定范围内x的$\phi(x)$值，上述代码的时间复杂度显然不满足要求，于是我们采取打表的方法求出1-n中所有数的$\phi(x)$值，代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">euler</span><span class="params">(ll n)</span> </span>&#123;</span><br><span class="line">	phi[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!phi[i]) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt;= n; j += i) &#123;</span><br><span class="line">				<span class="keyword">if</span> (!phi[j]) phi[j] = j;</span><br><span class="line">				phi[j] = phi[j] / i * (i - <span class="number">1</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="欧拉函数的性质"><a href="#欧拉函数的性质" class="headerlink" title="欧拉函数的性质"></a>欧拉函数的性质</h2><ol>
<li><p>若n是质数p的k次幂，即$n=p^{k}$，那么有$\phi(n)=(p-1)p^{k-1}$</p>
</li>
<li><p>若n与m互质，那么$\phi(nm)=(n-1)(m-1)=\phi(n)\phi(m)$</p>
</li>
<li><p>若n为奇数，则$\phi(n)=\phi(2n)$</p>
</li>
<li><p>小于n，且与n互质的数之和为$\frac{n \times \phi(n)}{2}$</p>
</li>
</ol>
<h2 id="例题：Mathematically-Hard-LightOJ-1007"><a href="#例题：Mathematically-Hard-LightOJ-1007" class="headerlink" title="例题：Mathematically Hard LightOJ - 1007"></a>例题：<a href="http://lightoj.com/volume_showproblem.php?problem=1007" target="_blank" rel="noopener">Mathematically Hard LightOJ - 1007</a></h2><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>给你正整数a和b，定义$score(x) = n^{2}$，其中n为小于x的质因子的个数，问你区间[a, b]内score(i)的和是多少</p>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>根据定义可知$n = \phi(x)$，那么我们使用打表法线性求出范围内的$\phi(x)$求平方和即可</p>
<h3 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h3><div><div class="fold_hider"><div class="close hider_title"></div></div><div class="fold">
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">5e6</span> + <span class="number">10</span>;</span><br><span class="line">ll phi[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">euler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	phi[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; maxn; ++i) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!phi[i]) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; maxn; j += i) &#123;</span><br><span class="line">				<span class="keyword">if</span> (!phi[j]) phi[j] = j;</span><br><span class="line">				phi[j] = phi[j] / i * (i - <span class="number">1</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; maxn; ++i) &#123;</span><br><span class="line">		phi[i] = phi[i - <span class="number">1</span>] + phi[i] * phi[i];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> T;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">	<span class="keyword">int</span> cas = <span class="number">0</span>;</span><br><span class="line">	euler();</span><br><span class="line">	<span class="keyword">while</span> (T--) &#123;</span><br><span class="line">		<span class="keyword">int</span> a, b;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Case %d: %llu\n"</span>, ++cas, phi[b] - phi[a - <span class="number">1</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></div>]]></content>
      <categories>
        <category>数论</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>欧拉函数</tag>
      </tags>
  </entry>
</search>
